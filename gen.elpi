
accumulate coq-lib.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Utilities %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% same-root X Y
%            i i
% Resolves only if the two terms are application of the same function/constructor
type same-root term -> term -> prop.
same-root X X.
same-root X (app [Y|_]) :- same-root X Y.
same-root (app [X|_]) Y :- same-root X Y.

%% do-apply T Params Out
%           i i      o
% Do the beta reduction of app [T|Params] (only on Params, does not beta reduce
% T)
type do-apply term -> list term -> term -> prop.
do-apply (lam _ _ Bo) [T|Ts] Out :-
    do-apply (Bo T) Ts Out.
do-apply (prod _ _ Bo) [T|Ts] Out :-
    do-apply (Bo T) Ts Out.
do-apply Out [] Out.

%% flip Prop Out
%       i    o
% Same as Haskell's flip but for propositions
type flip (A -> B -> C -> prop) -> B -> A -> C -> prop.
flip F B A C :-
    F A B C.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% API %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type phi string -> term -> list term -> term -> term -> prop.
type doConst string -> term -> term -> list term -> term -> prop.
type doCon   string -> term -> term -> term -> term -> prop.
type doInl   string -> term -> term -> term -> term -> prop.
type doInr   string -> term -> term -> term -> term -> prop.
type doPair  string -> term -> term -> term -> term -> term -> prop.
type doUnit  string -> term -> term -> prop.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%% Constructor conversion %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

kind constructor type.
type cinr  constructor -> constructor.
type cinl  constructor -> constructor.
type cprod constructor -> constructor -> constructor.
type ccon  term -> constructor -> constructor.
type cvar  term -> constructor.
type cunit constructor.

type term-con       constructor -> term.
type term-sum-type  term -> term -> term.
type term-prod-type term -> term -> term.
type term-unit-type term.

type match-sum     term -> term -> term -> term.
type match-prod    term -> term -> term.
type abstract-type term -> term -> term -> term.
type lift1         (constructor -> constructor) -> term -> term.
type lift2         (constructor -> constructor -> constructor) -> term -> term -> term.

%% abstract-constructor Type LC C Params Out
%                       i    i  i i      o
%   Type   : the type we're abstracting one of the constructor
%   LC     : the list of constructors of the type (possibly partially applied)
%   C      : one of the constructor of the list
%   Params : the parameters of C used to build the instance of type
%   Out    : the corresponding instance of type constructor without the con
type abstract-constructor term -> list term -> term -> list term -> constructor -> prop.
abstract-constructor Type LC C Params (ccon Type Out) :-
    abstract-constructor-sum LC C Params Out.

%% abstract-constructor-sum LC C Params Out
%                           i  i i      o
%   LC     : the list of constructors of the type (possibly partially applied)
%   C      : one of the constructor of the list
%   Params : the parameters of C used to build the instance of type
%   Out    : the corresponding instance of type constructor without the con
type abstract-constructor-sum list term -> term -> list term -> constructor -> prop.
abstract-constructor-sum [C] Cs Params Out :-
    % Here we assume C = Cs
    abstract-constructor-pairs Params Out.
abstract-constructor-sum [C|LC] Cs Params (cinl Out) :-
    C = Cs,
    abstract-constructor-pairs Params Out.
abstract-constructor-sum [C|LC] Cs Params (cinr Out) :-
    not (C = Cs),
    abstract-constructor-sum LC Cs Params Out.

%% abstract-constructor-pairs Params Out
%                             i      o
%   Params : the parameters of the constructor
%   Out    : the parameters grouped in the form (cprod (cvar p1) (cprod ...))
type abstract-constructor-pairs list term -> constructor -> prop.
abstract-constructor-pairs [P] (cvar P).
abstract-constructor-pairs [P|Params] (cprod (cvar P) Out) :-
    abstract-constructor-pairs Params Out.
abstract-constructor-pairs [] cunit.

abstract-constructor-test :-
    coq-locate "LamC" Type, Type = indt GR,
    coq-env-indt GR tt _ _ TY LC _,
    (pi a b\ abstract-constructor Type LC {{Abs}} [a, b] (Out a b)),
    coq-say Out.

%% concretise-constructor Abs C Params
%                         i   o o
concretise-constructor (ccon Type X) C Params :-
    get-type-information Type [] _ LC _,
    concretise-constructor-sum LC X C Params.

%% concretise-constructor-sum LC Abs C Params
%                             i  i   o o
concretise-constructor-sum [C|LC] (cinl X) C Params :-
    concretise-constructor-prod X Params.
concretise-constructor-sum [C] X C Params :-
    concretise-constructor-prod X Params.
concretise-constructor-sum [C|LC] (cinr X) C' Params :-
    concretise-constructor-sum LC X C' Params.

%% concretise-constructor-prod Abs Params
%                              i   o
concretise-constructor-prod (cprod (cvar X) O) [X|O'] :-
    concretise-constructor-prod O O'.
concretise-constructor-prod (cvar X) [X].
concretise-constructor-prod cunit    [].

concretise-constructor-test :-
    coq-locate "LamC" Type,
    Term = (a\ b\ ccon Type (cinr (cinl (cprod (cvar a) (cvar b))))),
    (pi a b\ concretise-constructor (Term a b) (C a b) (P a b)),
    coq-say C,
    coq-say P.

%% get-type-information Tp Params TY LC LT
%                       i  i      o  o  o
%   Tp     : a coq type potentially partially applied
%   Params : parameters for Tp
%   TY     : the type of app [Tp|Params]
%   LC     : the constructors of app [Tp|Params]
%   LT     : their types
get-type-information (app [X|Prs]) Params TY LC LT :-
    append Prs Params Params',
    get-type-information X Params' TY LC LT.
get-type-information (indt GR) Params TY LC LT :-
    coq-env-indt GR tt _ _ TY' LC' LT',
    do-apply TY' Params TY,
    map LC' ((flip mk-app) Params) LC,
    map LT' ((flip do-apply) Params) LT.

get-type-information-test :-
    coq-locate "LamC" Type,
    (pi a\ get-type-information (app [Type,a]) [] (TY a) (LC a) (LT a)),
    coq-say TY,
    coq-say LC,
    coq-say LT.

%% make-abstract-type ITp OTp
%                     i   o
make-abstract-type ITp OTp :-
    get-type-information ITp [] _ _ LT,
    make-abstract-type-sum LT OTp.

%% make-abstract-type-sum LC LT Out
%                         i  i  o
%   LT  : their types
%   Out : the type of the type considered in terms of sums of prods
make-abstract-type-sum [T] T1 :-
    make-abstract-type-prod {prod-2-lam T} T1.
make-abstract-type-sum [T|LT] (term-sum-type T1 T2) :-
    make-abstract-type-prod {prod-2-lam T} T1,
    make-abstract-type-sum LT T2.

%% make-abstract-type-prod T Out
%                          i o
%   T   : its type
%   Out : its type in terms of prods
make-abstract-type-prod (lam N T Bo) Out :-
    (pi x\ make-abstract-type-prod (Bo x) T'),
    make-prod T T' Out.
make-abstract-type-prod _ term-unit-type.

make-prod T term-unit-type T.
make-prod T T' (term-prod-type T T').

make-abstract-type-test :-
    coq-locate "LamC" Type,
    make-abstract-type (app [Type, {{nat}}]) OTp,
    coq-say OTp.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% Creating the type %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% derive-type Name Type TS Tp N TY
%              i    i    i  i  o o
% Builds the type of the derived function using the information in (phi Name)
% for the type Type, with arguments TS, with Tp being the type of Type (N is
% the index of the recursive argument for the fixpoint)
type derive-type string -> term -> list term -> term -> int -> term -> prop.
derive-type Name Type TS (prod N T Bo) Nn (prod N T Out) :-
    (pi t\ derive-type-acc Name Type t T (Bo t) TS [] [] Nn' (Out t)),
    Nn is Nn' + 1.
derive-type Name Type TS (lam N T Bo) Nn Out :-
    derive-type Name Type TS (prod N T Bo) Nn Out.
derive-type Name Type TS _ 0 (prod "a" Type Out) :-
    pi x\ phi Name Type TS x (Out x).

%% derive-type-acc Name Type P TP RTP TS Acc1 Acc2 N Out
%                  i    i    i i  i   i  []   []   o o
%   Name : the name of the description to use
%   Type : the type we're generating for, of kind * => K
%   P    : the parameters of Type
%   TP   : the type of P
%   RTP  : the type of app [Type,P]
%   TS   : the auxiliaries types of the generation, all of kind * => K
%   Acc1 : an accumulator of TS applied, should be set to []
%   Acc2 : an accumulator of the arguments of TS, should be set to []
%   N    : the index of the decreasing argument for the fixpoint
%   Out  : the type of the derivation for Type without the quantification on P
type derive-type-acc    string -> term -> term -> term -> term -> list term
                     -> list term -> list term -> int -> term -> prop.
derive-type-acc Name Type P TP RTP [T|TS] Acc1 Acc2 Nn (prod _ TP Out) :-
    (pi t\ derive-type-acc Name Type P TP RTP TS [app [T,t]|Acc1] [t|Acc2] Nn' (Out t)),
    Nn is Nn' + 1.
derive-type-acc Name Type P TP RTP [] Acc1' Acc2' Nn (prod _ TY _\ TY') :-
    rev Acc1' Acc1, rev Acc2' Acc2,
    derive-type Name P Acc2 TP _ TY,
    derive-type Name (app [Type,P]) Acc1 RTP Nn' TY',
    Nn is Nn' + 1.

derive-type-test :-
    coq-locate "LamC" Type, Type = indt GR,
    coq-env-indt GR tt _ _ TY _ _,
    ((pi a t\ phi "eq" t _ a (prod "b" t _\ {{bool}}))
        => derive-type "eq" Type [] TY N Out),
    coq-say N,
    coq-say Out.

derive-type-test' :-
    coq-locate "LamC" Type, Type = indt GR,
    coq-env-indt GR tt _ _ TY _ _,
    ((pi a t t'\ phi "map" t [t'] a t')
        => derive-type "map" Type [Type] TY N Out),
    coq-say N,
    coq-say Out.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% Fixpoint skeleton %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% rec-for-type Type Fun TFun
%               i    o   o
type rec-for-type term -> term -> term -> prop.

%% fixpoint Name Type TS Out
%           i    i    i  o
%   Name : the name of the generator
%   Type : the type we're generating for
%   TS   : the parameters of the generator
%   Out  : the generated function
type fixpoint string -> term -> list term -> term -> prop.
fixpoint Name Type TS (fix _ Nn TF Out) :-
    get-type-information Type [] TY LC LT,
    derive-type Name Type TS TY Nn TF,
    (pi f\ rec-for-type Type f TF
        => fixpoint-function Name Type LC LT TS TY (Out f)).

fixpoint-test :-
    coq-locate "LamC" Type,
    (pi f\ (pi t\ rec-for-type t f _)
        => fixpoint "eq" Type [] (Out f)),
    (pi f\ expand-term (Out f) (Out' f)),
    coq-say Out'.

%% fixpoint-function Name Type TS TY Out
%                    i    i    i  i  o
%   Name : the name of the generator
%   Type : the type we're generating for
%   LC   : the constructors of Type
%   LT   : their types
%   TS   : the parameters of the generator
%   TY   : the type of Type
%   Out  : the recursive function we need to give to the fixpoint
fixpoint-function Name Type LC LT TS (prod N T Bo) (prod N T Out) :-
    pi t\ fixpoint-function-acc Name Type LC LT t T (Bo t) TS [] [] (Out t).
fixpoint-function Name Type LC LT TS (lam N T Bo) Out :-
    fixpoint-function Name Type LC LT TS (prod N T Bo) Out.
fixpoint-function Name Type LC LT TS _ (prod "a" Type Out) :-
    map2 LC LT (main-match Name Type LC LT []) MTerms,
    Out = a\ match a (lam _ Type _\ hole) MTerms.

%% fixpoint-function-acc Name Type P TP RTP TS Acc1 Acc2 Out
%                        i    i    i i  i   i  []   []   o
%   Name : the name of the description to use
%   Type : the type we're generating for, of kind * => K
%   P    : the parameters of Type
%   TP   : the type of P
%   RTP  : the type of app [Type,P]
%   TS   : the auxiliaries types of the generation, all of kind * => K
%   Acc1 : an accumulator of TS applied, should be set to []
%   Acc2 : an accumulator of the arguments of TS, should be set to []
%   Out  : the type of the derivation for Type without the quantification on P
fixpoint-function-acc Name Type LC LT P TP RTP [T|TS] Acc1 Acc2 (prod _ TP Out) :-
    pi t\ fixpoint-function-acc Name Type LC LT P TP RTP TS [app [T,t]|Acc1] [t|Acc2] (Out t).
fixpoint-function-acc Name Type LC LT P TP RTP [] Acc1' Acc2' (prod _ TY Out) :-
    rev Acc1' Acc1, rev Acc2' Acc2,
    derive-type Name P Acc2 TP _ TY,
    map LC ((flip mk-app) [P]) LC',
    map LT ((flip do-apply) [P]) LT',
    pi f\ rec-for-type TP f TY
              => fixpoint-function Name (app [Type,P]) LC' LT' Acc1 RTP (Out f).

fixpoint-function-test :-
    coq-locate "LamC" Type, Type = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    (pi f\ (pi t\ rec-for-type t f _)
        => fixpoint-function "eq" Type LC LT [] TY (Out f)),
    coq-say Out.

fixpoint-function-test' :-
    coq-locate "LamC" Type, Type = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    ((pi a t t'\ phi "map" t [t'] a t')
        => fixpoint-function "map" Type LC LT [Type] TY Out),
    coq-say Out.

fixpoint-function-test'' :-
    coq-locate "LamC" Type, Type = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    ((pi a t\ phi "other" t [] a (prod "b" t _\ prod "c" {{nat}} _\ {{bool}}))
        => fixpoint-function "other" Type LC LT [] TY Out),
    coq-say Out.

%% main-match Name Type LC LT Params C T Out
%             i    i    i  i  []     i i o
main-match Name Type LC LT Params C (prod N T Bo) (prod N T Out) :-
    pi x\ main-match Name Type LC LT [x|Params] C (Bo x) (Out x).
main-match Name Type LC LT Params C (lam N T Bo) (lam N T Out) :-
    pi x\ main-match Name Type LC LT [x|Params] C (Bo x) (Out x).
main-match Name Type LC LT Params' C _ Out :-
    rev Params' Params,
    abstract-constructor Type LC C Params AST,
    build-operation Name Type Type AST Out.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% Building operation terms %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% build-operation Name Type T Main Phi
%                  i    i    i i    o
build-operation Name Type (term-sum-type T1 T2) (cinr M) Out :-
    build-operation Name Type T2 M Phi,
    doInr Name Type (term-sum-type T1 T2) Phi Out.
build-operation Name Type (term-sum-type T1 T2) (cinl M) Out :-
    build-operation Name Type T1 M Phi,
    doInl Name Type (term-sum-type T1 T2) Phi Out.
build-operation Name Type (term-prod-type T1 T2) (cprod M1 M2) Out :-
    build-operation Name Type T1 M1 Phi1,
    build-operation Name Type T2 M2 Phi2,
    doPair Name Type (term-prod-type T1 T2) Phi1 Phi2 Out.
build-operation Name Type Tp (ccon Tp M) Out :-
    make-abstract-type Tp ATp,
    build-operation Name Type ATp M Phi,
    doCon Name Type Tp Phi Out.
build-operation Name Type term-unit-type cunit Out :-
    doUnit Name Type Out.
build-operation Name Type Tp (cvar M) (app [Fun,M]) :-
    % TODO flatten-app Tp and TFun, and apply them.
    rec-for-type Tp Fun TFun.
% TODO if rec-for-type failed, we need to create and inline the function

build-operation-test :-
    coq-locate "LamC" Type', Type = app [Type', {{nat}}],
    Term = ccon Type (cinl (cprod (ccon Type (cinr (cinr (cvar {{0}}))))
                                  (ccon Type (cinr (cinr (cvar {{0}})))))),
    coq-say Term,
    (pi f\ (pi t\ rec-for-type t f _) => build-operation "eq" Type Type Term (Out f)),
    coq-say Out.

%% expand-term In Out
%              i  o
% Beta reduce all applications and match-*
type expand-term term -> term -> prop.
% Beta reduction
expand-term (app X) Out :-
    append [lam _ _ Bo, Y] L X,
    expand-term (app [Bo Y | L]) Out.
expand-term (app X) Out :-
    append [prod _ _ Bo, Y] L X,
    expand-term (app [Bo Y | L]) Out.
expand-term (app [X]) X' :-
    expand-term X X'.
expand-term (app [X|L]) (app [X'|L']) :-
    expand-term X X',
    X = X',
    map L expand-term L'.
expand-term (app [X|L]) Out :-
    expand-term X X',
    not (X = X'),
    map L expand-term L',
    expand-term (app [X'|L']) Out.
expand-term (lam N T Bo) (lam N T Out) :-
    pi x\ expand-term (Bo x) (Out x).
expand-term (prod N T Bo) (prod N T Out) :-
    pi x\ expand-term (Bo x) (Out x).
expand-term (match T P Brs) (match T' P Brs') :-
    expand-term T T',
    map Brs expand-term Brs'.
expand-term (fix Nm N Tp Bo) (fix Nm N Tp' Bo') :-
    expand-term Tp Tp',
    pi x\ expand-term (Bo x) (Bo' x).
% match-sum
expand-term (match-sum C L R) Out :-
    expand-term C (term-con (cinl X)),
    expand-term (app [L, term-con X]) Out.
expand-term (match-sum C L R) Out :-
    expand-term C (term-con (cinr X)),
    expand-term (app [R, term-con X]) Out.
expand-term (match-sum C _ _) _ :-
    fatal-error "Expanding match-sum with a wrongly typed constructor".
% match-prod
expand-term (match-prod C T) Out :-
    expand-term C (term-con (cprod X Y)),
    expand-term (app [T,term-con X,term-con Y]) Out.
expand-term (match-prod X T) Out :-
    fatal-error "Expanding match-prod with a wrongly typed constructor".
% abstract-type
expand-term (abstract-type Tp X Fun) Out :-
    expand-term Tp Tp',
    get-type-information Tp' [] _ LC LT,
    map2 LC LT (expand-term-abstract-constructor Tp' LC LT Fun []) MTerms,
    expand-term (match X (lam _ Tp' _\ hole) MTerms) Out.
% lift1
expand-term (lift1 F X) (term-con (F C)) :-
    expand-term X (term-con C).
expand-term (lift1 F X) (term-con (F (cvar C))) :-
    expand-term X C.
% lift2
expand-term (lift2 F X Y) (term-con (F C D)) :-
    expand-term X (term-con C),
    expand-term Y (term-con D).
expand-term (lift2 F X Y) (term-con (F (cvar C) D)) :-
    expand-term X C,
    expand-term Y (term-con D).
expand-term (lift2 F X Y) (term-con (F C (cvar D))) :-
    expand-term X (term-con C),
    expand-term Y D.
expand-term (lift2 F X Y) (term-con (F (cvar C) (cvar D))) :-
    expand-term X C,
    expand-term Y D.
% Base case
expand-term X X.

%% expand-term-abstract-constructor Type LC LT Fun Acc C TY Out
%                                   i    i  i  i   []  i i  o
%   Type : the type we're working with
%   LC   : its constructors
%   LT   : their types
%   Fun  : the function to apply at the end
%   Acc  : an accumulator for the term we're abstracting over, should be set to []
%   C    : the constructor we're abstracting for
%   TY   : its type
%   Out  : a term with the same arguments as C applying Fun to the constructor
%          associated to C with the abstracted arguments
expand-term-abstract-constructor Type LC LT Fun Acc C (prod N T Bo) (prod N T Out) :-
    pi x\ expand-term-abstract-constructor Type LC LT Fun [x|Acc] C (Bo x) (Out x).
expand-term-abstract-constructor Type LC LT Fun Acc C (lam N T Bo) (lam N T Out) :-
    pi x\ expand-term-abstract-constructor Type LC LT Fun [x|Acc] C (Bo x) (Out x).
expand-term-abstract-constructor Type LC LT Fun Acc' C _ (app [Fun, term-con AST]) :-
    rev Acc' Acc,
    abstract-constructor Type LC C Acc (ccon _ AST).

expand-term-test :-
    Term = app [(lam _ {{nat}} x\ lam _ {{nat}} y\ app [{{plus}}, x, y]), {{1}}, {{0}}],
    coq-say Term,
    expand-term Term Term',
    coq-say Term'.

expand-term-test' :-
    coq-locate "LamC" Type,
    Term = (lam _ {{Type}} A\ lam _ (app [Type,A]) x\ abstract-type (app [Type,A]) x
        (lam _ _ s1\ match-sum s1
            (lam _ _ p\ match-prod p (lam _ _ x\ lam _ _ y\ app [x,y]))
            (lam _ _ s2\ match-sum s2 (lam _ _ x\ x) (lam _ _ x\ x)))),
    coq-say Term,
    expand-term Term Term',
    coq-say Term'.

expand-term-test'' :-
    coq-locate "LamC" Type, Type = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    (pi f\ (pi t\ rec-for-type t f _)
        => fixpoint-function "eq" Type LC LT [] TY (Out f)),
    (pi f\ expand-term (Out f) (Out' f)),
    coq-say Out'.

%% cleanup-term In Out
%               i  o
% Takes a term and replace all term-con X by an appropriate interpretation of X
cleanup-term (term-con (cvar X)) X.
cleanup-term (term-con (ccon T X)) (app [C|Prms]) :-
    concretise-constructor (ccon T X) C Prms.
cleanup-term (term-con _) _ :-
    fatal-error "Invalid term-con found in generated term".
cleanup-term (lam N T Bo) (lam N T' Bo') :-
    cleanup-term T T',
    pi x\ cleanup-term (Bo x) (Bo' x).
cleanup-term (prod N T Bo) (prod N T' Bo') :-
    cleanup-term T T',
    pi x\ cleanup-term (Bo x) (Bo' x).
cleanup-term (app L) (app L') :-
    map L cleanup-term L'.
cleanup-term (fix Nm Nn Tp Bo) (fix Nm Nn Tp' Bo') :-
    cleanup-term Tp Tp',
    pi x\ cleanup-term (Bo x) (Bo' x).
cleanup-term (match X F MT) (match X' F MT') :-
    cleanup-term X X',
    map MT cleanup-term MT'.
cleanup-term X X.

cleanup-term-test :-
    coq-locate "LamC" Type,
    (pi f\ (pi t\ rec-for-type t f _)
        => fixpoint "eq" Type [] (Out f)),
    (pi f\ expand-term (Out f) (Out' f)), !,
    (pi f\ cleanup-term (Out' f) (Out'' f)),
    coq-say Out''.

cleanup-term-test' :-
    coq-locate "LamC" Type,
    Term = (lam _ _ a\ lam _ _ b\
        term-con (ccon Type (cinr (cinl (cprod (cvar a) (cvar b)))))),
    cleanup-term Term Term',
    coq-say Term'.

cleanup-term-test'' :-
    coq-locate "LamC" Type,
    (pi f\ (pi t\ rec-for-type t f _)
        => fixpoint "map" Type [Type] (Out f)), !,
    (pi f\ expand-term (Out f) (Out' f)), !,
    (pi f\ cleanup-term (Out' f) (Out'' f)),
    coq-say Out''.


