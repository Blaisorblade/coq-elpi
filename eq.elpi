
accumulate coq-lib.
accumulate lp-lib.

%% arbitrary-term-function
% Necessary because some relation recursively build function
% of arity n, which raise an error with the typer.
kind arbitrary-term-function type -> type.
type atf-const A -> arbitrary-term-function A.
type atf-lam   (term -> arbitrary-term-function A)
                     -> arbitrary-term-function A.

atf-apply (atf-lam F) T (F T).
atf-apply A           _ A.

type unique list A -> list A -> prop.
unique [X|L] L'     :- mem X L,      unique L L'.
unique [X|L] [X|L'] :- not(mem X L), unique L L'.
unique []    [].

unique-test :-
    unique [1,2,5,8,9,6,3,5,4,7,8,5,1,2,3,6,5,4,7,8,9,6] Out,
    coq-say Out.

same-length [X|L] [X'|L'] :- same-length L L'.
same-length [] [].

inductive-on-type' T T.
inductive-on-type' T T' :- inductive-on-type T T'.

inductive-on-type TP (lam _ T F) :-
    inductive-on-type' TP T; pi x\ inductive-on-type TP (F x).
inductive-on-type TP (prod _ T F) :-
    inductive-on-type' TP T; pi x\ inductive-on-type TP (F x).
inductive-on-type TP (app L) :-
    exists L (inductive-on-type' TP).

%% eq-signature
eq-signature Type Sign :-
    coq-locate "bool" Bool,
    Sign = (prod _ Type _\ prod _ Type _\ Bool).

eq-signature-test :-
    eq-signature {{nat}} Sign,
    coq-say Sign,
    {{eq_nat}} = const Eq,
    coq-env-const Eq _ TY,
    coq-say TY.

%% eq-test
type eq-function term -> term -> prop.
eq-test Tp Eq EqTp :-
    eq-function Tp Eq, Eq = const GR,
    coq-env-const GR _ EqTp.

simpl-eq-test' (lam _ Sign Bo) [Eqf|L] :-
    eq-signature Type Sign,
    eq-test Type Eqf TpEq,
    pi x\ simpl-eq-test' (Bo x) L.
simpl-eq-test' X [].
simpl-eq-test In InTp Out :-
    simpl-eq-test' {prod-2-lam InTp} L,
    not(null L),
    Out = app [In|L].
simpl-eq-test In InTp In :-
    simpl-eq-test' {prod-2-lam InTp} L,
    null L.

simpl-eq-test-test :-
    coq-locate "tmp" Tmp, Tmp = const GR,
    coq-env-const GR _ TY,
    eq-signature {{nat}} Sign,
    eq-test {{nat}} {{eq_nat}} Sign
        => simpl-eq-test Tmp TY Tmp',
    coq-say Tmp'.

simpl-eq-test-test' :-
    coq-locate "tmp'" Tmp, Tmp = const GR,
    coq-env-const GR _ TY,
    coq-locate "list" List,
    eq-signature {{nat}} Sign,
    pi l\ eq-signature (app [List|l]) (Type l),
    eq-test {{nat}} {{eq_nat}} Sign
        => (pi l\ eq-test (app [List|l]) (app [{{eq_list}}|l]) (Type l))
        => simpl-eq-test Tmp TY Tmp',
    coq-say Tmp'.

%% build-eq-check
build-eq-check And True [Trm|Trms] [Tp|Tps] Out :-
    build-eq-check And True Trms Tps End,
    eq-test Tp Eqf' TpEqf,
    simpl-eq-test Eqf' TpEqf Eqf,
    Trm   = pr A B,
    Nterm = app [Eqf, A, B],
    Out   = app [And, Nterm, End].
build-eq-check And True [] [] True.

build-eq-check-test :-
    coq-locate "andb"   And,
    coq-locate "true"   True,
    coq-locate "nat"    Nat,
    coq-locate "O"      Zero,
    coq-locate "S"      Succ,
    coq-locate "eq_nat" Eq, Eq = const GR,
    coq-env-const GR _ TY,
    eq-test Nat Eq TY => build-eq-check And True
                         [pr Zero Zero, pr Zero Zero]
                         [Nat, Nat] Out,
    coq-say Out.

build-eq-check-test' :-
    coq-locate "andb" And,
    coq-locate "true" True,
    coq-locate "nat"  Nat,
    coq-locate "O" Zero,
    coq-locate "eq_nat" Eq, Eq = const GR,
    coq-env-const GR _ TY,
    eq-test Nat Eq TY => build-eq-check And True [] [Nat] Out,
    coq-say Out.

%% constructor-args
constructor-args [X|LS] (lam _ T F) :-
    X = T,
    pi x\ constructor-args LS (F x).
constructor-args [] T :-
    not(T = (lam _ _ _)),
    not(T = (prod _ _ _)).

constructor-args-test :-
    coq-locate "S" Succ, Succ = indc GR,
    coq-env-indc GR _ _ TY,
    constructor-args L TY,
    coq-say TY,
    coq-say L.

%% build-constructor-match
build-constructor-match TypeCons Terms C Term :-
    TypeCons = pr Cons LCons,
    C = Cons,
    eq-lambda Terms [] {prod-2-lam LCons} Term [].
build-constructor-match TypeCons Terms C Term :-
    TypeCons = pr Cons LCons,
    not (C = Cons),
    false-lambda {prod-2-lam LCons} Term.

eq-lambda Terms Types (lam N X B) (lam N X C) L :-
    pi x\ eq-lambda Terms [X|Types] (B x) (C x) [x|L].
eq-lambda Terms Types T Out L :-
    not (T = lam _ _ _),
    zip Terms L NTerms,
    build-eq-check {{andb}} {{true}} NTerms Types Out.

false-lambda (lam N X B) (lam N X C) :-
    pi x\ false-lambda (B x) (C x).
false-lambda _ {{false}}.

build-constructor-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    coq-locate "O" Zero,
    coq-locate "S" Succ,
    Succ = indc SGR, coq-env-indc SGR _ _ STY,
    pi x\ eq-test Nat EqNat TY => build-constructor-match (pr Succ STY) [x]
                                                          Succ (Out x),
    coq-say Out.

%% sub-match
sub-match Type Conss TypeCons T Terms Out :-
    map Conss (build-constructor-match TypeCons Terms) MTerms,
    coq-locate "bool"  Bool,
    Out = match T (lam _ Type _ \ Bool) MTerms.

sub-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    coq-locate "O" Zero,
    coq-locate "S" Succ,
    Succ = indc SGR, coq-env-indc SGR _ _ STY,
    pi x\ pi y\ eq-test Nat EqNat TY => sub-match Nat [Zero, Succ]
                                                  (pr Succ STY) x [y] (Out x y),
    coq-say Out.

%% build-match-for-constructor
build-match-for-constructor Type      % The global type
                            T         % The second term to compare
                            Conss     % List of the constructors
                            TypeCons  % The type of the constructor
                            Out       % The result (ie a function for a
                                      % mach on this constructor)
                            :-
    TypeCons = pr Cons CType,
    sub-match-build Type Conss TypeCons T [] {prod-2-lam CType} Out.

sub-match-build Type Conss TypeCons T L (lam N X B) (lam N X C) :-
    pi x\ sub-match-build Type Conss TypeCons T [x|L] (B x) (C x).
sub-match-build Type Conss TypeCons T L _ Out :-
    sub-match Type Conss TypeCons T L Out.

build-match-for-constructor-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GREq, coq-env-const GREq _ TEq,
    coq-locate "nat" Nat, Nat = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    coq-locate "S" Succ, Succ = indc GR',
    coq-env-indc GR' _ _ TYSucc,
    pi t\ eq-test Nat EqNat TEq => build-match-for-constructor Nat t LC
                                   (pr Succ TYSucc) (Out t),
    coq-say Out.

%% build-eq-match
build-eq-match Type L T1 T2 Out :-
    Type = indt GR,
    coq-env-indt GR tt _ _ TY LC' LT',
    map LC' (gen-app L) LC,
    map LT' (tp-apply L) LT,
    zip LC LT TypeConss,
    map TypeConss (build-match-for-constructor Type T2 LC) MTerms,
    coq-locate "bool"  Bool,
    Out = match T1 (lam _ Type _ \ Bool) MTerms.

tp-apply' [X|L] (lam _ _ B) Out :-
    tp-apply' L (B X) Out.
tp-apply' [] T T.
tp-apply L B Out :-
    tp-apply' L {prod-2-lam B} Out.

gen-app [] C C.
gen-app L  C (app [C|L]).

build-eq-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    pi x\ pi y\ eq-test Nat EqNat TY => build-eq-match Nat [] x y
                                                      (Out x y),
    coq-say Out.

%% build-eq-body
build-eq-body Type L Out :-
    pi t1\ pi t2\ build-eq-match Type L t1 t2 (Bo t1 t2),
    Out = lam _ Type t1\ lam _ Type t2\ Bo t1 t2.

build-eq-body-test :-
    eq-signature {{nat}} Sign,
    eq-test {{nat}} {{eq_nat}} Sign
        => build-eq-body {{nat}} [] Out,
    coq-say Out.

%% get-types-for-construction
get-types-for-construction' [X|L] (lam _ T B) Out :-
    get-types-for-construction' L (B X) Out.
get-types-for-construction' [] Bo Out :-
    constructor-args Out Bo.
get-types-for-construction L Bo Out :-
    get-types-for-construction' L {prod-2-lam Bo} Out.

%% same-type
same-type T T.
same-type T (app [T|_]).

same-type-test :-
    coq-locate "nat" Nat,
    coq-locate "list" List,
    same-type Nat Nat,
    not(same-type Nat List),
    same-type List (app [List, Nat]),
    not(same-type Nat (app [List, Nat])),
    coq-say "Success !".

%% bind-types
bind-types Ndec Type LT L (lam N T B)
        (prod N T TBo) (atf-lam FT) (atf-lam OTypes) :-
    pi x\ bind-types N1 Type LT [x|L] (B x) (TBo x) (FT x) (OTypes x),
    Ndec is N1 + 1.
bind-types Ndec Type LT L' _ TOut (atf-const TOut) (atf-const OTypes) :-
    rev L' L,
    map LT (get-types-for-construction L) Args,
    flatten Args Args', unique Args' Args'',
    filter (x\ not(eq-test x _ _)) Args'' Args''',
    filter (x\ not(same-type Type x)) Args''' OTypes,
    get-type Type L OTypes TOut,
    length OTypes Ndec.

bind-types-test :-
    coq-locate "mlist" Mlist, Mlist = indt GR,
    coq-env-indt GR tt _ _ TY' LC LT,
    prod-2-lam TY' TY,
    bind-types Ndec Mlist LT [] TY Tout Fout OTypes,
    coq-say Ndec,
    coq-say Tout,
    coq-say Fout,
    coq-say OTypes.

%% get-type
get-type Type Args [T|Tps] (prod _ Sign TBo) :-
    eq-signature T Sign,
    pi f\ get-type Type Args Tps (TBo f).
get-type Type [] [] TOut :-
    eq-signature Type TOut.
get-type Type Args [] TOut :-
    eq-signature (app [Type|Args]) TOut.

%% apply-ft
apply-ft' [X|L] FT TOut :-
    atf-apply FT X FT',
    apply-ft' L FT' TOut.
apply-ft' [] FT FT.
apply-ft  L FT Out :-
    apply-ft' L FT ATF,
    ATF = atf-const Out.

type nrel (list term) -> term -> prop.
apply-ft-test :-
    L = [{{mbtree}}, {{nat}}],
    (pi l tp\ (
       nrel l tp :- apply-ft l
             (atf-lam x0\
               atf-lam x1\
                atf-const
                 (prod _ x0 a\ prod _ x1 b\ {{nat -> nat -> bool}}))
             tp))
              => (nrel L X, coq-say X).

%% build-eq-for-type
build-eq-for-type Type Out TOut :-
    Type = indt GR,
    coq-env-indt GR tt _ _ TY' LC LT,
    prod-2-lam TY' TY,
    bind-types Ndec Type LT [] TY TOut FOut OTypes,
    % Only one of the following to additions to eq-test will be used,
    % depending on whether Type is dependant or not
    pi f\ eq-test Type f TOut
     => ((pi l tp\
           eq-test (app [Type|l]) (app [f|l]) tp :-
               apply-ft l FOut tp
         )
      => get-eqs Type TY [] OTypes (Bo f)),
    Out = fix _ Ndec TOut Bo.

get-eqs Type (lam N T B) L (atf-lam F)         (lam N T Bo) :-
    pi x\ get-eqs Type (B x) [x|L] (F x) (Bo x).
get-eqs Type X           L (atf-const [T|Tps]) (lam _ Sign Bo) :-
    eq-signature T Sign,
    pi f\ eq-test T f Sign => get-eqs Type X L (atf-const Tps) (Bo f).
get-eqs Type _           L (atf-const [])      Out :-
    build-eq-body Type {rev L} Out.

build-eq-for-type-test :-
    build-eq-for-type {{mlist}} Out TOut,
    coq-say TOut,
    coq-say Out.

%% create-eq
create-eq Type :-
    build-eq-for-type Type Eq TEq, Type = indt GR,
    coq-string-of-gr GR S,
    Name is S ^ "_equal",
    coq-env-add-const Name Eq TEq (const NGR),
    coq-string-of-gr NGR Name.

create-eq-test :- create-eq {{mbtree}}.

%% create-eq-from-name
create-eq-from-name Name :-
    coq-locate Name Type,
    create-eq Type.


%% Miscelaneous tests
test-prod :-
    coq-locate "prod" Prod, Prod = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    coq-say TY,
    coq-say LC,
    coq-say LT.

test-list :-
    coq-locate "list" List, List = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    coq-say TY,
    coq-say LC,
    coq-say LT.

test-awful :-
    coq-locate "awful" Awful, Awful = indt GR,
    coq-env-indt GR tt Lno Luno TY LC LT,
    coq-say Lno,
    coq-say Luno,
    coq-say TY,
    coq-say LC,
    coq-say LT.

