
accumulate coq-lib.
accumulate lp-lib.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Utilities %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% arbitrary-term-function %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Necessary because some relation recursively build function
% of arity n, which raise an error with the typer.
kind arbitrary-term-function type -> type.
type atf-const A -> arbitrary-term-function A.
type atf-lam   (term -> arbitrary-term-function A)
                     -> arbitrary-term-function A.

atf-apply (atf-lam F) T (F T).
atf-apply A           _ A.

%% unique %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Remove doubles from list.
% move to lp-lib ?
type unique list A -> list A -> prop.
unique [X|L] L'     :- mem X L,      unique L L'.
unique [X|L] [X|L'] :- not(mem X L), unique L L'.
unique []    [].

unique-test :-
    unique [1,2,5,8,9,6,3,5,4,7,8,5,1,2,3,6,5,4,7,8,9,6] Out,
    coq-say Out.

%% same-length %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
same-length [X|L] [X'|L'] :- same-length L L'.
same-length [] [].

%% flatten-app %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% //merge// apps so that the head of an application list is not an application.
flatten-app (app [app L|X]) (app L') :-
    flatten-app (app L) (app FL),
    append FL X L'.
flatten-app (app [X]) X.
flatten-app (app L) (app L).

flatten-app-test :-
    coq-locate "nat" Nat,
    flatten-app (app [app [app [Nat], Nat], Nat, app [Nat, Nat], Nat]) Out,
    coq-say Out.

flatten-app-test' :-
    flatten-app (app [{{nat}}]) N,
    coq-say N.

%% eq-signature %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Create the type of an equality function for Type.
eq-signature Type Sign :-
    coq-locate "bool" Bool,
    Sign = (prod _ Type _\ prod _ Type _\ Bool).

eq-signature-test :-
    eq-signature {{nat}} Sign,
    coq-say Sign,
    {{eq_nat}} = const Eq,
    coq-env-const Eq _ TY,
    coq-say TY.

%% constructor-args %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Gives the list of the arguments of a function/constructor
constructor-args L (prod N T F) :-
    constructor-args L (lam N T F).
constructor-args [X|LS] (lam _ T F) :-
    X = T,
    pi x\ constructor-args LS (F x).
constructor-args [] T :-
    not(T = (lam _ _ _)),
    not(T = (prod _ _ _)).

constructor-args-test :-
    coq-locate "S" Succ, Succ = indc GR,
    coq-env-indc GR _ _ TY,
    constructor-args L TY,
    coq-say TY,
    coq-say L.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%% Database of functions and proofs %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% eq-test %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% eq-test links a type, an equality function for this type and the type of the
% equality function. Indeed, this last one is not necessarily (T -> T -> bool)
% but can be of the general form :
%   (A -> A -> bool) -> (B -> B -> bool) -> ... -> (T -> T -> bool)
% To make it easier to enter for the user, eq-function can be used : it links
% a type with an equality function *defined in Coq*. Its type can then
% automatically be loaded, as long it is of the form :
%   forall (A B ... : Type), (A -> A -> bool) -> ... -> (T -> T -> bool)
% See spec-function for how the forall is lifted when defining eq-test.
type eq-function term -> term -> prop.
eq-test Tp Eq EqTp :-
    eq-function Tp Eq, Eq = const GR,
    coq-env-const GR _ EqTp.

eq-test (app [Tp|L]) (app [Eq|L]) Type :-
    eq-function Tp Eq, Eq = const GR,
    coq-env-const GR _ EqTp,
    spec-function {prod-2-lam EqTp} ATF,
    apply-ft L ATF Type.

eq-test-test :-
    coq-say {{prod nat nat}},
    eq-test {{prod nat nat}} Cmp Tp,
    coq-say Cmp,
    coq-say Tp,
    simpl-eq-test Cmp Tp Eqf,
    coq-say Eqf.

%% spec-function %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Takes a type of the form :
%   forall (A B ... : Type), (A -> A -> bool) -> ... -> (T -> T -> bool)
% and create a lambda prolog function of the form :
%   A\ B\ ... (A -> A -> bool) -> ... -> (T -> T -> bool)
% (the function is wrapped as an ATF so that the typer does not complain about
% the varying arity of the generated function)
spec-function (lam N (sort _) B) (atf-lam Out) :-
    pi x\ spec-function (B x) (Out x).
spec-function A           (atf-const A).

spec-function-test :-
    prod-2-lam {{forall A B : Type, (A -> A -> bool) -> (B -> B -> bool)
        -> mlist A B -> mlist A B -> bool}} Sign,
    spec-function Sign Out,
    coq-say Out.

%% eq-proof %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% eq-proof links a type, a pair of vairables, a proof a the validity of a
% specific equality function applied to these terms and the equality function
% applied :
%   eq-proof type (pr a b) (t : eqf a b = true <-> a = b) (eqf a b).
% Storing the pair is necessary since the proof may depend on it in the case
% of an induction.
type eq-proof term -> pair term term -> term -> term -> prop.

%% simpl-eq-test %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% simpl-eq-test takes a comparison function In and its type InTp as those given
% by eq-test for a specific type. Assuming InTp is of the form :
%   (A -> A -> bool) -> ... -> (T -> T -> bool)
% it will recursively look for a comparison function of type (A -> A -> bool)
% in eq-test an apply it to In in order to return a term of type
% (T -> T -> bool).
simpl-eq-test' (lam _ Sign Bo) [Eqf|L] :-
    eq-signature Type Sign,
    eq-test Type Eqf' TpEq,
    simpl-eq-test' TpEq EqArgs,
    app-type Eqf' EqArgs Eqf,
    pi x\ simpl-eq-test' (Bo x) L.
simpl-eq-test' X [].
simpl-eq-test In InTp Out :-
    simpl-eq-test' {prod-2-lam InTp} L,
    app-type In L Out.

simpl-eq-test-test :-
    coq-locate "tmp" Tmp, Tmp = const GR,
    coq-env-const GR _ TY,
    eq-signature {{nat}} Sign,
    eq-test {{nat}} {{eq_nat}} Sign
        => simpl-eq-test Tmp TY Tmp',
    coq-say Tmp'.

simpl-eq-test-test' :-
    coq-locate "tmp'" Tmp, Tmp = const GR,
    coq-env-const GR _ TY,
    coq-locate "list" List,
    eq-signature {{nat}} Sign,
    pi l\ eq-signature (app [List|l]) (Type l),
    eq-test {{nat}} {{eq_nat}} Sign
        => (pi l\ eq-test (app [List|l]) (app [{{eq_list}}|l]) (Type l))
        => simpl-eq-test Tmp TY Tmp',
    coq-say Tmp'.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% Equality testing of constructors %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% build-eq-check %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Takes And and True which are the boolean and and true terms of Coq, a list
% pair of terms (the two terms of a pair must have the same type), and a list
% of types. It then looks into eq-test with simpl-eq-test to find functions
% to compare every pair. The generated term is :
% [pr x1 y1, pr x2 y2] -> [t1, t2] -> (eq1 x1 y1) && (eq2 x2 y2)
build-eq-check And True [Trm] [Tp] Out :-
    eq-test Tp Eqf' TpEqf,
    simpl-eq-test Eqf' TpEqf Eqf,
    Trm   = pr A B,
    Out   = app [Eqf, A, B].
build-eq-check And True [Trm|Trms] [Tp|Tps] Out :-
    build-eq-check And True Trms Tps End,
    eq-test Tp Eqf' TpEqf,
    simpl-eq-test Eqf' TpEqf Eqf,
    Trm   = pr A B,
    Nterm = app [Eqf, A, B],
    Out   = app [And, Nterm, End].
build-eq-check And True [] [] True.

build-eq-check-test :-
    coq-locate "andb"   And,
    coq-locate "true"   True,
    coq-locate "nat"    Nat,
    coq-locate "O"      Zero,
    coq-locate "S"      Succ,
    coq-locate "eq_nat" Eq, Eq = const GR,
    coq-env-const GR _ TY,
    eq-test Nat Eq TY => build-eq-check And True
                         [pr Zero Zero, pr Zero Zero]
                         [Nat, Nat] Out,
    coq-say Out.

build-eq-check-test' :-
    coq-locate "andb" And,
    coq-locate "true" True,
    coq-locate "nat"  Nat,
    coq-locate "O" Zero,
    coq-locate "eq_nat" Eq, Eq = const GR,
    coq-env-const GR _ TY,
    eq-test Nat Eq TY => build-eq-check And True [] [Nat] Out,
    coq-say Out.

%% proof-xy %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% proof-xy gives a term of type eqf X Y = true -> X = Y for X and Y of type T
proof-xy T X Y Hxy {{proj1 (iff_and lp:Heq) lp:Hxy}} :-
    eq-proof T (pr X Y) Heq _.

%% build-eq-check-proof-proj1-eq %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The arguments :
%   Hqs    : list of terms of type eqf_i x_i y_i = true
%   T{x,y} : list of terms x_i and y_i
%   FgEq   : {{fg_equal}}
%   Cons*  : the constructors used, partially applied, with their types
%   Type   : the type of the partially applied constructor
%   Proof  : term of type Cons1 = Cons2
% The return value is a term of type app [Cons1|Tx] = app [Cons2|Ty]
build-eq-check-proof-proj1-eq Cons1 Cons2 (lam N T B) [X|Tx] [Y|Ty] [Hxy|Hqs] FgEq Proof Out :-
    flatten-app (app [Cons1, X]) AC1,
    flatten-app (app [Cons2, Y]) AC2,
    proof-xy T X Y Hxy Eqxy,
    pi t\ build-eq-check-proof-proj1-eq AC1 AC2 (B t) Tx Ty Hqs FgEq
        (app [FgEq, T, (B t), Cons1, Cons2, X, Y, Eqxy, Proof])
        Out.
build-eq-check-proof-proj1-eq Cons1 Cons2 (prod N T B) Tx Ty Hqs FgEq Proof Out :-
    build-eq-check-proof-proj1-eq Cons1 Cons2 (lam N T B) Tx Ty Hqs FgEq Proof Out.
build-eq-check-proof-proj1-eq Cons1 Cons2 _ [] [] [] _ Proof Proof.

build-eq-check-proof-proj1-eq-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "eq_refl" EqRefl', EqRefl = app [EqRefl', hole, hole],
    coq-locate "fg_equal" FgEq,
    (pi eq\ pi heq\ pi x1\ pi y1\ pi x2\ pi y2\ pi x3\ pi y3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) (app [heq, t, a, b]) (app [eq, t, a, b])) =>
        (build-eq-check-proof-proj1-eq MbNode MbNode TY [x1, x2, x3] [y1, y2, y3]
            [app [eq, {{mbtree}}, x1, y1], app [eq, {{mbtree}}, x2, y2], app [eq, {{nat}}, x3, y3]]
            FgEq EqRefl (Out eq heq x1 y1 x2 y2 x3 y3))),
    Bo = (lam _ {{forall (A : Type), A -> A -> bool}} eq\
        lam _ {{forall (A : Type) (a b : A), lp:eq A a b = true}} teq\
        lam _ {{forall (A : Type) (a b : A), eq_ok A (lp:eq A) a b}} heq\
        lam _ {{mbtree}} x1\ lam _ {{mbtree}} y1\ lam _ {{mbtree}} x2\ lam _ {{mbtree}} y2\
        lam _ {{nat}} x3\ lam _ {{nat}} y3\ Out teq heq x1 y1 x2 y2 x3 y3),
    coq-say Bo,
    coq-elaborate Bo Bo' TBo,
    coq-say TBo.

%% build-eq-check-proof-proj1-and-cond %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Ts : list of types of terms
%   Tx : first list of terms
%   Ty : second list of terms
% Returns a term corresponding to the type :
%   eq_1 x_1 y_1 && (eq_2 x_2 y_2 && ...) = true
build-eq-check-proof-proj1-and-cond' _ [] [] {{true}}.
build-eq-check-proof-proj1-and-cond' [T|_] [X] [Y] Eq :-
    eq-proof T (pr X Y) _ Eq.
build-eq-check-proof-proj1-and-cond' [T|Ts] [X|Tx] [Y|Ty] Out :-
    eq-proof T (pr X Y) _ Eq,
    build-eq-check-proof-proj1-and-cond' Ts Tx Ty Trm,
    Out = {{andb lp:Eq lp:Trm}}.
build-eq-check-proof-proj1-and-cond Ts Tx Ty {{lp:Out = true}} :-
    build-eq-check-proof-proj1-and-cond' Ts Tx Ty Out.

%% build-eq-check-proof-proj1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Cons   : the constructor considered
%   Type   : the type of the constructor
%   Ts     : the list of types of the terms (which are the types of the
%            arguments of the constructor)
%   T{x,y} : arguments for the constructor (twice so that it can recurse on them
%            and still pass them to build-eq-check-proof-proj1)
%   Hqs    : empty list, filled internally with the properties
%            eq_i x_1 y_1 = true
%   H      : actual hypothesis (to be broken if necessary)
% Returns a term of type :
%   hq_1 && (hq_2 && ...) = true -> app [Cons|Tx] = app [Cons|Ty]
build-eq-check-proof-proj1 Cons Type [T|_] [X] Tx [Y] Ty Hqs H Out :-
    coq-locate "fg_equal" FgEq,
    coq-locate "eq_refl" EqRefl', EqRefl = app [EqRefl', hole, hole],
    build-eq-check-proof-proj1-eq Cons Cons Type Tx Ty [H|Hqs] FgEq EqRefl Out.
build-eq-check-proof-proj1 Cons Type [T|Ts] [X|Tx'] Tx [Y|Ty'] Ty Hqs H Out :-
    coq-locate "andb_prop" AndbProp,
    eq-proof T (pr X Y) _ Eq,
    (pi x\ build-eq-check-proof-proj1-and-cond Ts Tx' Ty' End),
    pi x\ pi hxy\ pi h'\ build-eq-check-proof-proj1 Cons Type Ts Tx' Tx Ty' Ty [hxy|Hqs] h' (Trm hxy h'),
    Out = match (app [AndbProp, hole, hole, H]) (lam _ {{and _ _}} _\ hole)
        [lam _ {{lp:Eq = true}} hxy\ lam _ End h'\ Trm hxy h'].
build-eq-check-proof-proj1 Cons Type _ [] Tx [] Ty Hqs _ Out :-
    coq-locate "fg_equal" FgEq,
    coq-locate "eq_refl" EqRefl', EqRefl = app [EqRefl', hole, hole],
    build-eq-check-proof-proj1-eq Cons Cons Type Tx Ty Hqs FgEq EqRefl Out.

build-eq-check-proof-proj1-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    constructor-args Args' {prod-2-lam TY}, rev Args' Args,
    (pi h\ pi eq\ pi heq\ pi x1\ pi y1\ pi x2\ pi y2\ pi x3\ pi y3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) (app [heq, t, a, b]) (app [eq, t, a, b])) =>
        build-eq-check-proof-proj1 MbNode TY Args
            [x3, x2, x1] [x1, x2, x3] [y3, y2, y1] [y1, y2, y3] [] h (Out h eq heq x1 y1 x2 y2 x3 y3)),
    coq-say Out.

%% build-eq-check-proof-proj2-projector-fun %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   N    : which argument of the constructor must be returned
%   Cons : the constructor from which we want the Nth argument
%   Def  : the value to return on other constructors
%   TOut : used internally to keep track of the type of the returned value,
%          can be set to anything when called
%   C    : the constructor on which we are applying the projection
%   Ty   : the type of the C constructor
% Returns the term of a function taking an instance of a type built with the C
% constructor, returning Def if C <> Cons and the (N-1)th argument of C
% if C = Cons.
build-eq-check-proof-proj2-projector-fun N Cons Def TOut C (prod Nm T TB) Out :-
    build-eq-check-proof-proj2-projector-fun N Cons Def TOut C (lam Nm T TB) Out.
build-eq-check-proof-proj2-projector-fun N Cons Def TOut C (lam Nm T TB) (lam Nm T Out) :-
    not(N is 0),
    N1 is N - 1,
    pi x\ build-eq-check-proof-proj2-projector-fun N1 Cons Def TOut C (TB x) (Out x).
build-eq-check-proof-proj2-projector-fun N Cons Def TOut C (lam Nm T TB) (lam Nm T Out) :-
    N is 0,
    N1 is N - 1,
    pi x\ build-eq-check-proof-proj2-projector-fun N1 Cons Def x C (TB x) (Out x).
build-eq-check-proof-proj2-projector-fun N Cons Def TOut C _ TOut :- C = Cons.
build-eq-check-proof-proj2-projector-fun N Cons Def TOut C _ Def  :- not(C = Cons).

build-eq-check-proof-proj2-projector-fun-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    pi d\ pi z\
        build-eq-check-proof-proj2-projector-fun 1 MbNode d z
            MbNode TY (Out d),
    coq-elaborate (lam _ {{mbtree}} d\ Out d) Bo TBo,
    coq-say TBo,
    coq-say Bo.

%% build-eq-check-proof-proj2-projector %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   N     : which argument of the constructor must be returned
%   Cons  : the constructor from which we want the Nth argument
%   Def   : the value to return on other constructors
%   Conss : the list of constructors of the type
%   Types : the types of the constructors
% Returns the term of a function taking an instance of a type and return the
% Nth argument of the Cons constructor if it was created with it, Def otherwise
build-eq-check-proof-proj2-projector' N Cons Def Conss Types Z Matches :-
    map2 Conss Types (build-eq-check-proof-proj2-projector-fun N Cons Def Z) Matches.
build-eq-check-proof-proj2-projector N Cons Def Conss Types Out :-
    pi z\ build-eq-check-proof-proj2-projector' N Cons Def Conss Types z Matches,
    current-type T,
    Out = lam _ hole x\ match x (lam _ T _\ hole)  Matches.

build-eq-check-proof-proj2-projector-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT',
    map LT' prod-2-lam LT,
    pi d\ build-eq-check-proof-proj2-projector 1 MbNode d LC LT (Out d),
    coq-say Out.

%% build-eq-check-proof-proj2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   N     : used to count the number of arguments to the Cons constructor,
%           should be set to 0
%   Cons  : the constructor for which the equality will be built
%   Type  : the type of the constructor (twice so that it can also be given
%           to build-eq-check-proof-proj2-projector)
%   Conss : the list of constructors of the type
%   Types : the types of the constructors
%   Tx    : arguments for cons
%   Ty    : arguments for cons
%   Ds    : list of default values
%   Proof : used as an accumulator for Out, should start as {{eq_refl}}
% Returns a term of type app [Cons|Tx] = app [Cons|Ty] -> (eq_1 x_1 y_1 && ...) = true
build-eq-check-proof-proj2 N Cons Type (prod Nm T Bo) Conss Types Tx Ty Ds H Proof Out :-
    build-eq-check-proof-proj2 N Cons Type (lam Nm T Bo) Conss Types Tx Ty Ds H Proof Out.
build-eq-check-proof-proj2 N Cons Type (lam _ T Bo) Conss Types [X|Tx] [Y|Ty] [D|Ds] H Proof Out :-
    N is 0,
    N1 is N + 1,
    eq-proof T (pr X Y) Heq _,
    build-eq-check-proof-proj2-projector N Cons D Conss Types F,
    pi x\ build-eq-check-proof-proj2 N1 Cons Type (Bo x) Conss Types Tx Ty Ds H
        {{(proj2 (iff_and lp:Heq) (f_equal lp:F lp:H))}} Out.
build-eq-check-proof-proj2 N Cons Type (lam _ T Bo) Conss Types [X|Tx] [Y|Ty] [D|Ds] H Proof Out :-
    N1 is N + 1,
    eq-proof T (pr X Y) Heq _,
    build-eq-check-proof-proj2-projector N Cons D Conss Types F,
    pi x\ build-eq-check-proof-proj2 N1 Cons Type (Bo x) Conss Types Tx Ty Ds H
        {{andb_true_intro (conj (proj2 (iff_and lp:Heq) (f_equal lp:F lp:H)) lp:Proof)}} Out.
build-eq-check-proof-proj2 _ _ _ _ _ _ [] [] [] _ Proof Proof.

build-eq-check-proof-proj2-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT,
    (pi h\ pi eq\ pi heq\ pi x1\ pi y1\ pi d1\ pi x2\ pi y2\ pi d2\ pi x3\ pi y3\ pi d3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) (app [heq, t, a, b]) (app [eq, t, a, b])) =>
        (current-type MbTree =>
        build-eq-check-proof-proj2 0 MbNode TY TY LC LT [x1, x2, x3] [y1, y2, y3]
            [d1, d2, d3] h {{eq_refl}} (Out h eq heq x1 y1 d1 x2 y2 d2 x3 y3 d3))),
    coq-say Out.

%% build-eq-check-proof %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Cons  : the constructor
%   Type  : the type of the constructor
%   Conss : the constructors of the type
%   Types : the types of the constructors
%   Tx    : arguments of Cons
%   Ty    : arguments of Cons
% Returns a term of type :
%   (eq_1 x_1 y_1 && (eq_2 x_2 y_2 && ...)) = true <-> app [Cons|Tx] = app [Cons|Ty]
build-eq-check-proof Cons Type Conss Types Tx Ty Out :-
    constructor-args Args' Type, rev Args' Args,
    rev Tx Tx', rev Ty Ty',
    build-eq-check-proof-proj1-and-cond Args Tx' Ty' Prj1Arg,
    (pi h\ build-eq-check-proof-proj1 Cons Type Args Tx' Tx Ty' Ty [] h (Prj1 h)),
    (pi h\ build-eq-check-proof-proj2 0 Cons Type Type Conss Types Tx Ty Tx h {{eq_refl}} (Prj2 h)),
    current-type Tp,
    rev Tx RTx, rev Ty RTy,
    coq-locate "eq" Eq,
    Out = app [{{conj}}, hole, hole
              %, {{lp:"app [Cmp, app[Cons|Tx], app[Cons|Ty]]" = true -> lp:"app [Cons|Tx]" = lp:"app [Cons|Ty]"}}
              %, hole
              , (lam _ Prj1Arg h\ Prj1 h)
              , (lam _ {{lp:"app [Cons|Tx]" = lp:"app [Cons|Ty]"}} h\ Prj2 h)].

%% TODO remove use of current-type, is a hack
type current-type term -> prop.
build-eq-check-proof-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT,
    (pi eqnat\ pi eqprod\ pi eqmb\ pi hnat\ pi hprod\ pi hmbtree\
     pi x1\ pi y1\ pi x2\ pi y2\ pi x3\ pi y3\
        (pi a\ pi b\ eq-proof {{nat}} (pr a b) (app [hnat, a, b]) (app [eqnat, a, b])) =>
        ((pi a\ pi b\ eq-proof (app [{{prod}}, {{nat}}, {{nat}}]) (pr a b) (app [hprod,a,b]) (app [eqprod, a, b])) =>
        ((pi a\ pi b\ eq-proof MbTree (pr a b) (app [hmbtree,a,b]) (app [eqmb, a, b])) =>
        (current-type MbTree =>
        build-eq-check-proof MbNode TY LC LT [x1, x2, x3] [y1, y2, y3] (Out eqnat eqprod eqmb
                                                                            hnat hprod hmbtree 
                                                                            x1 y1 x2 y2 x3 y3))))),
    Bo =  (lam _ {{nat -> nat -> bool}} eqnat\ lam _ {{nat*nat -> nat*nat -> bool}} eqprod\
        lam _ {{mbtree -> mbtree -> bool}} eqmb\ lam _ {{forall (a b : nat), eq_ok nat lp:eqnat a b}} hnat\
        lam _ {{forall (a b : nat*nat), eq_ok (nat * nat) lp:eqprod a b}} hprod\
        lam _ {{forall (a b : mbtree), eq_ok mbtree lp:eqmb a b}} hmb\
        lam _ MbTree x1\ lam _ MbTree y1\ lam _ MbTree x2\ lam _ MbTree y2\ lam _ {{nat}} x3\ lam _ {{nat}} y3\
        Out eqnat eqprod eqmb hnat hprod hmb x1 y1 x2 y2 x3 y3),
     coq-elaborate Bo Bo' TBo,
     coq-say TBo.

%% build-constructor-match %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   TypeCons : a pair of a constructor and its type
%   Terms    : the arguments of the constructor
%   TC       : a pair of a constructor and its type
% Returns a term, if C is of type A -> B -> ... -> T, taking A, B, ... as arguments
% and checking the equality of app [Cons|Terms] and app [C,A,B...]
build-constructor-match TypeCons Terms TC Term :-
    TypeCons = pr Cons LCons,
    TC = pr C LC,
    C = Cons,
    eq-lambda Terms [] {prod-2-lam LC} Term [].
build-constructor-match TypeCons Terms TC Term :-
    TypeCons = pr Cons LCons,
    TC = pr C LC,
    not (C = Cons),
    false-lambda {prod-2-lam LC} Term.

%% eq-lambda %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Terms : the terms of the constructor
%   Types : their types, used as an accumulator, should be set to []
%   T     : the type of the constructor
%   L     : list of terms bound, used as accumulator, should be set to []
% Returns a term checking tacking parameters to the constructor as argument and
% checking their equlity with those of Terms : takes care of the diagonal of
% the recursion
eq-lambda Terms Types (lam N X B) (lam N X C) L :-
    pi x\ eq-lambda Terms [X|Types] (B x) (C x) [x|L].
eq-lambda Terms Types T Out L :-
    not (T = lam _ _ _),
    zip Terms L NTerms,
    build-eq-check {{andb}} {{true}} NTerms Types Out.

%% false-lambda %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments : the type of the second constructor.
% Returns a function taking the same arguments as the constructor and returning
% false : takes care of the cases when comparing two different constructors
false-lambda (lam N X B) (lam N X C) :-
    pi x\ false-lambda (B x) (C x).
false-lambda _ {{false}}.

build-constructor-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    coq-locate "O" Zero,
    coq-locate "S" Succ,
    Succ = indc SGR, coq-env-indc SGR _ _ STY,
    pi x\ eq-test Nat EqNat TY => build-constructor-match (pr Succ STY) [x]
                                                          (pr Succ STY) (Out x),
    coq-say Out.

%% false-lambda-proof-proj1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type   : the type considered
%   C{x,y} : the constructors
%   T{x,y} : their arguments
% Returns a term of type (assuming Cx <> Cy) false = true -> app [Cx|Tx] = app [Cy|Ty]
false-lambda-proof-proj1 Type Cx Tx Cy Ty (lam _ hole Out) :-
    pi h\ (False h) = app [{{eq_ind}}, hole, {{false}}, 
                           lam _ {{bool}} (e\ match e (lam _ {{bool}} _\ hole) [{{False}},{{True}}]),
                           {{I}}, {{true}}, h],
    pi h\ (Out h) = app [{{False_ind}}, {{lp:"app [Cx|Tx]" = lp:"app [Cy|Ty]"}}, (False h)].

%% false-lambda-proof-proj2-match-term %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   False : {{False}}
%   True  : {{True}}
%   Cons  : the considered constructor
%   C     : the constructor of the match
%   T     : the type of the constructor of the match
% If C is of type A -> B -> ... -> T, return a term of type A -> B -> ... -> Prop,
% where Prop is False if C = Cons and True otherwise
false-lambda-proof-proj2-match-term False True Cons C (prod N T Bo) Out :-
    false-lambda-proof-proj2-match-term False True Cons C (lam N T Bo) Out.
false-lambda-proof-proj2-match-term False True Cons C (lam N T Bo) (lam N T Out) :-
    pi x\ false-lambda-proof-proj2-match-term False True Cons C (Bo x) (Out x).
false-lambda-proof-proj2-match-term False True Cons C _ False :-
    C = Cons.
false-lambda-proof-proj2-match-term False True Cons C _ True :-
    not(C = Cons).

%% false-lambda-proof-proj2 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type  : the type considered
%   Cx    : the considered constructor
%   Cy    : the constructor we compare with
%   Conss : the constructor of Type
%   Types : the types of the constructors
%   Tx    : the arguments of Cx
%   Ty    : the arguments of Cy
% Returns a term of type (assuming Cx <> Cy) app [Cx|Tx] = app [Cy|Ty] -> false = true
false-lambda-proof-proj2 Type Cx Cy Conss Types Tx Ty (lam _ hole Out) :-
    map2 Conss Types (false-lambda-proof-proj2-match-term {{False}} {{True}} Cy) MTerms,
    Match = lam _ Type (e\ match e (lam _ Type _\ hole) MTerms),
    (pi h\ (False h) = app [{{eq_ind}}, hole, app [Cx|Tx], Match, {{I}}, app [Cy|Ty], h]),
    (pi h\ (Out h) = app [{{False_ind}}, {{false = true}}, False h]).

%% false-lambda-proof %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type  : the type considered
%   Cx    : the considered constructor
%   Tx    : the arguments of Cx
%   Cy    : the constructor we compare with
%   Ty    : the arguments of Cy
%   Conss : the constructor of Type
%   Types : the types of the constructors
% Returns a term of type (assuming Cx <> Cy) :
%       false = true <-> app [Cx|Tx] = app [Cy|Ty]
false-lambda-proof Type Cx Tx Cy Ty Conss Types Out :-
    false-lambda-proof-proj1 Type Cx Tx Cy Ty Prj1,
    false-lambda-proof-proj2 Type Cx Cy Conss Types Tx Ty Prj2,
    Out = app [{{conj}}, hole, hole, Prj1, Prj2].

false-lambda-proof-test :-
    coq-locate "mbnode" MbNode,
    coq-locate "mbtree" MbTree, MbTree = indt GR,
    coq-env-indt GR tt _ _ _ LC LT,
    coq-locate "mbleaf" MbLeaf,
    pi x1\ pi x2\ pi x3\ pi y\
        false-lambda-proof MbTree MbNode [x1, x2, x3] MbLeaf [y] LC LT (Out x1 x2 x3 y),
    coq-say Out.

%% build-constructor-match-proof %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type  : the type considered
%   Cx    : the considered constructor
%   Tx    : the arguments of Cx
%   Conss : the constructor of Type
%   Types : the types of the constructors
%   L     : an accumulator for the arguments of C, should be set to []
%   C     : the constructor to compare with
%   P     : a pair containing twice the type of C
% If C is of type A -> B -> ... -> T, returns a term of type :
%   A -> B -> ... -> eq (app [Cx|Tx]) (app [C,a,b...]) = true <-> app [Cx|Tx] = app [C,a,b...]
build-constructor-match-proof Type Cx Tx Conss Types L C (pr (prod N T Bo) TC) Out :-
    build-constructor-match-proof Type Cx Tx Conss Types L C (pr (lam N T Bo) TC) Out.
build-constructor-match-proof Type Cx Tx Conss Types L C (pr (lam N T Bo) TC) (lam N T Out) :-
    pi x\ build-constructor-match-proof Type Cx Tx Conss Types [x|L] C (pr (Bo x) TC) (Out x).
build-constructor-match-proof Type Cx Tx Conss Types L C _ Out :-
    not(Cx = C),
    rev L Ty,
    false-lambda-proof Type Cx Tx C Ty Conss Types Out.
build-constructor-match-proof Type Cx Tx Conss Types L C (pr _ TC) Out :-
    Cx = C,
    rev L Ty,
    current-type Type => build-eq-check-proof C TC Conss Types Tx Ty Out.

build-constructor-match-proof-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT,
    coq-locate "mbleaf" MbLeaf, MbLeaf = indc GR'',
    coq-env-indc GR'' _ _ TY'',
    pi heq\ pi eq\ pi x1\ pi x2\ pi x3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) heq eq) =>
        build-constructor-match-proof MbTree MbNode [x1, x2, x3]
            LC LT [] MbNode (pr TY TY) (Out heq eq x1 x2 x3),
    coq-say Out,
    pi x1\ pi x2\ pi x3\
        build-constructor-match-proof MbTree MbNode [x1, x2, x3]
            LC LT [] MbLeaf (pr TY'' TY'') (Out' x1 x2 x3),
    coq-say Out'.

%% sub-match %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type      : the type considered
%   TypeConss : the pair of its constructors and their types
%   TypeCons  : the pair of a considered constructor and its type
%   T         : the term to compare with
%   Terms     : the arguments of the considered constructor
% Returns a term checking the equality of T with app [C|Terms]
sub-match Type TypeConss TypeCons T Terms Out :-
    map TypeConss (build-constructor-match TypeCons Terms) MTerms,
    coq-locate "bool"  Bool,
    Out = match T (lam _ Type _ \ Bool) MTerms.

sub-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    coq-locate "O" Zero,
    Zero = indc ZGR, coq-env-indc ZGR _ _ ZTY,
    coq-locate "S" Succ,
    Succ = indc SGR, coq-env-indc SGR _ _ STY,
    pi x\ pi y\ eq-test Nat EqNat TY => sub-match Nat [pr Zero ZTY, pr Succ STY]
                                                  (pr Succ STY) x [y] (Out x y),
    coq-say Out.

%% sub-match-proof %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type  : the type considered
%   Cmp   : the comparison function we're proving
%   Cx    : the considered constructor
%   Tx    : the arguments of Cx
%   Conss : the constructor of Type
%   Types : the types of the constructors
%   T     : the term to compare with
% Return a term of type Cmp (app [Cx|Tx]) T = true <-> app [Cx|Tx] = T
sub-match-proof Type Cmp Cx Tx Conss Types T (match T TP MTerms) :-
    zip Types Types Types',
    TP = lam _ Type (x\ {{lp:"app [Cmp, app [Cx|Tx], x]" = true <-> lp:"app [Cx|Tx]" = lp:x}}),
    map2 Conss Types' (build-constructor-match-proof Type Cx Tx Conss Types []) MTerms.

sub-match-proof-test :-
    coq-locate "mbtree" MbTree, MbTree = indt GR,
    coq-env-indt GR tt _ _ _ LC LT,
    coq-locate "mbnode" MbNode,
    coq-locate "mbleaf" MbLeaf,
    pi cmp\ pi heq\ pi eq\ pi t\ pi x1\ pi x2\ pi x3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) heq eq) =>
        sub-match-proof MbTree cmp MbNode [x1, x2, x3]
            LC LT t (Out heq eq t x1 x2 x3),
    coq-say Out.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% Destructing the first type %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% build-match-for-constructor %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type      : the considered type
%   T         : the term to compare with
%   TypeConss : the constructors and their type of Type
%   TypeCons  : the constructor of the first term and its type
% Returns a function taking as many arguments as the constructor of the first
% term and check the equality of this constructor with the arguments given
% with T
build-match-for-constructor Type T TypeConss TypeCons Out :-
    TypeCons = pr Cons CType,
    sub-match-build Type TypeConss TypeCons T [] {prod-2-lam CType} Out.

%% sub-match-build %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type     : the considered type
%   Conss    : the constructors and their type of Type
%   TypeCons : the constructor of the first term and its type
%   T        : the term to compare with
%   L        : used as an accumulator of the arguments, should be set to []
%   Tpe      : the type of the constructor of the first term
% Returns a function taking as many arguments as the constructor of the first
% term and check the equality of this constructor with the arguments given
% with T
sub-match-build Type Conss TypeCons T L (lam N X B) (lam N X C) :-
    pi x\ sub-match-build Type Conss TypeCons T [x|L] (B x) (C x).
sub-match-build Type Conss TypeCons T L _ Out :-
    sub-match Type Conss TypeCons T L Out.

build-match-for-constructor-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GREq, coq-env-const GREq _ TEq,
    coq-locate "nat" Nat, Nat = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    coq-locate "S" Succ, Succ = indc GR',
    coq-env-indc GR' _ _ TYSucc,
    zip LC LT TypeConss,
    pi t\ eq-test Nat EqNat TEq => build-match-for-constructor Nat t TypeConss
                                   (pr Succ TYSucc) (Out t),
    coq-say Out.

%% build-match-for-constructor-proof %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type  : the considered type
%   Cmp   : the comparison function we're proving
%   Prop  : a function taking two arguments and returning the induction property
%           we're proving (ie a\ b\ eq_ok Type Cmp a b)
%   Conss : the constructors of Type
%   Types : the types of the constructors
%   Lx    : the arguments of the constructor of the first term
%   C     : C the constructor of the first term
%   TY    : the type of the constructor
% Returns a term taking as many arguments as C, plus induction hypothesis for
% the arguments with Type type, and give the induction hypothesis on C with
% the taken arguments
build-match-for-constructor-proof Type Cmp Prop Conss Types Lx C (prod N T Bo) Out :-
    build-match-for-constructor-proof Type Cmp Prop Conss Types Lx C (lam N T Bo) Out.
build-match-for-constructor-proof Type Cmp Prop Conss Types Lx C (lam N Type Bo) (lam N Type Out) :-
    pi x\ pi h\ (pi b\ eq-proof Type (pr x b) (app [h, b]) (app [Cmp, x, b])) => (
        build-match-for-constructor-proof Type Cmp Prop Conss Types [x|Lx] C (Bo x) (Out' x h)),
    Out = x\ lam _ (prod _ Type b\ Prop x b) (Out' x).
build-match-for-constructor-proof Type Cmp Prop Conss Types Lx C (lam N T Bo) (lam N T Out) :-
    pi x\ build-match-for-constructor-proof Type Cmp Prop Conss Types [x|Lx] C (Bo x) (Out x).
build-match-for-constructor-proof Type Cmp Prop Conss Types Lx' C _ (lam _ Type Out) :-
    rev Lx' Lx,
    pi x\ sub-match-proof Type Cmp C Lx Conss Types x (Out x).

build-match-for-constructor-proof-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT,
    coq-locate "mbtree_equal" EqMb,
    (pi eqnat\ pi eqnn\ pi heq\ pi hnn\ pi eqnat\ pi eqnn\
        (pi a\ pi b\ eq-proof {{nat}} (pr a b) (app [heq, a, b]) (app [eqnat, a, b])) =>
        ((pi a\ pi b\ eq-proof (app [{{prod}}, {{nat}}, {{nat}}]) (pr a b) (app [hnn, a, b]) (app [eqnn, a, b])) =>
        build-match-for-constructor-proof MbTree (app [EqMb, eqnat, eqnn]) (a\ b\ {{eq_ok mbtree lp:"app [EqMb, eqnat, eqnn]" lp:a lp:b}})
            LC LT [] MbNode TY (Out eqnat eqnn heq hnn))),
    Bo = (lam _ {{nat -> nat -> bool}} eqnat\
        lam _ {{nat*nat -> nat*nat -> bool}} eqnn\ lam _ {{forall (a b : nat), eq_ok nat lp:eqnat a b}} hnat\
        lam _ {{forall (a b : nat*nat), eq_ok (nat*nat) lp:eqnn a b}} hnn\
        Out eqnat eqnn hnat hnn),
    coq-elaborate Bo Bo' TBo,
    coq-say TBo.

%% app-type %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO remove, same as gen-app
app-type Type [] Type.
app-type Type L (app [Type|L]).

%% build-eq-match %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type   : the considered Type
%   L      : the parameters of Type
%   T{1,2} : the terms to compare
% Returns a term checking the equality of T1 and T2
build-eq-match Type L T1 T2 Out :-
    Type = indt GR,
    coq-env-indt GR tt _ _ TY LC' LT',
    map LC' (gen-app L) LC,
    map LT' (tp-apply L) LT,
    zip LC LT TypeConss,
    app-type Type L Type',
    map TypeConss (build-match-for-constructor Type' T2 TypeConss) MTerms,
    coq-locate "bool"  Bool,
    Out = match T1 (lam _ Type' _ \ Bool) MTerms.

%% tp-apply %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Do beta-reduction on a term with a list of arguments
tp-apply' [X|L] (lam _ _ B) Out :-
    tp-apply' L (B X) Out.
tp-apply' [] T T.
tp-apply L B Out :-
    tp-apply' L {prod-2-lam B} Out.

%% gen-app %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Apply a term to a list, but with a special case for when the list is empty.
gen-app [] C C.
gen-app L  C (app [C|L]).

build-eq-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    pi x\ pi y\ eq-test Nat EqNat TY => build-eq-match Nat [] x y
                                                      (Out x y),
    coq-say Out.

%% build-eq-match-proof-prop %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type   : the consider type
%   Prop   : a function taking the list of parameters of the type and two terms
%            and gives the induction property for these
%   Params : the parameters of Type
% Returns a term of type forall (a b : Type Params), Prop Params a b
build-eq-match-proof-prop Type Prop Params Out :-
    Out = lam "a" (app [Type|Params]) a\ prod "b" (app [Type|Params]) b\ Prop Params a b.

build-eq-match-proof-prop-test :-
    coq-locate "mbtree" MbTree, MbTree = indt GR,
    coq-env-indt GR tt _ _ TY _ _,
    pi x\ build-eq-match-proof-prop MbTree (l\ a\ b\ app [{{eq_ok}}, app [MbTree|l], x, a, b]) [] (Out x),
    coq-say Out.

%% build-eq-match-proof-apply-params-conss %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO remove, same as gen-app
build-eq-match-proof-apply-params-conss Params Cons Out :-
    app-type Cons Params Out.
%% build-eq-match-proof-apply-params-types %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TODO remove, save as tp-apply
build-eq-match-proof-apply-params-types L (prod N T Bo) Out :-
    build-eq-match-proof-apply-params-types L (lam N T Bo) Out.
build-eq-match-proof-apply-params-types [P|Params] (lam _ _ Bo) Out :-
    build-eq-match-proof-apply-params-types Params (Bo P) Out.
build-eq-match-proof-apply-params-types [] Tp Tp.

%% build-eq-match-proof %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type   : the considered type
%   Cmp    : the comparison function we're proving
%   Params : the parameters of Type
%   Prop   : a function taking the list of parameters of the type and two terms
%            and gives the induction property for these
%   TY     : unused, to remove TODO
%   Conss  : the constructors of Type
%   Types  : the types of the constructors
%   A      : the first term of the comparison in the proof
% Returns a term of type :
%       forall (b : Type Params), Prop Params A b
build-eq-match-proof Type Cmp Params Prop TY Conss Types A (app Out) :-
    Type = indt GR, coq-string-of-gr GR GRS,
    IndName is GRS ^ "_ind", coq-locate IndName Ind,
    build-eq-match-proof-prop Type Prop Params P,
    map Conss (build-eq-match-proof-apply-params-conss Params) Conss',
    map Types (build-eq-match-proof-apply-params-types Params) Types',
    build-eq-match-proof-apply-params-conss Params Type Type',
    map2 Conss' Types' (build-match-for-constructor-proof Type' Cmp (Prop Params) Conss' Types' []) Steps,
    flatten [[Ind], Params, [P], Steps, [A]] Out.

build-eq-match-proof-test :-
    coq-locate "mlist" Mlist, Mlist = indt GR,
    coq-locate "mlist_equal" Cmp,
    coq-env-indt GR tt _ _ TY LC LT,
    (pi A\ pi B\ pi eqA\ pi eqB\ pi hA\ pi hB\ pi a\
        (pi a\ pi b\  eq-proof A (pr a b) (app [hA, a, b]) (app [eqA, a, b])) =>
        ((pi a\ pi b\ eq-proof B (pr a b) (app [hB, a, b]) (app [eqB, a, b])) =>
        build-eq-match-proof Mlist 
            (app [Cmp, A, B, eqA, eqB])
            [A, B]
            (l\ a\ b\ app [{{eq_ok}}, app [Mlist|l], app [app [Cmp|l], eqA, eqB], a, b])
            TY LC LT a
            (Out A B eqA eqB hA hB a))),
    Bo = (lam "A" {{Type}} A\ lam "B" {{Type}} B\
        lam "eqA" {{lp:A -> lp:A -> bool}} eqA\ lam "eqB" {{lp:B -> lp:B -> bool}} eqB\
        lam "hA" {{forall (a b : lp:A), eq_ok lp:A lp:eqA a b}} hA\
        lam "hB" {{forall (a b : lp:B), eq_ok lp:B lp:eqB a b}} hB\
        lam _ (app [Mlist, A, B]) a\ Out A B eqA eqB hA hB a),
    coq-print-universe-constraints,
    coq-elaborate Bo Bo' TBo,
    coq-say Bo',
    coq-say TBo,
    coq-print-universe-constraints,
    coq-env-add-const "mlist_equal_ok" Bo' TBo _.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% Taking the arguments %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% build-eq-body %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type : the considered type
%   L    : the parameters of Type
% Returns a terms taking two terms of type (Type L) and checking their
% equality
build-eq-body Type L Out :-
    pi t1\ pi t2\ build-eq-match Type L t1 t2 (Bo t1 t2),
    app-type Type L Type',
    Out = lam _ Type' t1\ lam _ Type' t2\ Bo t1 t2.

build-eq-body-test :-
    eq-signature {{nat}} Sign,
    eq-test {{nat}} {{eq_nat}} Sign
        => build-eq-body {{nat}} [] Out,
    coq-say Out.

%% get-types-for-construction %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   L  : the parameters of the type
%   Bo : the type of a constructor
% Returns the list of the arguments of the constructor after L has been applied.
% TODO could be simplified using tp-apply
get-types-for-construction' [X|L] (lam _ T B) Out :-
    get-types-for-construction' L (B X) Out.
get-types-for-construction' [] Bo Out :-
    constructor-args Out Bo.
get-types-for-construction L Bo Out :-
    get-types-for-construction' L {prod-2-lam Bo} Out.

%% same-type %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
same-type T T.
same-type T (app [T|_]).

same-type-test :-
    coq-locate "nat" Nat,
    coq-locate "list" List,
    same-type Nat Nat,
    not(same-type Nat List),
    same-type List (app [List, Nat]),
    not(same-type Nat (app [List, Nat])),
    coq-say "Success !".

%% bind-types %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type : the considered type
%   LT   : the types of the constructors of Type
%   L    : an accumulator of bound parameters, should be set to []
%   TY   : the type of Type
% Returns :
%   Ndec   : the number of parameters of Type
%   Tout   : the Coq type of OTypes (ie takes the types as prod parameters)
%   FT     : an arbitrary function taking as many arguments as Type has parameters
%            and which gives the type of OTypes when applied to them
%   OTypes : an arbitrary function taking as many arguments as Type has parameters
%            and which gives the list of types an equality function is needed
%            for
bind-types Ndec Type LT L (lam N T B)
        (prod N T TBo) (atf-lam FT) (atf-lam OTypes) :-
    pi x\ bind-types N1 Type LT [x|L] (B x) (TBo x) (FT x) (OTypes x),
    Ndec is N1 + 1.
bind-types Ndec Type LT L' _ TOut (atf-const TOut) (atf-const OTypes) :-
    rev L' L,
    map LT (get-types-for-construction L) Args,
    flatten Args Args', unique Args' Args'',
    filter (x\ not(eq-test x _ _)) Args'' Args''',
    filter (x\ not(same-type Type x)) Args''' OTypes,
    get-type Type L OTypes TOut,
    length OTypes Ndec.

bind-types-test :-
    coq-locate "mlist" Mlist, Mlist = indt GR,
    coq-env-indt GR tt _ _ TY' LC LT,
    prod-2-lam TY' TY,
    bind-types Ndec Mlist LT [] TY Tout Fout OTypes,
    coq-say Ndec,
    coq-say Tout,
    coq-say Fout,
    coq-say OTypes.

%% get-type %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type : the considered type
%   Args : the parameters of Type
%   Tps  : list of types an equality function is needed for
% Returns the signature of the generated equality function.
get-type Type Args [T|Tps] (prod _ Sign TBo) :-
    eq-signature T Sign,
    pi f\ get-type Type Args Tps (TBo f).
get-type Type [] [] TOut :-
    eq-signature Type TOut.
get-type Type Args [] TOut :-
    eq-signature (app [Type|Args]) TOut.

%% apply-ft %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Recursively apply an arbitrary function to a list of parameters. Assumes the
% application is complete (ie the result is an atf-const)
apply-ft' [X|L] FT TOut :-
    atf-apply FT X FT',
    apply-ft' L FT' TOut.
apply-ft' [] FT FT.
apply-ft  L FT Out :-
    apply-ft' L FT ATF,
    ATF = atf-const Out.

type nrel (list term) -> term -> prop.
apply-ft-test :-
    L = [{{mbtree}}, {{nat}}],
    (pi l tp\ (
       nrel l tp :- apply-ft l
             (atf-lam x0\
               atf-lam x1\
                atf-const
                 (prod _ x0 a\ prod _ x1 b\ {{nat -> nat -> bool}}))
             tp))
              => (nrel L X, coq-say X).

%% build-eq-for-type %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Build the equality function for type Type, returning its body Out and its
% type TOut
build-eq-for-type Type Out TOut :-
    Type = indt GR,
    coq-env-indt GR tt _ _ TY' LC LT,
    prod-2-lam TY' TY,
    bind-types Ndec Type LT [] TY TOut FOut OTypes,
    % Only one of the following to additions to eq-test will be used,
    % depending on whether Type is dependant or not
    pi f\ eq-test Type f TOut
     => ((pi l tp\
           eq-test (app [Type|l]) (app [f|l]) tp :-
               apply-ft l FOut tp
         )
      => get-eqs Type TY [] OTypes (Bo f)),
    Out = fix _ Ndec TOut Bo.

get-eqs Type (lam N T B) L (atf-lam F)         (lam N T Bo) :-
    pi x\ get-eqs Type (B x) [x|L] (F x) (Bo x).
get-eqs Type X           L (atf-const [T|Tps]) (lam _ Sign Bo) :-
    eq-signature T Sign,
    pi f\ eq-test T f Sign => get-eqs Type X L (atf-const Tps) (Bo f).
get-eqs Type _           L (atf-const [])      Out :-
    build-eq-body Type {rev L} Out.

build-eq-for-type-test :-
    build-eq-for-type {{mlist}} Out TOut,
    coq-say TOut,
    coq-say Out.

%% build-eq-for-type-proof %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arguments :
%   Type   : the considered type
%   Cmp    : the comparison function we're proving
%   TY     : the type of Type
%   Prop   : a function taking a list of equality functions, a list of parameters
%            and two terms and create the proven propositions for those terms
%   TY     : the type of Type (again)
%   Params : an accumulator for the parameters of Type, should be set to []
%   Conss  : the constructors of Type
%   Types  : the types of the constructors
% Returns the proof of correction of Cmp
%
% More specifically, it is split in three parts. The first one abstract over
% the parameters of the types, the middle one over the equality function
% necessary and the end one over the proofs of validity of those functions
build-eq-for-type-proof Type Cmp TY Prop (prod N T Bo) Params Conss Types (lam N T Out) :-
    pi x\ build-eq-for-type-proof Type Cmp TY Prop (Bo x) [x|Params] Conss Types (Out x).
build-eq-for-type-proof Type Cmp TY Prop (lam N T Bo) Params Conss Types (lam N T Out) :-
    pi x\ build-eq-for-type-proof Type Cmp TY Prop (Bo x) [x|Params] Conss Types (Out x).
build-eq-for-type-proof Type Cmp TY Prop _ Params' Conss Types Out :-
    rev Params' Params,
    map Types (get-types-for-construction Params) Args,
    flatten Args Args', unique Args' Args'',
    filter (x\ not(eq-test x _ _)) Args'' Args''',
    filter (x\ not(same-type Type x)) Args''' Deqs,
    build-eq-for-type-proof-middle Type (app [Cmp|Params]) TY Prop Params Deqs [] Conss Types Out.

build-eq-for-type-proof-middle Type Cmp TY Prop Params [T|Deqs] Leqs Conss Types (lam Name DT Out) :-
    eq-signature T DT,
    get-name-of-type T Name', Name is "eq" ^ Name',
    pi eq\ build-eq-for-type-proof-middle Type (app [Cmp,eq]) TY Prop Params Deqs [pr eq T|Leqs] Conss Types (Out eq).
build-eq-for-type-proof-middle Type Cmp TY Prop Params [] Leqs' Conss Types Out :-
    rev Leqs' Leqs,
    map Leqs fst Eqs,
    build-eq-for-type-proof-end Type Cmp TY (Prop Eqs) Params Leqs Conss Types Out.

build-eq-for-type-proof-end Type Cmp TY Prop Params [pr Eq T|Leqs] Conss Types (lam Name TH Out) :-
    get-name-of-type T Name', Name is "Heq" ^ Name',
    TH = prod "a" T (a\ prod "b" T (b\ app [{{eq_ok}}, T, Eq, a, b])),
    pi h\ (pi a\ pi b\ eq-proof T (pr a b) (app [h, a, b]) (app [Eq, a, b])) =>
        build-eq-for-type-proof-end Type Cmp TY Prop Params Leqs Conss Types (Out h).
build-eq-for-type-proof-end Type Cmp TY Prop Params [] Conss Types Out :-
    app-type Type Params Type',
    pi a\ build-eq-match-proof Type Cmp Params Prop TY Conss Types a (Out' a),
    Out = lam "a" Type' a\ Out' a.

get-name-of-type (indt GR) Name :-
    coq-string-of-gr GR Name.
get-name-of-type _ "_".

build-eq-for-type-proof-test :-
    coq-locate "mbtree" MbTree, MbTree = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    coq-locate "mbtree_equal" Cmp,
    build-eq-for-type-proof MbTree Cmp TY (eqs\ l\ a\ b\ app [{{eq_ok}}, MbTree, app [Cmp|eqs], a, b]) TY [] LC LT Bo,
    coq-say Bo,
    coq-elaborate Bo Bo' TBo,
    coq-env-add-const "mbtree_equal_ok" Bo' TBo _.

%% create-eq %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Add to the environment an equality function for type Type, named
% (name of type)_equal
create-eq Type :-
    build-eq-for-type Type Eq TEq, Type = indt GR,
    coq-string-of-gr GR S,
    Name is S ^ "_equal",
    coq-env-add-const Name Eq TEq (const NGR),
    coq-string-of-gr NGR Name.

create-eq-test :- create-eq {{mbtree}}.

%% create-eq-proof %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Add to the environment a proof of validity for the equality function
% (name of type)_equal as generated above, and name (name of type)_equal_ok
create-eq-proof Type :-
    Type = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    coq-string-of-gr GR S,
    CmpName is S ^ "_equal", coq-locate CmpName Cmp,
    build-eq-for-type-proof Type Cmp TY
        (eqs\ l\ a\ b\ app [{{eq_ok}}, app [Type|l], app [app [Cmp|l]|eqs], a, b])
        TY [] LC LT Out,
    coq-say Out,
    coq-elaborate Out Out' TOut,
    Name is S ^ "_equal_ok",
    coq-env-add-const Name Out' TOut _.

create-eq-proof-test :-
    create-eq-proof {{mbtree}}.

%% create-eq-from-name %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Same as create-eq, but takes the name of the type instead of the type itself
% as argument
create-eq-from-name Name :-
    coq-locate Name Type,
    create-eq Type.

%% create-eq-with-proof %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Takes the name of a type and creates both the comparison function and its
% proof at the same time
create-eq-with-proof Name :-
    coq-locate Name Type,
    create-eq Type, !,
    create-eq-proof Type.

% vim:set ft=lprolog:
