
accumulate coq-lib.
accumulate lp-lib.

%% arbitrary-term-function
% Necessary because some relation recursively build function
% of arity n, which raise an error with the typer.
kind arbitrary-term-function type -> type.
type atf-const A -> arbitrary-term-function A.
type atf-lam   (term -> arbitrary-term-function A)
                     -> arbitrary-term-function A.

atf-apply (atf-lam F) T (F T).
atf-apply A           _ A.

%% Miscellaneous utilities
type unique list A -> list A -> prop.
unique [X|L] L'     :- mem X L,      unique L L'.
unique [X|L] [X|L'] :- not(mem X L), unique L L'.
unique []    [].

unique-test :-
    unique [1,2,5,8,9,6,3,5,4,7,8,5,1,2,3,6,5,4,7,8,9,6] Out,
    coq-say Out.

same-length [X|L] [X'|L'] :- same-length L L'.
same-length [] [].

inductive-on-type' T T.
inductive-on-type' T T' :- inductive-on-type T T'.

inductive-on-type TP (lam _ T F) :-
    inductive-on-type' TP T; pi x\ inductive-on-type TP (F x).
inductive-on-type TP (prod _ T F) :-
    inductive-on-type' TP T; pi x\ inductive-on-type TP (F x).
inductive-on-type TP (app L) :-
    exists L (inductive-on-type' TP).

%% flatten-app
flatten-app (app [app L|X]) (app L') :-
    flatten-app (app L) (app FL),
    append FL X L'.
flatten-app (app L) (app L).

flatten-app-test :-
    coq-locate "nat" Nat,
    flatten-app (app [app [app [Nat, Nat], Nat], Nat, app [Nat, Nat], Nat]) Out,
    coq-say Out.

%% eq-signature
eq-signature Type Sign :-
    coq-locate "bool" Bool,
    Sign = (prod _ Type _\ prod _ Type _\ Bool).

eq-signature-test :-
    eq-signature {{nat}} Sign,
    coq-say Sign,
    {{eq_nat}} = const Eq,
    coq-env-const Eq _ TY,
    coq-say TY.

%% eq-test
type eq-function term -> term -> prop.
eq-test Tp Eq EqTp :-
    eq-function Tp Eq, Eq = const GR,
    coq-env-const GR _ EqTp.

eq-test (app [Tp|L]) (app [Eq|L]) Type :-
    eq-function Tp Eq, Eq = const GR,
    coq-env-const GR _ EqTp,
    spec-function {prod-2-lam EqTp} ATF,
    apply-ft L ATF Type.

eq-test-test :-
    coq-say {{prod nat nat}},
    eq-test {{prod nat nat}} Cmp Tp,
    coq-say Cmp,
    coq-say Tp,
    simpl-eq-test Cmp Tp Eqf,
    coq-say Eqf.

spec-function (lam N T B) (atf-const (lam N T B)) :-
    eq-signature TP T.
spec-function (lam N (sort _) B) (atf-lam Out) :-
    pi x\ spec-function (B x) (Out x).
spec-function A           (atf-const A).

spec-function-test :-
    prod-2-lam {{forall A B : Type, (A -> A -> bool) -> (B -> B -> bool) -> mlist A B -> mlist A B -> bool}} Sign,
    spec-function Sign Out,
    coq-say Out.

type eq-proof term -> pair term term -> term -> prop.
% eq-proof type (pr a b) (t : eqf a b = true <-> a = b).

%% simpl-eq-test
simpl-eq-test' (lam _ Sign Bo) [Eqf|L] :-
    eq-signature Type Sign,
    eq-test Type Eqf' TpEq,
    simpl-eq-test' TpEq EqArgs,
    app-type Eqf' EqArgs Eqf,
    pi x\ simpl-eq-test' (Bo x) L.
simpl-eq-test' X [].
simpl-eq-test In InTp Out :-
    simpl-eq-test' {prod-2-lam InTp} L,
    app-type In L Out.

simpl-eq-test-test :-
    coq-locate "tmp" Tmp, Tmp = const GR,
    coq-env-const GR _ TY,
    eq-signature {{nat}} Sign,
    eq-test {{nat}} {{eq_nat}} Sign
        => simpl-eq-test Tmp TY Tmp',
    coq-say Tmp'.

simpl-eq-test-test' :-
    coq-locate "tmp'" Tmp, Tmp = const GR,
    coq-env-const GR _ TY,
    coq-locate "list" List,
    eq-signature {{nat}} Sign,
    pi l\ eq-signature (app [List|l]) (Type l),
    eq-test {{nat}} {{eq_nat}} Sign
        => (pi l\ eq-test (app [List|l]) (app [{{eq_list}}|l]) (Type l))
        => simpl-eq-test Tmp TY Tmp',
    coq-say Tmp'.

%% build-eq-check
build-eq-check And True [Trm] [Tp] Out :-
    eq-test Tp Eqf' TpEqf,
    simpl-eq-test Eqf' TpEqf Eqf,
    Trm   = pr A B,
    Out   = app [Eqf, A, B].
build-eq-check And True [Trm|Trms] [Tp|Tps] Out :-
    build-eq-check And True Trms Tps End,
    eq-test Tp Eqf' TpEqf,
    simpl-eq-test Eqf' TpEqf Eqf,
    Trm   = pr A B,
    Nterm = app [Eqf, A, B],
    Out   = app [And, Nterm, End].
build-eq-check And True [] [] True.

build-eq-check-test :-
    coq-locate "andb"   And,
    coq-locate "true"   True,
    coq-locate "nat"    Nat,
    coq-locate "O"      Zero,
    coq-locate "S"      Succ,
    coq-locate "eq_nat" Eq, Eq = const GR,
    coq-env-const GR _ TY,
    eq-test Nat Eq TY => build-eq-check And True
                         [pr Zero Zero, pr Zero Zero]
                         [Nat, Nat] Out,
    coq-say Out.

build-eq-check-test' :-
    coq-locate "andb" And,
    coq-locate "true" True,
    coq-locate "nat"  Nat,
    coq-locate "O" Zero,
    coq-locate "eq_nat" Eq, Eq = const GR,
    coq-env-const GR _ TY,
    eq-test Nat Eq TY => build-eq-check And True [] [Nat] Out,
    coq-say Out.

% build-eq-check-proof-proj1 : eqf a b = true -> a = b

proof-xy T X Y Hxy (app [Proj1, app [IffAnd, Heq], Hxy]) :-
    coq-locate "proj1"   Proj1,
    coq-locate "iff_and" IffAnd,
    eq-proof T (pr X Y) Heq.

% Hqs    : list of terms of type eqf_i x_i y_i = true
% Terms* : list of terms x_i and y_i
% FgEq   : {{fg_equal}}
% Cons*  : the constructors used, partially applied, with their types
% Type   : the type of the partially applied constructor
% Proof  : term of type Cons1 = Cons2
build-eq-check-proof-proj1-eq Cons1 Cons2 (lam N T B) [X|Tx] [Y|Ty] [Hxy|Hqs] FgEq Proof Out :-
    flatten-app (app [Cons1, X]) AC1,
    flatten-app (app [Cons2, Y]) AC2,
    proof-xy T X Y Hxy Eqxy,
    pi t\ build-eq-check-proof-proj1-eq AC1 AC2 (B t) Tx Ty Hqs FgEq
        (app [FgEq, T, (B t), Cons1, Cons2, X, Y, Eqxy, Proof])
        Out.
build-eq-check-proof-proj1-eq Cons1 Cons2 _ [] [] [] _ Proof Proof.

build-eq-check-proof-proj1-eq-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "eq_refl" EqRefl,
    coq-locate "fg_equal" FgEq,
    pi eq\ pi heq\ pi x1\ pi y1\ pi x2\ pi y2\ pi x3\ pi y3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) heq) =>
        (build-eq-check-proof-proj1-eq MbNode MbNode {prod-2-lam TY} [x1, x2, x3] [y1, y2, y3]
            [eq, eq, eq] FgEq EqRefl (Out eq heq x1 y1 x2 y2 x3 y3)),
    coq-say Out.

build-eq-check-proof-proj1 N Cons Type Tx Ty Hqs' _ Out :-
    N is 0,
    rev Hqs' Hqs,
    build-eq-check-proof-proj1-eq Cons Cons Type Tx Ty Hqs {{fg_equal}} {{eq_refl}} Out.
build-eq-check-proof-proj1 N Cons Type Tx Ty Hqs H Out :-
    N > 0,
    N1 is N - 1,
    coq-locate "andb_prop" AndbProp,
    pi hxy\ pi h'\ build-eq-check-proof-proj1 N1 Cons Type Tx Ty [hxy|Hqs] h' (T hxy h'),
    Out = match (app [AndbProp, hole, hole, H]) hole [lam _ hole hxy\ lam _ hole h'\ T hxy h'].

build-eq-check-proof-proj1-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    pi h\ pi heq\ pi x1\ pi y1\ pi x2\ pi y2\ pi x3\ pi y3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) heq) =>
        build-eq-check-proof-proj1 3 MbNode {prod-2-lam TY}
            [x1, x2, x3] [y1, y2, y3] [] h (Out h heq x1 y1 x2 y2 x3 y3),
    coq-say Out.

build-eq-check-proof-proj2-projector-fun N Cons Def TOut C (lam Nm T TB) (lam Nm T Out) :-
    not(N is 0),
    N1 is N - 1,
    pi x\ build-eq-check-proof-proj2-projector-fun N1 Cons Def TOut C (TB x) (Out x).
build-eq-check-proof-proj2-projector-fun N Cons Def TOut C (lam Nm T TB) (lam Nm T Out) :-
    N is 0,
    N1 is N - 1,
    pi x\ build-eq-check-proof-proj2-projector-fun N1 Cons Def x C (TB x) (Out x).
build-eq-check-proof-proj2-projector-fun N Cons Def TOut C _ TOut :- C = Cons.
build-eq-check-proof-proj2-projector-fun N Cons Def TOut C _ Def  :- not(C = Cons).

build-eq-check-proof-proj2-projector-fun-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    pi d\ pi z\
        build-eq-check-proof-proj2-projector-fun 1 MbNode d z
            MbNode {prod-2-lam TY} (Out d),
    coq-say Out.

build-eq-check-proof-proj2-projector' N Cons Def Conss Types Z Matches :-
    map2 Conss Types (build-eq-check-proof-proj2-projector-fun N Cons Def Z) Matches.
build-eq-check-proof-proj2-projector N Cons Def Conss Types Out :-
    pi z\ build-eq-check-proof-proj2-projector' N Cons Def Conss Types z Matches,
    Out = lam _ hole x\ match x hole Matches.

build-eq-check-proof-proj2-projector-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT',
    map LT' prod-2-lam LT,
    pi d\ build-eq-check-proof-proj2-projector 1 MbNode d LC LT (Out d),
    coq-say Out.

build-eq-check-proof-proj2 N Cons Type (lam _ T Bo) Conss Types [X|Tx] [Y|Ty] [D|Ds] H Proof Out :-
    N is 0,
    N1 is N + 1,
    eq-proof T (pr X Y) Heq,
    build-eq-check-proof-proj2-projector N Cons D Conss Types F,
    pi x\ build-eq-check-proof-proj2 N1 Cons Type (Bo x) Conss Types Tx Ty Ds H
        (app [{{proj2}}, app [{{iff_and}}, Heq], app [F, H]]) Out.
build-eq-check-proof-proj2 N Cons Type (lam _ T Bo) Conss Types [X|Tx] [Y|Ty] [D|Ds] H Proof Out :-
    N1 is N + 1,
    eq-proof T (pr X Y) Heq,
    build-eq-check-proof-proj2-projector N Cons D Conss Types F,
    pi x\ build-eq-check-proof-proj2 N1 Cons Type (Bo x) Conss Types Tx Ty Ds H
        (app [{{conj}}, app [{{proj2}}, app [{{iff_and}}, Heq], app [F, H]], Proof]) Out.
build-eq-check-proof-proj2 _ _ _ _ _ _ [] [] [] _ Proof Proof.

build-eq-check-proof-proj2-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT',
    map LT' prod-2-lam LT,
    pi h\ pi heq\ pi x1\ pi y1\ pi d1\ pi x2\ pi y2\ pi d2\ pi x3\ pi y3\ pi d3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) heq) =>
        build-eq-check-proof-proj2 0 MbNode {prod-2-lam TY} {prod-2-lam TY} LC LT [x1, x2, x3] [y1, y2, y3]
            [d1, d2, d3] h {{eq_refl}} (Out h heq x1 y1 d1 x2 y2 d2 x3 y3 d3),
    coq-say Out.

build-eq-check-proof Cons Type Conss Types Tx Ty Out :-
    length Tx N,
    pi h\ build-eq-check-proof-proj1 N Cons Type Tx Ty [] h (Prj1 h),
    pi h\ build-eq-check-proof-proj2 0 Cons Type Type Conss Types Tx Ty Tx h {{eq_refl}} (Prj2 h),
    Out = app [{{conj}}, (lam _ hole h\ Prj1 h), (lam _ hole h\ Prj2 h)].

build-eq-check-proof-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY', prod-2-lam TY' TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT',
    map LT' prod-2-lam LT,
    pi h\ pi heq\ pi x1\ pi y1\ pi x2\ pi y2\ pi x3\ pi y3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) heq) =>
        build-eq-check-proof MbNode TY LC LT [x1, x2, x3] [y1, y2, y3] (Out h heq x1 y1 x2 y2 x3 y3),
    coq-say Out.

%% constructor-args
constructor-args [X|LS] (lam _ T F) :-
    X = T,
    pi x\ constructor-args LS (F x).
constructor-args [] T :-
    not(T = (lam _ _ _)),
    not(T = (prod _ _ _)).

constructor-args-test :-
    coq-locate "S" Succ, Succ = indc GR,
    coq-env-indc GR _ _ TY,
    constructor-args L TY,
    coq-say TY,
    coq-say L.

%% build-constructor-match
build-constructor-match TypeCons Terms TC Term :-
    TypeCons = pr Cons LCons,
    TC = pr C LC,
    C = Cons,
    eq-lambda Terms [] {prod-2-lam LC} Term [].
build-constructor-match TypeCons Terms TC Term :-
    TypeCons = pr Cons LCons,
    TC = pr C LC,
    not (C = Cons),
    false-lambda {prod-2-lam LC} Term.

eq-lambda Terms Types (lam N X B) (lam N X C) L :-
    pi x\ eq-lambda Terms [X|Types] (B x) (C x) [x|L].
eq-lambda Terms Types T Out L :-
    not (T = lam _ _ _),
    zip Terms L NTerms,
    build-eq-check {{andb}} {{true}} NTerms Types Out.

false-lambda (lam N X B) (lam N X C) :-
    pi x\ false-lambda (B x) (C x).
false-lambda _ {{false}}.

build-constructor-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    coq-locate "O" Zero,
    coq-locate "S" Succ,
    Succ = indc SGR, coq-env-indc SGR _ _ STY,
    pi x\ eq-test Nat EqNat TY => build-constructor-match (pr Succ STY) [x]
                                                          (pr Succ STY) (Out x),
    coq-say Out.

false-lambda-proof-proj1 Cx Tx Cy Ty (lam _ hole Out) :-
    pi h\ (False h) = app [{{eq_ind}}, {{false}}, 
                           lam _ {{bool}} e\ match e hole [{{False}},{{True}}],
                           {{I}}, {{true}}, h],
    pi h\ (Out h) = app [{{False_ind}}, {{lp:"app [Cx|Tx]" = lp:"app [Cy|Ty]"}}, (False h)].

false-lambda-proof-proj2-match-term False True Cons C (lam N T Bo) (lam N T Out) :-
    pi x\ false-lambda-proof-proj2-match-term False True Cons C (Bo x) (Out x).
false-lambda-proof-proj2-match-term False True Cons C _ False :-
    C = Cons.
false-lambda-proof-proj2-match-term False True Cons C _ True :-
    not(C = Cons).

false-lambda-proof-proj2 Type Cx Cy Conss Types Tx Ty (lam _ hole Out) :-
    map2 Conss Types (false-lambda-proof-proj2-match-term {{False}} {{True}} Cy) MTerms,
    Match = lam _ Type (e\ match e hole MTerms),
    (pi h\ (False h) = app [{{eq_ind}}, app [Cx|Tx], Match, {{I}}, app [Cy|Ty], h]),
    (pi h\ (Out h) = app [{{False_ind}}, {{false = true}}, False h]).

false-lambda-proof Type Cx Tx Cy Ty Conss Types Out :-
    false-lambda-proof-proj1 Cx Tx Cy Ty Prj1,
    false-lambda-proof-proj2 Type Cx Cy Conss Types Tx Ty Prj2,
    Out = app [{{conj}}, Prj1, Prj2].

false-lambda-proof-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY', prod-2-lam TY' TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT', map LT' prod-2-lam LT,
    coq-locate "mbleaf" MbLeaf, MbLeaf = indc GR'',
    coq-env-indc GR'' _ _ TY''', prod-2-lam TY''' TY'',
    pi x1\ pi x2\ pi x3\ pi y\
        false-lambda-proof MbTree MbNode [x1, x2, x3] MbLeaf [y] LC LT (Out x1 x2 x3 y),
    coq-say Out.

build-constructor-match-proof Type Cx Tx Conss Types C (lam N T Bo) TC L (lam N T Out) :-
    pi x\ build-constructor-match-proof Type Cx Tx Conss Types C (Bo x) TC [x|L] (Out x).
build-constructor-match-proof Type Cx Tx Conss Types C _ _ L Out :-
    not(Cx = C),
    rev L Ty,
    false-lambda-proof Type Cx Tx C Ty Conss Types Out.
build-constructor-match-proof Type Cx Tx Conss Types C _ TC L Out :-
    Cx = C,
    rev L Ty,
    build-eq-check-proof C TC Conss Types Tx Ty Out.

build-constructor-match-proof-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY', prod-2-lam TY' TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT', map LT' prod-2-lam LT,
    coq-locate "mbleaf" MbLeaf, MbLeaf = indc GR'',
    coq-env-indc GR'' _ _ TY''', prod-2-lam TY''' TY'',
    pi heq\ pi x1\ pi x2\ pi x3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) heq) =>
        build-constructor-match-proof MbTree MbNode [x1, x2, x3] LC LT MbNode TY TY [] (Out heq x1 x2 x3),
    coq-say Out,
    pi x1\ pi x2\ pi x3\
        build-constructor-match-proof MbTree MbNode [x1, x2, x3] LC LT MbLeaf TY'' TY'' [] (Out' x1 x2 x3),
    coq-say Out'.

%% sub-match
sub-match Type TypeConss TypeCons T Terms Out :-
    map TypeConss (build-constructor-match TypeCons Terms) MTerms,
    coq-locate "bool"  Bool,
    Out = match T (lam _ Type _ \ Bool) MTerms.

sub-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    coq-locate "O" Zero,
    Zero = indc ZGR, coq-env-indc ZGR _ _ ZTY,
    coq-locate "S" Succ,
    Succ = indc SGR, coq-env-indc SGR _ _ STY,
    pi x\ pi y\ eq-test Nat EqNat TY => sub-match Nat [pr Zero ZTY, pr Succ STY]
                                                  (pr Succ STY) x [y] (Out x y),
    coq-say Out.

%% build-match-for-constructor
build-match-for-constructor Type      % The global type
                            T         % The second term to compare
                            TypeConss % List of the constructors
                            TypeCons  % The type of the constructor
                            Out       % The result (ie a function for a
                                      % mach on this constructor)
                            :-
    TypeCons = pr Cons CType,
    sub-match-build Type TypeConss TypeCons T [] {prod-2-lam CType} Out.

sub-match-build Type Conss TypeCons T L (lam N X B) (lam N X C) :-
    pi x\ sub-match-build Type Conss TypeCons T [x|L] (B x) (C x).
sub-match-build Type Conss TypeCons T L _ Out :-
    sub-match Type Conss TypeCons T L Out.

build-match-for-constructor-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GREq, coq-env-const GREq _ TEq,
    coq-locate "nat" Nat, Nat = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    coq-locate "S" Succ, Succ = indc GR',
    coq-env-indc GR' _ _ TYSucc,
    zip LC LT TypeConss,
    pi t\ eq-test Nat EqNat TEq => build-match-for-constructor Nat t TypeConss
                                   (pr Succ TYSucc) (Out t),
    coq-say Out.

%% app-type
app-type Type [] Type.
app-type Type L (app [Type|L]).

%% build-eq-match
build-eq-match Type L T1 T2 Out :-
    Type = indt GR,
    coq-env-indt GR tt _ _ TY LC' LT',
    map LC' (gen-app L) LC,
    map LT' (tp-apply L) LT,
    zip LC LT TypeConss,
    app-type Type L Type',
    map TypeConss (build-match-for-constructor Type' T2 TypeConss) MTerms,
    coq-locate "bool"  Bool,
    Out = match T1 (lam _ Type' _ \ Bool) MTerms.

tp-apply' [X|L] (lam _ _ B) Out :-
    tp-apply' L (B X) Out.
tp-apply' [] T T.
tp-apply L B Out :-
    tp-apply' L {prod-2-lam B} Out.

gen-app [] C C.
gen-app L  C (app [C|L]).

build-eq-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    pi x\ pi y\ eq-test Nat EqNat TY => build-eq-match Nat [] x y
                                                      (Out x y),
    coq-say Out.

%% build-eq-body
build-eq-body Type L Out :-
    pi t1\ pi t2\ build-eq-match Type L t1 t2 (Bo t1 t2),
    app-type Type L Type',
    Out = lam _ Type' t1\ lam _ Type' t2\ Bo t1 t2.

build-eq-body-test :-
    eq-signature {{nat}} Sign,
    eq-test {{nat}} {{eq_nat}} Sign
        => build-eq-body {{nat}} [] Out,
    coq-say Out.

%% get-types-for-construction
get-types-for-construction' [X|L] (lam _ T B) Out :-
    get-types-for-construction' L (B X) Out.
get-types-for-construction' [] Bo Out :-
    constructor-args Out Bo.
get-types-for-construction L Bo Out :-
    get-types-for-construction' L {prod-2-lam Bo} Out.

%% same-type
same-type T T.
same-type T (app [T|_]).

same-type-test :-
    coq-locate "nat" Nat,
    coq-locate "list" List,
    same-type Nat Nat,
    not(same-type Nat List),
    same-type List (app [List, Nat]),
    not(same-type Nat (app [List, Nat])),
    coq-say "Success !".

%% bind-types
bind-types Ndec Type LT L (lam N T B)
        (prod N T TBo) (atf-lam FT) (atf-lam OTypes) :-
    pi x\ bind-types N1 Type LT [x|L] (B x) (TBo x) (FT x) (OTypes x),
    Ndec is N1 + 1.
bind-types Ndec Type LT L' _ TOut (atf-const TOut) (atf-const OTypes) :-
    rev L' L,
    map LT (get-types-for-construction L) Args,
    flatten Args Args', unique Args' Args'',
    filter (x\ not(eq-test x _ _)) Args'' Args''',
    filter (x\ not(same-type Type x)) Args''' OTypes,
    get-type Type L OTypes TOut,
    length OTypes Ndec.

bind-types-test :-
    coq-locate "mlist" Mlist, Mlist = indt GR,
    coq-env-indt GR tt _ _ TY' LC LT,
    prod-2-lam TY' TY,
    bind-types Ndec Mlist LT [] TY Tout Fout OTypes,
    coq-say Ndec,
    coq-say Tout,
    coq-say Fout,
    coq-say OTypes.

%% get-type
get-type Type Args [T|Tps] (prod _ Sign TBo) :-
    eq-signature T Sign,
    pi f\ get-type Type Args Tps (TBo f).
get-type Type [] [] TOut :-
    eq-signature Type TOut.
get-type Type Args [] TOut :-
    eq-signature (app [Type|Args]) TOut.

%% apply-ft
apply-ft' [X|L] FT TOut :-
    atf-apply FT X FT',
    apply-ft' L FT' TOut.
apply-ft' [] FT FT.
apply-ft  L FT Out :-
    apply-ft' L FT ATF,
    ATF = atf-const Out.

type nrel (list term) -> term -> prop.
apply-ft-test :-
    L = [{{mbtree}}, {{nat}}],
    (pi l tp\ (
       nrel l tp :- apply-ft l
             (atf-lam x0\
               atf-lam x1\
                atf-const
                 (prod _ x0 a\ prod _ x1 b\ {{nat -> nat -> bool}}))
             tp))
              => (nrel L X, coq-say X).

%% build-eq-for-type
build-eq-for-type Type Out TOut :-
    Type = indt GR,
    coq-env-indt GR tt _ _ TY' LC LT,
    prod-2-lam TY' TY,
    bind-types Ndec Type LT [] TY TOut FOut OTypes,
    % Only one of the following to additions to eq-test will be used,
    % depending on whether Type is dependant or not
    pi f\ eq-test Type f TOut
     => ((pi l tp\
           eq-test (app [Type|l]) (app [f|l]) tp :-
               apply-ft l FOut tp
         )
      => get-eqs Type TY [] OTypes (Bo f)),
    Out = fix _ Ndec TOut Bo.

get-eqs Type (lam N T B) L (atf-lam F)         (lam N T Bo) :-
    pi x\ get-eqs Type (B x) [x|L] (F x) (Bo x).
get-eqs Type X           L (atf-const [T|Tps]) (lam _ Sign Bo) :-
    eq-signature T Sign,
    pi f\ eq-test T f Sign => get-eqs Type X L (atf-const Tps) (Bo f).
get-eqs Type _           L (atf-const [])      Out :-
    build-eq-body Type {rev L} Out.

build-eq-for-type-test :-
    build-eq-for-type {{mlist}} Out TOut,
    coq-say TOut,
    coq-say Out.

%% create-eq
create-eq Type :-
    build-eq-for-type Type Eq TEq, Type = indt GR,
    coq-string-of-gr GR S,
    Name is S ^ "_equal",
    coq-env-add-const Name Eq TEq (const NGR),
    coq-string-of-gr NGR Name.

create-eq-test :- create-eq {{mbtree}}.

%% create-eq-from-name
create-eq-from-name Name :-
    coq-locate Name Type,
    create-eq Type.

