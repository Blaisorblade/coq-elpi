
accumulate coq-lib.
accumulate lp-lib.

type unique list A -> list A -> prop.
unique [X|L] L'     :- mem X L,      unique L L'.
unique [X|L] [X|L'] :- not(mem X L), unique L L'.
unique []    [].

unique-test :-
    unique [1,2,5,8,9,6,3,5,4,7,8,5,1,2,3,6,5,4,7,8,9,6] Out,
    coq-say Out.

same-length [X|L] [X'|L'] :- same-length L L'.
same-length [] [].

inductive-on-type' T T.
inductive-on-type' T T' :- inductive-on-type T T'.

inductive-on-type TP (lam _ T F) :-
    inductive-on-type' TP T; pi x\ inductive-on-type TP (F x).
inductive-on-type TP (prod _ T F) :-
    inductive-on-type' TP T; pi x\ inductive-on-type TP (F x).
inductive-on-type TP (app L) :-
    exists L (inductive-on-type' TP).

%% eq-signature
eq-signature Type Sign :-
    coq-locate "bool" Bool,
    Sign = (prod _ Type _\ prod _ Type _\ Bool).

eq-signature-test :-
    eq-signature {{nat}} Sign,
    coq-say Sign,
    {{eq_nat}} = const Eq,
    coq-env-const Eq _ TY,
    coq-say TY.

%% eq-test
type eq-test term -> term -> term -> prop.

simpl-eq-test' (lam _ Sign Bo) [Eqf|L] :-
    eq-signature Type Sign,
    eq-test Type Eqf TpEq,
    pi x\ simpl-eq-test' (Bo x) L.
simpl-eq-test' X [].
simpl-eq-test In InTp Out :-
    simpl-eq-test' {prod-2-lam InTp} L,
    not(null L),
    Out = app [In|L].
simpl-eq-test In InTp In :-
    simpl-eq-test' {prod-2-lam InTp} L,
    null L.

simpl-eq-test-test :-
    coq-locate "tmp" Tmp, Tmp = const GR,
    coq-env-const GR _ TY,
    eq-signature {{nat}} Sign,
    eq-test {{nat}} {{eq_nat}} Sign
        => simpl-eq-test Tmp TY Tmp',
    coq-say Tmp'.

%% build-eq-check
build-eq-check And True [Trm|Trms] [Tp|Tps] Out :-
    build-eq-check And True Trms Tps End,
    eq-test Tp Eqf' TpEqf,
    simpl-eq-test Eqf' TpEqf Eqf,
    Trm   = pr A B,
    Nterm = app [Eqf, A, B],
    Out   = app [And, Nterm, End].
build-eq-check And True [] [] Out :- Out = True.

build-eq-check-test :-
    coq-locate "andb"   And,
    coq-locate "true"   True,
    coq-locate "nat"    Nat,
    coq-locate "O"      Zero,
    coq-locate "S"      Succ,
    coq-locate "eq_nat" Eq, Eq = const GR,
    coq-env-const GR _ TY,
    eq-test Nat Eq TY => build-eq-check And True
                         [pr Zero Zero, pr Zero Zero]
                         [Nat, Nat] Out,
    coq-say Out.

build-eq-check-test' :-
    coq-locate "andb" And,
    coq-locate "true" True,
    coq-locate "nat"  Nat,
    coq-locate "O" Zero,
    coq-locate "eq_nat" Eq, Eq = const GR,
    coq-env-const GR _ TY,
    eq-test Nat Eq TY => build-eq-check And True [] [Nat] Out,
    coq-say Out.

%% constructor-args
constructor-args [X|LS] (lam _ T F) :-
    X = T,
    pi x\ constructor-args LS (F x).
constructor-args [X|LS] (prod _ T F) :-
    X = T,
    pi x\ constructor-args LS (F x).
constructor-args [] T :-
    not(T = (lam _ _ _)),
    not(T = (prod _ _ _)).

constructor-args-test :-
    coq-locate "S" Succ, Succ = indc GR,
    coq-env-indc GR _ _ TY,
    constructor-args L TY,
    coq-say TY,
    coq-say L.

%% build-constructor-match
build-constructor-match Cons Terms C Term :-
    C = Cons,
    Cons = indc GR,
    coq-env-indc GR _ _  LCons,
    eq-lambda Terms [] {prod-2-lam LCons} Term [].
build-constructor-match Cons Terms C Term :-
    not (C = Cons),
    C = indc GR,
    coq-env-indc GR _ _ LCons,
    false-lambda {prod-2-lam LCons} Term.

eq-lambda Terms Types (lam N X B) (lam N X C) L :-
    pi x\ eq-lambda Terms [X|Types] (B x) (C x) [x|L].
eq-lambda Terms Types T Out L :-
    not (T = lam _ _ _),
    zip Terms L NTerms,
    build-eq-check {{andb}} {{true}} NTerms Types Out.

false-lambda (lam N X B) (lam N X C) :-
    pi x\ false-lambda (B x) (C x).
false-lambda _ {{false}}.

build-constructor-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    coq-locate "O" Zero,
    coq-locate "S" Succ,
    pi x\ eq-test Nat EqNat TY => build-constructor-match Succ [x]
                                                          Succ (Out x),
    coq-say Out.

%% sub-match
sub-match Type Conss Cons T Terms Out :-
    map Conss (build-constructor-match Cons Terms) MTerms,
    coq-locate "bool"  Bool,
    Out = match T (lam _ Type _ \ Bool) MTerms.

sub-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    coq-locate "O" Zero,
    coq-locate "S" Succ,
    pi x\ pi y\ eq-test Nat EqNat TY => sub-match Nat [Zero, Succ]
                                                  Succ x [y] (Out x y),
    coq-say Out.

%% build-match-for-constructor
build-match-for-constructor Type      % The global type
                            T         % The second term to compare
                            Conss     % List of the constructors
                            TypeCons  % The type of the constructor
                            Out       % The result (ie a function for a
                                      % mach on this constructor)
                            :-
    TypeCons = pr Cons Ctype,
    Cons = indc GR,
    coq-env-indc GR _ _  LCons,
    sub-match-build Type Conss Cons T [] {prod-2-lam LCons} Out.

sub-match-build Type Conss Cons T L (lam N X B) (lam N X C) :-
    pi x\ sub-match-build Type Conss Cons T [x|L] (B x) (C x).
sub-match-build Type Conss Cons T L _ Out :-
    sub-match Type Conss Cons T L Out.

build-match-for-constructor-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GREq, coq-env-const GREq _ TEq,
    coq-locate "nat" Nat, Nat = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    coq-locate "S" Succ, Succ = indc GR',
    coq-env-indc GR' _ _ TYSucc,
    pi t\ eq-test Nat EqNat TEq => build-match-for-constructor Nat t LC
                                   (pr Succ TYSucc) (Out t),
    coq-say Out.

%% build-eq-match
build-eq-match Type T1 T2 Out :-
    Type = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    zip LC LT TypeConss,
    map TypeConss (build-match-for-constructor Type T2 LC) MTerms,
    coq-locate "bool"  Bool,
    Out = match T1 (lam _ Type _ \ Bool) MTerms.

build-eq-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    pi x\ pi y\ eq-test Nat EqNat TY => build-eq-match Nat x y
                                                      (Out x y),
    coq-say Out.

%% build-eq-body
build-eq-body Type Out :-
    pi t1\ pi t2\ build-eq-match Type t1 t2 (Bo t1 t2),
    Out = lam _ Type t1\ lam _ Type t2\ Bo t1 t2.

build-eq-body-test :-
    eq-signature {{nat}} Sign,
    eq-test {{nat}} {{eq_nat}} Sign
        => build-eq-body {{nat}} Out,
    coq-say Out.

%% build-eq-for-type
build-eq-for-type Type Out TOut :-
    Type = indt GR,
    coq-env-indt GR tt _ _ _ LC LT,
    map LT (flip constructor-args) Args,
    flatten Args Args',
    unique Args' Args'',
    filter (x\ not(eq-test x _ _)) Args'' Args''',
    filter (x\ not(x = Type)) Args''' OTypes,
    get-type Type OTypes TOut,
    pi f\ eq-test Type f TOut => get-eqs Type OTypes (Bo f),
    length OTypes Ndec,
    Out = fix _ Ndec TOut Bo.

get-type Type [T|Tps] (prod _ Sign TBo) :-
    eq-signature T Sign,
    pi f\ get-type Type Tps (TBo f).
get-type Type [] TOut :-
    eq-signature Type TOut.

get-eqs Type [T|Tps] (lam _ Sign Bo) :-
    eq-signature T Sign,
    pi f\ eq-test T f Sign => get-eqs Type Tps (Bo f).
get-eqs Type [] Out :-
    build-eq-body Type Out.

build-eq-for-type-test :-
    build-eq-for-type {{mbtree}} Out TOut,
    coq-say TOut,
    coq-say Out.

%% create-eq
create-eq Type :-
    build-eq-for-type Type Eq TEq, Type = indt GR,
    coq-string-of-gr GR S,
    Name is S ^ "_equal",
    coq-env-add-const Name Eq TEq (const NGR),
    coq-string-of-gr NGR Name.

create-eq-test :- create-eq {{mbtree}}.

%% create-eq-from-name
create-eq-from-name Name :-
    coq-locate Name Type,
    create-eq Type.

test-prod :-
    coq-locate "prod" Prod, Prod = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    coq-say TY,
    coq-say LC,
    coq-say LT.

test-list :-
    coq-locate "list" List, List = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    coq-say TY,
    coq-say LC,
    coq-say LT.

