
accumulate coq-lib.
accumulate lp-lib.

%% arbitrary-term-function
% Necessary because some relation recursively build function
% of arity n, which raise an error with the typer.
kind arbitrary-term-function type -> type.
type atf-const A -> arbitrary-term-function A.
type atf-lam   (term -> arbitrary-term-function A)
                     -> arbitrary-term-function A.

atf-apply (atf-lam F) T (F T).
atf-apply A           _ A.

%% Miscellaneous utilities
type unique list A -> list A -> prop.
unique [X|L] L'     :- mem X L,      unique L L'.
unique [X|L] [X|L'] :- not(mem X L), unique L L'.
unique []    [].

unique-test :-
    unique [1,2,5,8,9,6,3,5,4,7,8,5,1,2,3,6,5,4,7,8,9,6] Out,
    coq-say Out.

same-length [X|L] [X'|L'] :- same-length L L'.
same-length [] [].

inductive-on-type' T T.
inductive-on-type' T T' :- inductive-on-type T T'.

inductive-on-type TP (lam _ T F) :-
    inductive-on-type' TP T; pi x\ inductive-on-type TP (F x).
inductive-on-type TP (prod _ T F) :-
    inductive-on-type' TP T; pi x\ inductive-on-type TP (F x).
inductive-on-type TP (app L) :-
    exists L (inductive-on-type' TP).

%% flatten-app
flatten-app (app [app L|X]) (app L') :-
    flatten-app (app L) (app FL),
    append FL X L'.
flatten-app (app [X]) X.
flatten-app (app L) (app L).

flatten-app-test :-
    coq-locate "nat" Nat,
    flatten-app (app [app [app [Nat], Nat], Nat, app [Nat, Nat], Nat]) Out,
    coq-say Out.

flatten-app-test' :-
    flatten-app (app [{{nat}}]) N,
    coq-say N.

%% eq-signature
eq-signature Type Sign :-
    coq-locate "bool" Bool,
    Sign = (prod _ Type _\ prod _ Type _\ Bool).

eq-signature-test :-
    eq-signature {{nat}} Sign,
    coq-say Sign,
    {{eq_nat}} = const Eq,
    coq-env-const Eq _ TY,
    coq-say TY.

%% eq-test
type eq-function term -> term -> prop.
eq-test Tp Eq EqTp :-
    eq-function Tp Eq, Eq = const GR,
    coq-env-const GR _ EqTp.

eq-test (app [Tp|L]) (app [Eq|L]) Type :-
    eq-function Tp Eq, Eq = const GR,
    coq-env-const GR _ EqTp,
    spec-function {prod-2-lam EqTp} ATF,
    apply-ft L ATF Type.

eq-test-test :-
    coq-say {{prod nat nat}},
    eq-test {{prod nat nat}} Cmp Tp,
    coq-say Cmp,
    coq-say Tp,
    simpl-eq-test Cmp Tp Eqf,
    coq-say Eqf.

spec-function (lam N T B) (atf-const (lam N T B)) :-
    eq-signature TP T.
spec-function (lam N (sort _) B) (atf-lam Out) :-
    pi x\ spec-function (B x) (Out x).
spec-function A           (atf-const A).

spec-function-test :-
    prod-2-lam {{forall A B : Type, (A -> A -> bool) -> (B -> B -> bool) -> mlist A B -> mlist A B -> bool}} Sign,
    spec-function Sign Out,
    coq-say Out.

type eq-proof term -> pair term term -> term -> term -> prop.
% eq-proof type (pr a b) (t : eqf a b = true <-> a = b) (eqf a b).

%% simpl-eq-test
simpl-eq-test' (lam _ Sign Bo) [Eqf|L] :-
    eq-signature Type Sign,
    eq-test Type Eqf' TpEq,
    simpl-eq-test' TpEq EqArgs,
    app-type Eqf' EqArgs Eqf,
    pi x\ simpl-eq-test' (Bo x) L.
simpl-eq-test' X [].
simpl-eq-test In InTp Out :-
    simpl-eq-test' {prod-2-lam InTp} L,
    app-type In L Out.

simpl-eq-test-test :-
    coq-locate "tmp" Tmp, Tmp = const GR,
    coq-env-const GR _ TY,
    eq-signature {{nat}} Sign,
    eq-test {{nat}} {{eq_nat}} Sign
        => simpl-eq-test Tmp TY Tmp',
    coq-say Tmp'.

simpl-eq-test-test' :-
    coq-locate "tmp'" Tmp, Tmp = const GR,
    coq-env-const GR _ TY,
    coq-locate "list" List,
    eq-signature {{nat}} Sign,
    pi l\ eq-signature (app [List|l]) (Type l),
    eq-test {{nat}} {{eq_nat}} Sign
        => (pi l\ eq-test (app [List|l]) (app [{{eq_list}}|l]) (Type l))
        => simpl-eq-test Tmp TY Tmp',
    coq-say Tmp'.

%% build-eq-check
build-eq-check And True [Trm] [Tp] Out :-
    eq-test Tp Eqf' TpEqf,
    simpl-eq-test Eqf' TpEqf Eqf,
    Trm   = pr A B,
    Out   = app [Eqf, A, B].
build-eq-check And True [Trm|Trms] [Tp|Tps] Out :-
    build-eq-check And True Trms Tps End,
    eq-test Tp Eqf' TpEqf,
    simpl-eq-test Eqf' TpEqf Eqf,
    Trm   = pr A B,
    Nterm = app [Eqf, A, B],
    Out   = app [And, Nterm, End].
build-eq-check And True [] [] True.

build-eq-check-test :-
    coq-locate "andb"   And,
    coq-locate "true"   True,
    coq-locate "nat"    Nat,
    coq-locate "O"      Zero,
    coq-locate "S"      Succ,
    coq-locate "eq_nat" Eq, Eq = const GR,
    coq-env-const GR _ TY,
    eq-test Nat Eq TY => build-eq-check And True
                         [pr Zero Zero, pr Zero Zero]
                         [Nat, Nat] Out,
    coq-say Out.

build-eq-check-test' :-
    coq-locate "andb" And,
    coq-locate "true" True,
    coq-locate "nat"  Nat,
    coq-locate "O" Zero,
    coq-locate "eq_nat" Eq, Eq = const GR,
    coq-env-const GR _ TY,
    eq-test Nat Eq TY => build-eq-check And True [] [Nat] Out,
    coq-say Out.

% build-eq-check-proof-proj1 : eqf a b = true -> a = b

proof-xy T X Y Hxy {{proj1 (iff_and lp:Heq) lp:Hxy}} :-
    eq-proof T (pr X Y) Heq _.

% Hqs    : list of terms of type eqf_i x_i y_i = true
% Terms* : list of terms x_i and y_i
% FgEq   : {{fg_equal}}
% Cons*  : the constructors used, partially applied, with their types
% Type   : the type of the partially applied constructor
% Proof  : term of type Cons1 = Cons2
build-eq-check-proof-proj1-eq Cons1 Cons2 (lam N T B) [X|Tx] [Y|Ty] [Hxy|Hqs] FgEq Proof Out :-
    flatten-app (app [Cons1, X]) AC1,
    flatten-app (app [Cons2, Y]) AC2,
    proof-xy T X Y Hxy Eqxy,
    pi t\ build-eq-check-proof-proj1-eq AC1 AC2 (B t) Tx Ty Hqs FgEq
        (app [FgEq, T, (B t), Cons1, Cons2, X, Y, Eqxy, Proof])
        Out.
build-eq-check-proof-proj1-eq Cons1 Cons2 (prod N T B) Tx Ty Hqs FgEq Proof Out :-
    build-eq-check-proof-proj1-eq Cons1 Cons2 (lam N T B) Tx Ty Hqs FgEq Proof Out.
build-eq-check-proof-proj1-eq Cons1 Cons2 _ [] [] [] _ Proof Proof.

build-eq-check-proof-proj1-eq-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "eq_refl" EqRefl', EqRefl = app [EqRefl', hole, hole],
    coq-locate "fg_equal" FgEq,
    (pi eq\ pi heq\ pi x1\ pi y1\ pi x2\ pi y2\ pi x3\ pi y3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) (app [heq, t, a, b]) (app [eq, t, a, b])) =>
        (build-eq-check-proof-proj1-eq MbNode MbNode TY [x1, x2, x3] [y1, y2, y3]
            [app [eq, {{mbtree}}, x1, y1], app [eq, {{mbtree}}, x2, y2], app [eq, {{nat}}, x3, y3]]
            FgEq EqRefl (Out eq heq x1 y1 x2 y2 x3 y3))),
    Bo = (lam _ {{forall (A : Type), A -> A -> bool}} eq\
        lam _ {{forall (A : Type) (a b : A), lp:eq A a b = true}} teq\
        lam _ {{forall (A : Type) (a b : A), eq_ok A (lp:eq A) a b}} heq\
        lam _ {{mbtree}} x1\ lam _ {{mbtree}} y1\ lam _ {{mbtree}} x2\ lam _ {{mbtree}} y2\
        lam _ {{nat}} x3\ lam _ {{nat}} y3\ Out teq heq x1 y1 x2 y2 x3 y3),
    coq-say Bo,
    coq-elaborate Bo Bo' TBo,
    coq-say TBo.

build-eq-check-proof-proj1-and-cond' _ [] [] {{true}}.
build-eq-check-proof-proj1-and-cond' [T|_] [X] [Y] Eq :-
    eq-proof T (pr X Y) _ Eq.
build-eq-check-proof-proj1-and-cond' [T|Ts] [X|Tx] [Y|Ty] Out :-
    eq-proof T (pr X Y) _ Eq,
    build-eq-check-proof-proj1-and-cond' Ts Tx Ty Trm,
    Out = {{andb lp:Eq lp:Trm}}.
build-eq-check-proof-proj1-and-cond Ts Tx Ty {{lp:Out = true}} :-
    build-eq-check-proof-proj1-and-cond' Ts Tx Ty Out.

build-eq-check-proof-proj1 Cons Type [T|_] [X] Tx [Y] Ty Hqs H Out :-
    coq-locate "fg_equal" FgEq,
    coq-locate "eq_refl" EqRefl', EqRefl = app [EqRefl', hole, hole],
    build-eq-check-proof-proj1-eq Cons Cons Type Tx Ty [H|Hqs] FgEq EqRefl Out.
build-eq-check-proof-proj1 Cons Type [T|Ts] [X|Tx'] Tx [Y|Ty'] Ty Hqs H Out :-
    coq-locate "andb_prop" AndbProp,
    eq-proof T (pr X Y) _ Eq,
    (pi x\ build-eq-check-proof-proj1-and-cond Ts Tx' Ty' End),
    pi x\ pi hxy\ pi h'\ build-eq-check-proof-proj1 Cons Type Ts Tx' Tx Ty' Ty [hxy|Hqs] h' (Trm hxy h'),
    Out = match (app [AndbProp, hole, hole, H]) (lam _ {{and _ _}} _\ hole)
        [lam _ {{lp:Eq = true}} hxy\ lam _ End h'\ Trm hxy h'].
build-eq-check-proof-proj1 Cons Type _ [] Tx [] Ty Hqs _ Out :-
    coq-locate "fg_equal" FgEq,
    coq-locate "eq_refl" EqRefl', EqRefl = app [EqRefl', hole, hole],
    build-eq-check-proof-proj1-eq Cons Cons Type Tx Ty Hqs FgEq EqRefl Out.

build-eq-check-proof-proj1-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    constructor-args Args' {prod-2-lam TY}, rev Args' Args,
    (pi h\ pi eq\ pi heq\ pi x1\ pi y1\ pi x2\ pi y2\ pi x3\ pi y3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) (app [heq, t, a, b]) (app [eq, t, a, b])) =>
        build-eq-check-proof-proj1 MbNode TY Args
            [x3, x2, x1] [x1, x2, x3] [y3, y2, y1] [y1, y2, y3] [] h (Out h eq heq x1 y1 x2 y2 x3 y3)),
    coq-say Out.

build-eq-check-proof-proj2-projector-fun N Cons Def TOut C (prod Nm T TB) Out :-
    build-eq-check-proof-proj2-projector-fun N Cons Def TOut C (lam Nm T TB) Out.
build-eq-check-proof-proj2-projector-fun N Cons Def TOut C (lam Nm T TB) (lam Nm T Out) :-
    not(N is 0),
    N1 is N - 1,
    pi x\ build-eq-check-proof-proj2-projector-fun N1 Cons Def TOut C (TB x) (Out x).
build-eq-check-proof-proj2-projector-fun N Cons Def TOut C (lam Nm T TB) (lam Nm T Out) :-
    N is 0,
    N1 is N - 1,
    pi x\ build-eq-check-proof-proj2-projector-fun N1 Cons Def x C (TB x) (Out x).
build-eq-check-proof-proj2-projector-fun N Cons Def TOut C _ TOut :- C = Cons.
build-eq-check-proof-proj2-projector-fun N Cons Def TOut C _ Def  :- not(C = Cons).

build-eq-check-proof-proj2-projector-fun-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    pi d\ pi z\
        build-eq-check-proof-proj2-projector-fun 1 MbNode d z
            MbNode TY (Out d),
    coq-elaborate (lam _ {{mbtree}} d\ Out d) Bo TBo,
    coq-say TBo,
    coq-say Bo.

build-eq-check-proof-proj2-projector' N Cons Def Conss Types Z Matches :-
    map2 Conss Types (build-eq-check-proof-proj2-projector-fun N Cons Def Z) Matches.
build-eq-check-proof-proj2-projector N Cons Def Conss Types Out :-
    pi z\ build-eq-check-proof-proj2-projector' N Cons Def Conss Types z Matches,
    current-type T,
    Out = lam _ hole x\ match x (lam _ T _\ hole)  Matches.

build-eq-check-proof-proj2-projector-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT',
    map LT' prod-2-lam LT,
    pi d\ build-eq-check-proof-proj2-projector 1 MbNode d LC LT (Out d),
    coq-say Out.

build-eq-check-proof-proj2 N Cons Type (prod Nm T Bo) Conss Types Tx Ty Ds H Proof Out :-
    build-eq-check-proof-proj2 N Cons Type (lam Nm T Bo) Conss Types Tx Ty Ds H Proof Out.
build-eq-check-proof-proj2 N Cons Type (lam _ T Bo) Conss Types [X|Tx] [Y|Ty] [D|Ds] H Proof Out :-
    N is 0,
    N1 is N + 1,
    eq-proof T (pr X Y) Heq _,
    build-eq-check-proof-proj2-projector N Cons D Conss Types F,
    pi x\ build-eq-check-proof-proj2 N1 Cons Type (Bo x) Conss Types Tx Ty Ds H
        {{(proj2 (iff_and lp:Heq) (f_equal lp:F lp:H))}} Out.
build-eq-check-proof-proj2 N Cons Type (lam _ T Bo) Conss Types [X|Tx] [Y|Ty] [D|Ds] H Proof Out :-
    N1 is N + 1,
    eq-proof T (pr X Y) Heq _,
    build-eq-check-proof-proj2-projector N Cons D Conss Types F,
    pi x\ build-eq-check-proof-proj2 N1 Cons Type (Bo x) Conss Types Tx Ty Ds H
        {{andb_true_intro (conj (proj2 (iff_and lp:Heq) (f_equal lp:F lp:H)) lp:Proof)}} Out.
build-eq-check-proof-proj2 _ _ _ _ _ _ [] [] [] _ Proof Proof.

build-eq-check-proof-proj2-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT,
    (pi h\ pi eq\ pi heq\ pi x1\ pi y1\ pi d1\ pi x2\ pi y2\ pi d2\ pi x3\ pi y3\ pi d3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) (app [heq, t, a, b]) (app [eq, t, a, b])) =>
        (current-type MbTree =>
        build-eq-check-proof-proj2 0 MbNode TY TY LC LT [x1, x2, x3] [y1, y2, y3]
            [d1, d2, d3] h {{eq_refl}} (Out h eq heq x1 y1 d1 x2 y2 d2 x3 y3 d3))),
    coq-say Out.

build-eq-check-proof Cons Type Conss Types Tx Ty Out :-
    constructor-args Args' Type, rev Args' Args,
    rev Tx Tx', rev Ty Ty',
    build-eq-check-proof-proj1-and-cond Args Tx' Ty' Prj1Arg,
    (pi h\ build-eq-check-proof-proj1 Cons Type Args Tx' Tx Ty' Ty [] h (Prj1 h)),
    (pi h\ build-eq-check-proof-proj2 0 Cons Type Type Conss Types Tx Ty Tx h {{eq_refl}} (Prj2 h)),
    current-type Tp,
    rev Tx RTx, rev Ty RTy,
    coq-locate "eq" Eq,
    Out = app [{{conj}}, hole, hole
              %, {{lp:"app [Cmp, app[Cons|Tx], app[Cons|Ty]]" = true -> lp:"app [Cons|Tx]" = lp:"app [Cons|Ty]"}}
              %, hole
              , (lam _ Prj1Arg h\ Prj1 h)
              , (lam _ {{lp:"app [Cons|Tx]" = lp:"app [Cons|Ty]"}} h\ Prj2 h)].

type current-type term -> prop.
build-eq-check-proof-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT,
    (pi eqnat\ pi eqprod\ pi eqmb\ pi hnat\ pi hprod\ pi hmbtree\
     pi x1\ pi y1\ pi x2\ pi y2\ pi x3\ pi y3\
        (pi a\ pi b\ eq-proof {{nat}} (pr a b) (app [hnat, a, b]) (app [eqnat, a, b])) =>
        ((pi a\ pi b\ eq-proof (app [{{prod}}, {{nat}}, {{nat}}]) (pr a b) (app [hprod,a,b]) (app [eqprod, a, b])) =>
        ((pi a\ pi b\ eq-proof MbTree (pr a b) (app [hmbtree,a,b]) (app [eqmb, a, b])) =>
        (current-type MbTree =>
        build-eq-check-proof MbNode TY LC LT [x1, x2, x3] [y1, y2, y3] (Out eqnat eqprod eqmb
                                                                            hnat hprod hmbtree 
                                                                            x1 y1 x2 y2 x3 y3))))),
    Bo =  (lam _ {{nat -> nat -> bool}} eqnat\ lam _ {{nat*nat -> nat*nat -> bool}} eqprod\
        lam _ {{mbtree -> mbtree -> bool}} eqmb\ lam _ {{forall (a b : nat), eq_ok nat lp:eqnat a b}} hnat\
        lam _ {{forall (a b : nat*nat), eq_ok (nat * nat) lp:eqprod a b}} hprod\
        lam _ {{forall (a b : mbtree), eq_ok mbtree lp:eqmb a b}} hmb\
        lam _ MbTree x1\ lam _ MbTree y1\ lam _ MbTree x2\ lam _ MbTree y2\ lam _ {{nat}} x3\ lam _ {{nat}} y3\
        Out eqnat eqprod eqmb hnat hprod hmb x1 y1 x2 y2 x3 y3),
     coq-elaborate Bo Bo' TBo,
     coq-say TBo.

%% constructor-args
constructor-args L (prod N T F) :-
    constructor-args L (lam N T F).
constructor-args [X|LS] (lam _ T F) :-
    X = T,
    pi x\ constructor-args LS (F x).
constructor-args [] T :-
    not(T = (lam _ _ _)),
    not(T = (prod _ _ _)).

constructor-args-test :-
    coq-locate "S" Succ, Succ = indc GR,
    coq-env-indc GR _ _ TY,
    constructor-args L TY,
    coq-say TY,
    coq-say L.

%% build-constructor-match
build-constructor-match TypeCons Terms TC Term :-
    TypeCons = pr Cons LCons,
    TC = pr C LC,
    C = Cons,
    eq-lambda Terms [] {prod-2-lam LC} Term [].
build-constructor-match TypeCons Terms TC Term :-
    TypeCons = pr Cons LCons,
    TC = pr C LC,
    not (C = Cons),
    false-lambda {prod-2-lam LC} Term.

eq-lambda Terms Types (lam N X B) (lam N X C) L :-
    pi x\ eq-lambda Terms [X|Types] (B x) (C x) [x|L].
eq-lambda Terms Types T Out L :-
    not (T = lam _ _ _),
    zip Terms L NTerms,
    build-eq-check {{andb}} {{true}} NTerms Types Out.

false-lambda (lam N X B) (lam N X C) :-
    pi x\ false-lambda (B x) (C x).
false-lambda _ {{false}}.

build-constructor-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    coq-locate "O" Zero,
    coq-locate "S" Succ,
    Succ = indc SGR, coq-env-indc SGR _ _ STY,
    pi x\ eq-test Nat EqNat TY => build-constructor-match (pr Succ STY) [x]
                                                          (pr Succ STY) (Out x),
    coq-say Out.

false-lambda-proof-proj1 Type Cx Tx Cy Ty (lam _ hole Out) :-
    pi h\ (False h) = app [{{eq_ind}}, hole, {{false}}, 
                           lam _ {{bool}} (e\ match e (lam _ {{bool}} _\ hole) [{{False}},{{True}}]),
                           {{I}}, {{true}}, h],
    pi h\ (Out h) = app [{{False_ind}}, {{lp:"app [Cx|Tx]" = lp:"app [Cy|Ty]"}}, (False h)].

false-lambda-proof-proj2-match-term False True Cons C (prod N T Bo) Out :-
    false-lambda-proof-proj2-match-term False True Cons C (lam N T Bo) Out.
false-lambda-proof-proj2-match-term False True Cons C (lam N T Bo) (lam N T Out) :-
    pi x\ false-lambda-proof-proj2-match-term False True Cons C (Bo x) (Out x).
false-lambda-proof-proj2-match-term False True Cons C _ False :-
    C = Cons.
false-lambda-proof-proj2-match-term False True Cons C _ True :-
    not(C = Cons).

false-lambda-proof-proj2 Type Cx Cy Conss Types Tx Ty (lam _ hole Out) :-
    map2 Conss Types (false-lambda-proof-proj2-match-term {{False}} {{True}} Cy) MTerms,
    Match = lam _ Type (e\ match e (lam _ Type _\ hole) MTerms),
    (pi h\ (False h) = app [{{eq_ind}}, hole, app [Cx|Tx], Match, {{I}}, app [Cy|Ty], h]),
    (pi h\ (Out h) = app [{{False_ind}}, {{false = true}}, False h]).

false-lambda-proof Type Cx Tx Cy Ty Conss Types Out :-
    false-lambda-proof-proj1 Type Cx Tx Cy Ty Prj1,
    false-lambda-proof-proj2 Type Cx Cy Conss Types Tx Ty Prj2,
    Out = app [{{conj}}, hole, hole, Prj1, Prj2].

false-lambda-proof-test :-
    coq-locate "mbnode" MbNode,
    coq-locate "mbtree" MbTree, MbTree = indt GR,
    coq-env-indt GR tt _ _ _ LC LT,
    coq-locate "mbleaf" MbLeaf,
    pi x1\ pi x2\ pi x3\ pi y\
        false-lambda-proof MbTree MbNode [x1, x2, x3] MbLeaf [y] LC LT (Out x1 x2 x3 y),
    coq-say Out.

build-constructor-match-proof Type Cx Tx Conss Types L C (pr (prod N T Bo) TC) Out :-
    build-constructor-match-proof Type Cx Tx Conss Types L C (pr (lam N T Bo) TC) Out.
build-constructor-match-proof Type Cx Tx Conss Types L C (pr (lam N T Bo) TC) (lam N T Out) :-
    pi x\ build-constructor-match-proof Type Cx Tx Conss Types [x|L] C (pr (Bo x) TC) (Out x).
build-constructor-match-proof Type Cx Tx Conss Types L C _ Out :-
    not(Cx = C),
    rev L Ty,
    false-lambda-proof Type Cx Tx C Ty Conss Types Out.
build-constructor-match-proof Type Cx Tx Conss Types L C (pr _ TC) Out :-
    Cx = C,
    rev L Ty,
    current-type Type => build-eq-check-proof C TC Conss Types Tx Ty Out.

build-constructor-match-proof-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT,
    coq-locate "mbleaf" MbLeaf, MbLeaf = indc GR'',
    coq-env-indc GR'' _ _ TY'',
    pi heq\ pi eq\ pi x1\ pi x2\ pi x3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) heq eq) =>
        build-constructor-match-proof MbTree MbNode [x1, x2, x3]
            LC LT [] MbNode (pr TY TY) (Out heq eq x1 x2 x3),
    coq-say Out,
    pi x1\ pi x2\ pi x3\
        build-constructor-match-proof MbTree MbNode [x1, x2, x3]
            LC LT [] MbLeaf (pr TY'' TY'') (Out' x1 x2 x3),
    coq-say Out'.

%% sub-match
sub-match Type TypeConss TypeCons T Terms Out :-
    map TypeConss (build-constructor-match TypeCons Terms) MTerms,
    coq-locate "bool"  Bool,
    Out = match T (lam _ Type _ \ Bool) MTerms.

sub-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    coq-locate "O" Zero,
    Zero = indc ZGR, coq-env-indc ZGR _ _ ZTY,
    coq-locate "S" Succ,
    Succ = indc SGR, coq-env-indc SGR _ _ STY,
    pi x\ pi y\ eq-test Nat EqNat TY => sub-match Nat [pr Zero ZTY, pr Succ STY]
                                                  (pr Succ STY) x [y] (Out x y),
    coq-say Out.

sub-match-proof Type Cmp Cx Tx Conss Types T (match T TP MTerms) :-
    zip Types Types Types',
    TP = lam _ Type (x\ {{lp:"app [Cmp, app [Cx|Tx], x]" = true <-> lp:"app [Cx|Tx]" = lp:x}}),
    map2 Conss Types' (build-constructor-match-proof Type Cx Tx Conss Types []) MTerms.

sub-match-proof-test :-
    coq-locate "mbtree" MbTree, MbTree = indt GR,
    coq-env-indt GR tt _ _ _ LC LT,
    coq-locate "mbnode" MbNode,
    coq-locate "mbleaf" MbLeaf,
    pi cmp\ pi heq\ pi eq\ pi t\ pi x1\ pi x2\ pi x3\
        (pi t\ pi a\ pi b\ eq-proof t (pr a b) heq eq) =>
        sub-match-proof MbTree cmp MbNode [x1, x2, x3]
            LC LT t (Out heq eq t x1 x2 x3),
    coq-say Out.

%% build-match-for-constructor
build-match-for-constructor Type      % The global type
                            T         % The second term to compare
                            TypeConss % List of the constructors
                            TypeCons  % The type of the constructor
                            Out       % The result (ie a function for a
                                      % mach on this constructor)
                            :-
    TypeCons = pr Cons CType,
    sub-match-build Type TypeConss TypeCons T [] {prod-2-lam CType} Out.

sub-match-build Type Conss TypeCons T L (lam N X B) (lam N X C) :-
    pi x\ sub-match-build Type Conss TypeCons T [x|L] (B x) (C x).
sub-match-build Type Conss TypeCons T L _ Out :-
    sub-match Type Conss TypeCons T L Out.

build-match-for-constructor-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GREq, coq-env-const GREq _ TEq,
    coq-locate "nat" Nat, Nat = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    coq-locate "S" Succ, Succ = indc GR',
    coq-env-indc GR' _ _ TYSucc,
    zip LC LT TypeConss,
    pi t\ eq-test Nat EqNat TEq => build-match-for-constructor Nat t TypeConss
                                   (pr Succ TYSucc) (Out t),
    coq-say Out.

build-match-for-constructor-proof Type Cmp Prop Conss Types Lx C (prod N T Bo) Out :-
    build-match-for-constructor-proof Type Cmp Prop Conss Types Lx C (lam N T Bo) Out.
build-match-for-constructor-proof Type Cmp Prop Conss Types Lx C (lam N Type Bo) (lam N Type Out) :-
    pi x\ pi h\ (pi b\ eq-proof Type (pr x b) (app [h, b]) (app [Cmp, x, b])) => (
        build-match-for-constructor-proof Type Cmp Prop Conss Types [x|Lx] C (Bo x) (Out' x h)),
    Out = x\ lam _ (prod _ Type b\ Prop x b) (Out' x).
build-match-for-constructor-proof Type Cmp Prop Conss Types Lx C (lam N T Bo) (lam N T Out) :-
    pi x\ build-match-for-constructor-proof Type Cmp Prop Conss Types [x|Lx] C (Bo x) (Out x).
build-match-for-constructor-proof Type Cmp Prop Conss Types Lx' C _ (lam _ Type Out) :-
    rev Lx' Lx,
    pi x\ sub-match-proof Type Cmp C Lx Conss Types x (Out x).

build-match-for-constructor-proof-test :-
    coq-locate "mbnode" MbNode, MbNode = indc GR,
    coq-env-indc GR _ _ TY,
    coq-locate "mbtree" MbTree, MbTree = indt GR',
    coq-env-indt GR' tt _ _ _ LC LT,
    coq-locate "mbtree_equal" EqMb,
    (pi eqnat\ pi eqnn\ pi heq\ pi hnn\ pi eqnat\ pi eqnn\
        (pi a\ pi b\ eq-proof {{nat}} (pr a b) (app [heq, a, b]) (app [eqnat, a, b])) =>
        ((pi a\ pi b\ eq-proof (app [{{prod}}, {{nat}}, {{nat}}]) (pr a b) (app [hnn, a, b]) (app [eqnn, a, b])) =>
        build-match-for-constructor-proof MbTree (app [EqMb, eqnat, eqnn]) (a\ b\ {{eq_ok mbtree lp:"app [EqMb, eqnat, eqnn]" lp:a lp:b}})
            LC LT [] MbNode TY (Out eqnat eqnn heq hnn))),
    Bo = (lam _ {{nat -> nat -> bool}} eqnat\
        lam _ {{nat*nat -> nat*nat -> bool}} eqnn\ lam _ {{forall (a b : nat), eq_ok nat lp:eqnat a b}} hnat\
        lam _ {{forall (a b : nat*nat), eq_ok (nat*nat) lp:eqnn a b}} hnn\
        Out eqnat eqnn hnat hnn),
    coq-elaborate Bo Bo' TBo,
    coq-say TBo.

%% app-type
app-type Type [] Type.
app-type Type L (app [Type|L]).

%% build-eq-match
build-eq-match Type L T1 T2 Out :-
    Type = indt GR,
    coq-env-indt GR tt _ _ TY LC' LT',
    map LC' (gen-app L) LC,
    map LT' (tp-apply L) LT,
    zip LC LT TypeConss,
    app-type Type L Type',
    map TypeConss (build-match-for-constructor Type' T2 TypeConss) MTerms,
    coq-locate "bool"  Bool,
    Out = match T1 (lam _ Type' _ \ Bool) MTerms.

tp-apply' [X|L] (lam _ _ B) Out :-
    tp-apply' L (B X) Out.
tp-apply' [] T T.
tp-apply L B Out :-
    tp-apply' L {prod-2-lam B} Out.

gen-app [] C C.
gen-app L  C (app [C|L]).

build-eq-match-test :-
    coq-locate "eq_nat" EqNat,
    EqNat = const GR, coq-env-const GR _ TY,
    coq-locate "nat" Nat,
    pi x\ pi y\ eq-test Nat EqNat TY => build-eq-match Nat [] x y
                                                      (Out x y),
    coq-say Out.

build-eq-match-proof-prop Type Prop Params Out :-
    Out = lam "a" (app [Type|Params]) a\ prod "b" (app [Type|Params]) b\ Prop Params a b.

build-eq-match-proof-prop-test :-
    coq-locate "mbtree" MbTree, MbTree = indt GR,
    coq-env-indt GR tt _ _ TY _ _,
    pi x\ build-eq-match-proof-prop MbTree (l\ a\ b\ app [{{eq_ok}}, app [MbTree|l], x, a, b]) [] (Out x),
    coq-say Out.

build-eq-match-proof-apply-params-conss Params Cons Out :-
    app-type Cons Params Out.
build-eq-match-proof-apply-params-types L (prod N T Bo) Out :-
    build-eq-match-proof-apply-params-types L (lam N T Bo) Out.
build-eq-match-proof-apply-params-types [P|Params] (lam _ _ Bo) Out :-
    build-eq-match-proof-apply-params-types Params (Bo P) Out.
build-eq-match-proof-apply-params-types [] Tp Tp.

% Using the induction
build-eq-match-proof Type Cmp Params Prop TY Conss Types A (app Out) :-
    Type = indt GR, coq-string-of-gr GR GRS,
    IndName is GRS ^ "_ind", coq-locate IndName Ind,
    build-eq-match-proof-prop Type Prop Params P,
    map Conss (build-eq-match-proof-apply-params-conss Params) Conss',
    map Types (build-eq-match-proof-apply-params-types Params) Types',
    build-eq-match-proof-apply-params-conss Params Type Type',
    map2 Conss' Types' (build-match-for-constructor-proof Type' Cmp (Prop Params) Conss' Types' []) Steps,
    flatten [[Ind], Params, [P], Steps, [A]] Out.

build-eq-match-proof-test :-
    coq-locate "mlist" Mlist, Mlist = indt GR,
    coq-locate "mlist_equal" Cmp,
    coq-env-indt GR tt _ _ TY LC LT,
    (pi A\ pi B\ pi eqA\ pi eqB\ pi hA\ pi hB\ pi a\
        (pi a\ pi b\  eq-proof A (pr a b) (app [hA, a, b]) (app [eqA, a, b])) =>
        ((pi a\ pi b\ eq-proof B (pr a b) (app [hB, a, b]) (app [eqB, a, b])) =>
        build-eq-match-proof Mlist 
            (app [Cmp, A, B, eqA, eqB])
            [A, B]
            (l\ a\ b\ app [{{eq_ok}}, app [Mlist|l], app [app [Cmp|l], eqA, eqB], a, b])
            TY LC LT a
            (Out A B eqA eqB hA hB a))),
    Bo = (lam "A" {{Type}} A\ lam "B" {{Type}} B\
        lam "eqA" {{lp:A -> lp:A -> bool}} eqA\ lam "eqB" {{lp:B -> lp:B -> bool}} eqB\
        lam "hA" {{forall (a b : lp:A), eq_ok lp:A lp:eqA a b}} hA\
        lam "hB" {{forall (a b : lp:B), eq_ok lp:B lp:eqB a b}} hB\
        lam _ (app [Mlist, A, B]) a\ Out A B eqA eqB hA hB a),
    coq-say Bo,
    coq-elaborate Bo Bo' TBo,
    coq-env-add-const "mbtree_equal_ok" Bo' TBo _.

%% build-eq-body
build-eq-body Type L Out :-
    pi t1\ pi t2\ build-eq-match Type L t1 t2 (Bo t1 t2),
    app-type Type L Type',
    Out = lam _ Type' t1\ lam _ Type' t2\ Bo t1 t2.

build-eq-body-test :-
    eq-signature {{nat}} Sign,
    eq-test {{nat}} {{eq_nat}} Sign
        => build-eq-body {{nat}} [] Out,
    coq-say Out.

%% get-types-for-construction
get-types-for-construction' [X|L] (lam _ T B) Out :-
    get-types-for-construction' L (B X) Out.
get-types-for-construction' [] Bo Out :-
    constructor-args Out Bo.
get-types-for-construction L Bo Out :-
    get-types-for-construction' L {prod-2-lam Bo} Out.

%% same-type
same-type T T.
same-type T (app [T|_]).

same-type-test :-
    coq-locate "nat" Nat,
    coq-locate "list" List,
    same-type Nat Nat,
    not(same-type Nat List),
    same-type List (app [List, Nat]),
    not(same-type Nat (app [List, Nat])),
    coq-say "Success !".

%% bind-types
bind-types Ndec Type LT L (lam N T B)
        (prod N T TBo) (atf-lam FT) (atf-lam OTypes) :-
    pi x\ bind-types N1 Type LT [x|L] (B x) (TBo x) (FT x) (OTypes x),
    Ndec is N1 + 1.
bind-types Ndec Type LT L' _ TOut (atf-const TOut) (atf-const OTypes) :-
    rev L' L,
    map LT (get-types-for-construction L) Args,
    flatten Args Args', unique Args' Args'',
    filter (x\ not(eq-test x _ _)) Args'' Args''',
    filter (x\ not(same-type Type x)) Args''' OTypes,
    get-type Type L OTypes TOut,
    length OTypes Ndec.

bind-types-test :-
    coq-locate "mlist" Mlist, Mlist = indt GR,
    coq-env-indt GR tt _ _ TY' LC LT,
    prod-2-lam TY' TY,
    bind-types Ndec Mlist LT [] TY Tout Fout OTypes,
    coq-say Ndec,
    coq-say Tout,
    coq-say Fout,
    coq-say OTypes.

%% get-type
get-type Type Args [T|Tps] (prod _ Sign TBo) :-
    eq-signature T Sign,
    pi f\ get-type Type Args Tps (TBo f).
get-type Type [] [] TOut :-
    eq-signature Type TOut.
get-type Type Args [] TOut :-
    eq-signature (app [Type|Args]) TOut.

%% apply-ft
apply-ft' [X|L] FT TOut :-
    atf-apply FT X FT',
    apply-ft' L FT' TOut.
apply-ft' [] FT FT.
apply-ft  L FT Out :-
    apply-ft' L FT ATF,
    ATF = atf-const Out.

type nrel (list term) -> term -> prop.
apply-ft-test :-
    L = [{{mbtree}}, {{nat}}],
    (pi l tp\ (
       nrel l tp :- apply-ft l
             (atf-lam x0\
               atf-lam x1\
                atf-const
                 (prod _ x0 a\ prod _ x1 b\ {{nat -> nat -> bool}}))
             tp))
              => (nrel L X, coq-say X).

%% build-eq-for-type
build-eq-for-type Type Out TOut :-
    Type = indt GR,
    coq-env-indt GR tt _ _ TY' LC LT,
    prod-2-lam TY' TY,
    bind-types Ndec Type LT [] TY TOut FOut OTypes,
    % Only one of the following to additions to eq-test will be used,
    % depending on whether Type is dependant or not
    pi f\ eq-test Type f TOut
     => ((pi l tp\
           eq-test (app [Type|l]) (app [f|l]) tp :-
               apply-ft l FOut tp
         )
      => get-eqs Type TY [] OTypes (Bo f)),
    Out = fix _ Ndec TOut Bo.

get-eqs Type (lam N T B) L (atf-lam F)         (lam N T Bo) :-
    pi x\ get-eqs Type (B x) [x|L] (F x) (Bo x).
get-eqs Type X           L (atf-const [T|Tps]) (lam _ Sign Bo) :-
    eq-signature T Sign,
    pi f\ eq-test T f Sign => get-eqs Type X L (atf-const Tps) (Bo f).
get-eqs Type _           L (atf-const [])      Out :-
    build-eq-body Type {rev L} Out.

build-eq-for-type-test :-
    build-eq-for-type {{mlist}} Out TOut,
    coq-say TOut,
    coq-say Out.

% build-eq-for-type-proof Type Cmp TY Prop TY Params Deqs Leqs Conss Types Out.
build-eq-for-type-proof Type Cmp TY Prop (prod N T Bo) Params Conss Types (lam N T Out) :-
    pi x\ build-eq-for-type-proof Type Cmp TY Prop (Bo x) [x|Params] Conss Types (Out x).
build-eq-for-type-proof Type Cmp TY Prop (lam N T Bo) Params Conss Types (lam N T Out) :-
    pi x\ build-eq-for-type-proof Type Cmp TY Prop (Bo x) [x|Params] Conss Types (Out x).
build-eq-for-type-proof Type Cmp TY Prop _ Params' Conss Types Out :-
    rev Params' Params,
    map Types (get-types-for-construction Params) Args,
    flatten Args Args', unique Args' Args'',
    filter (x\ not(eq-test x _ _)) Args'' Args''',
    filter (x\ not(same-type Type x)) Args''' Deqs,
    build-eq-for-type-proof-middle Type (app [Cmp|Params]) TY Prop Params Deqs [] Conss Types Out.

build-eq-for-type-proof-middle Type Cmp TY Prop Params [T|Deqs] Leqs Conss Types (lam Name DT Out) :-
    eq-signature T DT,
    get-name-of-type T Name', Name is "eq" ^ Name',
    pi eq\ build-eq-for-type-proof-middle Type (app [Cmp,eq]) TY Prop Params Deqs [pr eq T|Leqs] Conss Types (Out eq).
build-eq-for-type-proof-middle Type Cmp TY Prop Params [] Leqs' Conss Types Out :-
    rev Leqs' Leqs,
    map Leqs fst Eqs,
    build-eq-for-type-proof-end Type Cmp TY (Prop Eqs) Params Leqs Conss Types Out.

build-eq-for-type-proof-end Type Cmp TY Prop Params [pr Eq T|Leqs] Conss Types (lam Name TH Out) :-
    get-name-of-type T Name', Name is "Heq" ^ Name',
    TH = prod "a" T (a\ prod "b" T (b\ app [{{eq_ok}}, T, Eq, a, b])),
    pi h\ (pi a\ pi b\ eq-proof T (pr a b) (app [h, a, b]) (app [Eq, a, b])) =>
        build-eq-for-type-proof-end Type Cmp TY Prop Params Leqs Conss Types (Out h).
build-eq-for-type-proof-end Type Cmp TY Prop Params [] Conss Types Out :-
    app-type Type Params Type',
    pi a\ build-eq-match-proof Type Cmp Params Prop TY Conss Types a (Out' a),
    Out = lam "a" Type' a\ Out' a.

get-name-of-type (indt GR) Name :-
    coq-string-of-gr GR Name.
get-name-of-type _ "_".

build-eq-for-type-proof-test :-
    coq-locate "mbtree" MbTree, MbTree = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    coq-locate "mbtree_equal" Cmp,
    build-eq-for-type-proof MbTree Cmp TY (eqs\ l\ a\ b\ app [{{eq_ok}}, MbTree, app [Cmp|eqs], a, b]) TY [] LC LT Bo,
    coq-say Bo,
    coq-elaborate Bo Bo' TBo,
    coq-env-add-const "mbtree_equal_ok" Bo' TBo _.

%% create-eq
create-eq Type :-
    build-eq-for-type Type Eq TEq, Type = indt GR,
    coq-string-of-gr GR S,
    Name is S ^ "_equal",
    coq-env-add-const Name Eq TEq (const NGR),
    coq-string-of-gr NGR Name.

create-eq-test :- create-eq {{mbtree}}.

create-eq-proof Type :-
    Type = indt GR,
    coq-env-indt GR tt _ _ TY LC LT,
    coq-string-of-gr GR S,
    CmpName is S ^ "_equal", coq-locate CmpName Cmp,
    build-eq-for-type-proof Type Cmp TY
        (eqs\ l\ a\ b\ app [{{eq_ok}}, app [Type|l], app [app [Cmp|l]|eqs], a, b])
        TY [] LC LT Out,
    coq-say Out,
    coq-elaborate Out Out' TOut,
    Name is S ^ "_equal_ok",
    coq-env-add-const Name Out' TOut _.

create-eq-proof-test :-
    create-eq-proof {{mbtree}}.

%% create-eq-from-name
create-eq-from-name Name :-
    coq-locate Name Type,
    create-eq Type.

%% create-eq-with-proof
create-eq-with-proof Name :-
    coq-locate Name Type,
    create-eq Type, !,
    create-eq-proof Type.

