
pred last i:list A, o:list A, o:A.
last [X] [] X :- !.
last [X|XS] [X|YS] Last :- last XS YS Last.

pred easy i:term, o:term.

pred refines o:term, i:term, o:term, o:term. % rel, t1, t2, proof
% @log(refines _ _ _ _).
refines R T1 T2 P :- easy T1 (const GR), !,
  P = const GR,
  % $coq-say "found P=" P,
  coq-env-typeof-gr GR CoqTyGR,
  % $coq-say "CoqTyGR =" CoqTyGR,
  % $coq-say (app[{{@refines}},_,_,R,_,T2]),
  CoqTyGR = app [{{@refines}},_,_,R,_,T2].
  % $coq-say "R =" R.
%  of P PTY _,
%  unify-eq PTY {of {{refines lp:R _ lp:T2}} _}.
refines R (app [F | Args]) T2 P :-
  last Args LeftArgs LastArg,
  mk-app F LeftArgs G,
  refines (app [{{@hrespectful}}, _, _, _ ,_ , RArg, R]) G RG PG, !,
  refines RArg LastArg RLastArg PLastArg,
  P = {{refines_apply lp:PLastArg lp:PG}},
  mk-app RG [RLastArg] T2.


solve [goal Ev (app[{{@refines}}, _Src, _Tgt, Rel, T1, T2])  _] :-
  $coq-say "we refine " T1,
  if (time (refines Rel T1 X P) Time)
    (% $coq-say "we obtain " X " and proof " P,
     coq-elaborate X T2 _,
     % coq-evd-print,
     % coq-say "and the proof",
     coq-elaborate P Ev _,
     coq-say Time)
    ($coq-error "can't refine" {pp T1}).


% We disable coq-refiner
:before "coq-declare-evar"
  coq-declare-evar Ev Ty :- !, coq-evar Ev Ty.

:before "coq-declare-goal"
  coq-declare-goal Ev Ty G :- !, coq-evar Ev Ty, G Ev Ty. 

% vim:set ft=lprolog spelllang=:

