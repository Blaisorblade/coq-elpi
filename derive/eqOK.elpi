/* Correctness of comparison functions                                       */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

%FIXME duplicate

% Relates a type with a predicate to state the induction hyp on it
param1-db T (lam `x` T _\ {{ True }}).

% Relates an induction predicates and its proof
param1P-db (lam N T _\ {{ True }}) (lam N T _\ {{ I }}).


derive-induction-use-db-pred T P :-
  spy(param1-db T Q), % FIXME use real unit propagation
  if (Q = (lam _ _ _\ {{ True }})) (P = none) (P = some Q).

derive-eqOK-rty A _ V _ R :-
  rev V [X|_], R = A X.

derive-eqOK-rty2 P _ V _ R :-
  rev V [X|_], subst-prod [X] P R.

sorry {{ match daemon in False with end }}.

derive-eqOK-search {{ @reflect (@eq lp:T lp:X lp:X) lp:_ }}
                   {{ @ReflectT (@eq lp:T lp:X lp:X) (@eq_refl lp:T lp:X) }}.
derive-eqOK-search {{ @reflect (@eq lp:T lp:X lp:Y) lp:_ }} R :-
  param1P-db {{ @axiom lp:T lp:_ lp:X }} F,
  mk-app F [Y] R.

derive-eqOK-disprove {{ @reflect lp:P lp:_ }} K1 V1 VT1 K2 V2 VT2 {{ @ReflectF lp:P lp:EF }} :-
 EF = (lam `abs` P abs\ E abs),
 pi abs\ discriminate abs P {{ False }} (E abs).

derive-eqOK-prove P K1 [] _ K2 [] _ E :- derive-eqOK-search P E.

derive-eqOK-prove {{ @reflect lp:_ lp:Pr }} K1 [X] [T] K2 [Y] [_] 
                  {{ @reflect_eqf_last lp:T _ _ lp:X lp:Y lp:Inj lp:Pr lp:E }} :-
 sorry Inj,
 spy(derive-eqOK-search {{ @reflect (@eq lp:T lp:X lp:Y) lp:Pr }} E).

derive-eqOK-body P K1 V1 VT1 K2 _ V2 VT2 R :- 
  subst-prod [{mk-app K2 V2}] P Goal, 
  if (K1 = K2)
     (spy(derive-eqOK-prove    Goal K1 V1 VT1 K2 V2 VT2 R))
     (spy(derive-eqOK-disprove Goal K1 V1 VT1 K2 V2 VT2 R)),
  !.

derive-eqOK-match Ity Pr K V VT (lam `y` Ity R) :-
  whd Pr [{mk-app K V}] P [],
  pi y\ build-match y Ity 
    (derive-eqOK-rty2 P) 
    (derive-eqOK-body P K V VT)
    (R y).

% called on each inudction branch
derive-eqOK-branch Ity P Acc AccT K (prod Name S T) (lam Name S R) :- !,
  if (derive-induction-use-db-pred S (some Q))
    (R = (x\ lam `h` {mk-app Q [x]} hx\ R1 x hx),
     pi x hx\ sigma Qx\ mk-app Q [x] Qx,
        param1P-db Qx hx => 
        derive-eqOK-branch Ity P [x|Acc] [S|AccT] K (T x) (R1 x hx))
    (pi x\ derive-eqOK-branch Ity P [x|Acc] [S|AccT] K (T x) (R x)).
derive-eqOK-branch Ity P Acc AccT K _ R :-
  derive-eqOK-match Ity P K {rev Acc} {rev AccT} R.

derive-eqOK-params N K KT (prod Name S T) Ity F IP R :- N > 0, !, M is N - 1,
  R = (lam Name S a\ lam `f` {{ lp:S -> lp:S -> bool }} f\ Bo a f),
  pi a f\
    derive-eqOK-params M K KT (T a) 
      {mk-app Ity [a]} {mk-app F [a,f]} {mk-app IP [a]} (Bo a f).

derive-eqOK-params 0 K KT (sort _) Ity F IP (lam `x` Ity R) :- !,
  derive-induction-use-db-pred Ity none,
  coq-say IP,
  P = {{ axiom lp:Ity lp:F }},
  param1-db Ity P => % FIXME: push arity
    map2 K KT (derive-eqOK-branch Ity P [] []) Kp,
  pi x\ mk-app IP {append [P|Kp] [x]} (R x). 

derive-eqOK-params 0 _ _ (prod _ _ _) _ _ _ _ :-
  assert false "not implemented".

derive-eqOK GR Cmp :- 
  coq-env-indt GR _ Lno _ Arity K KT,
  induction-db (indt GR) IndP,
  derive-eqOK-params Lno K KT Arity (indt GR) (const Cmp) IndP CmpOK,
  coq-say CmpOK,
  coq-elaborate CmpOK CmpOK1 CmpTy,
  coq-env-add-const {calc ({coq-gr->id Cmp} ^ "OK")} CmpOK1 CmpTy @opaque! _.

