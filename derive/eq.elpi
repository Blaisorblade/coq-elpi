/* Boolean comparison functions                                             */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

:name "derive-eq-body:begin"
derive-eq-body K []     K []     _      {{ true%bool }}.
derive-eq-body K [X]    K [Y]    [T]    (app[F,X,Y]) :- !, eq-db T F.
derive-eq-body K [X|XS] K [Y|YS] [T|TS] {{ (lp:R && lp:RS)%bool }} :-
  eq-db T F, R = app[F,X,Y], derive-eq-body K XS K YS TS RS.
derive-eq-body _ _      _ _      _      {{ false%bool }}.

derive-eq-ty2 _ _ _ {{bool}}.
derive-eq-bo2 Kno1 Vars1 Kno2 _ Vars2 VarsTy R :- !,
  derive-eq-body Kno1 Vars1 Kno2 Vars2 VarsTy R.

derive-eq-ty1 _ _ Tys R :- rev Tys [T|_], R = {{lp:T -> bool}}.
derive-eq-bo1 Ity Kno _Kty Vars _VarsTy R :-
  R = {{ fun (x2 : lp:Ity) => lp:Bo x2 }},
  pi x2 \
    build-match-skeleton x2 Ity
      derive-eq-ty2 (derive-eq-bo2 Kno Vars) (Bo x2).
  
derive-eq-bo-params 0 Ity _Arity R :- !,
  R = {{fix f (x1 : lp:Ity) {struct x1} : lp:Ity -> bool := lp:Bo f x1 }},
  pi f x1 \
    eq-db Ity f =>
    build-match-skeleton x1 Ity
      derive-eq-ty1 (derive-eq-bo1 Ity) (Bo f x1).

derive-eq-bo-params N Ity (prod _ Sty Rty) R :- M is N - 1,
  R = {{ fun (A : lp:Sty) (eqA : A -> A -> bool) => lp:Bo A eqA }},
  pi a f \  sigma ItyA \
    mk-app Ity [a] ItyA, 
    eq-db a f => derive-eq-bo-params M ItyA (Rty a) (Bo a f).

derive-eq-clause Lno Ty (prod _ _ Tx) Todo Cmp (pi x fx\ C x fx) :- Lno > 0, !,
  Lno1 is Lno - 1,
  pi x fx\
    derive-eq-clause Lno1
      {mk-app Ty [x]} (Tx x) [eq-db x fx|Todo] {mk-app Cmp [x,fx]} (C x fx).
derive-eq-clause 0 Ty (prod _ _ Tx) Premises Cmp (pi x\ C x) :-
  pi x\
    derive-eq-clause 0 {mk-app Ty [x]} (Tx x) Premises {mk-app Cmp [x]} (C x).
derive-eq-clause 0 Ty (sort _) Premises Cmp (eq-db Ty Cmp :- Conditions) :-
  derive-eq-premise->cond Premises Conditions.
derive-eq-premise->cond [] true.
derive-eq-premise->cond [X] X.
derive-eq-premise->cond [X|XS] (C, X) :- derive-eq-premise->cond XS C.

derive-eq GR :- do! [
  coq-env-indt GR Ind Lno Luno Arity _ _,
  assert (Ind = tt) "derive.eq: Coinductive types are not supported",
  assert (Lno = Luno) "derive.eq: Non-uniform parameters not supported",
  derive-eq-bo-params Lno (indt GR) Arity R,
  Name is {coq-gr->id GR} ^ "_eq",
  coq-elaborate R R1 R1T,
  coq-env-add-const Name R1 R1T _ Cmp,
  derive-eq-clause Lno (indt GR) Arity [] Cmp Clause,
  coq-elpi-accumulate "derive.eq.db" (clause _ _ Clause)
].

