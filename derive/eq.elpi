/* Boolean comparison functions                                             */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

derive-eq-bo-and [] [] _ {{true}}.
derive-eq-bo-and [X] [Y] [T] (app[F,X,Y]) :- !, eq-db T F.
derive-eq-bo-and [X|XS] [Y|YS] [T|TS] {{ (lp:R && lp:RS)%bool }} :-
  eq-db T F, R = app[F,X,Y], derive-eq-bo-and XS YS TS RS.

derive-eq-ty3 _ _ _ {{bool}}.
derive-eq-bo3 Kno Vars1 Kno _ Vars2 VarsTy R :- !,
  derive-eq-bo-and Vars1 Vars2 VarsTy R.
derive-eq-bo3 Kno1 _ Kno2 _ _ _ {{false}}.

derive-eq-ty2 _ _ Tys R :- rev Tys [T|_], R = {{lp:T -> bool}}.
derive-eq-bo2 Ity GR Args Kno Kty Vars VarsTy R :-
  R = {{ fun (x2 : lp:Ity) => lp:Bo x2 }},
  pi x2 \
    build-match-skeleton x2 GR Args
      derive-eq-ty3 (derive-eq-bo3 Kno Vars) (Bo x2).
  
derive-eq-bo-params 0 Ity Arity R :- !,
  R = {{fix f (x1 : lp:Ity) {struct x1}
              : lp:Ity -> lp:Ity -> bool := lp:Bo f x1 }},
  safe-dest-app Ity (indt GR) Args,
  pi f x1 \
    eq-db Ity f =>
    build-match-skeleton x1 GR Args
      derive-eq-ty2 (derive-eq-bo2 Ity GR Args) (Bo f x1).

derive-eq-bo-params N Ity (prod Name Sty Rty) R :- M is N - 1,
  R = {{ fun (A : lp:Sty) (eqA : A -> A -> bool) => lp:Bo A eqA }},
  pi a f \  sigma ItyA \
    mk-app Ity [a] ItyA, 
    eq-db a f => derive-eq-bo-params M ItyA (Rty a) (Bo a f).

derive-eq-clause Lno Ty (prod N S Tx) Todo Cmp (pi x fx\ C x fx) :- Lno > 0, !,
  Lno1 is Lno - 1,
  pi x fx\
    derive-eq-clause Lno1
      {mk-app Ty [x]} (Tx x) [eq-db x fx|Todo] {mk-app Cmp [x,fx]} (C x fx).
derive-eq-clause 0 Ty (prod _ _ Tx) Premises Cmp (pi x\ C x) :-
  pi x\
    derive-eq-clause 0 {mk-app Ty [x]} (Tx x) Premises {mk-app Cmp [x]} (C x).
derive-eq-clause 0 Ty (sort _) Premises Cmp (eq-db Ty Cmp :- Conditions) :-
  derive-eq-premise->cond Premises Conditions.
derive-eq-premise->cond [] true.
derive-eq-premise->cond [X] X.
derive-eq-premise->cond [X|XS] (C, X) :- derive-eq-premise->cond XS C.

derive-eq GR :-
  coq-env-indt GR Ind Lno Luno Arity _ _,
  assert (Ind = tt) "derive-eq: Coinductive types are not supported",
  assert (Lno = Luno) "derive-eq: Non-uniform parameters not supported",
  derive-eq-bo-params Lno (indt GR) Arity R,
  coq-say R,
  Name is {coq-gr->id GR} ^ "_eq",
  coq-env-add-const Name R _ _ Cmp,
  derive-eq-clause Lno (indt GR) Arity [] Cmp Clause,
  coq-elpi-accumulate "derive.eq.db" (clause _ _ Clause).

