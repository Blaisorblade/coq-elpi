/* Derive a function "projnK t -> x" iif t is "K ..x.."                      */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

namespace derive.projK {

body (prod N T F) Args GR Paramsno J K KT (lam N T B) :-
  pi x\ body (F x) [x|Args] GR Paramsno J K KT (B x).
body (sort _) RArgs GR Paramsno J K KT R :- do! [
  rev RArgs Args,
  take Paramsno Args Params,
  subst-prod Params KT KTP,
  bind-aux KTP J J GR Args K R
].

bind-aux (prod N T F) J OJ GR Args K (lam N T B) :- J > 0, !,
  J1 is J - 1,
  pi x\ bind-aux (F x) J1 OJ GR Args K (B x).

bind-aux (prod _ T _) 0 J GR Args K (lam `d` T x\ lam `i` I (B x)) :-
  mk-app (indt GR) Args I,
  pi d i\
    build-match i I
        (_\ _\ _\ r\ r = T)
    (k1\ _\ args\ _\ r\
      if (safe-dest-app k1 (indc K) _)
         (nth J args r)
         (r = d))
    (B d i).

allK-projs Prefix J JN Projs Paramsno Arity GR (indc K) KTy Clauses :- do! [
  body Arity [] GR Paramsno J K KTy R,
  J1 is J + 1,
  Name is Prefix ^ {any->string J1} ^ {coq.gr->id K},
  if (coq.typecheck R TyR)
     (coq.env.add-const Name R TyR _ P,
      Clause = projK-db K J1 P,
      coq.elpi.accumulate "derive.projK.db" (clause _ _ Clause),
      Clauses = [Clause|Clauses1])
     (coq.say "skip" Name {pp R}, P = hole, Clauses = Clauses1),
  if (JN > J1)
     (allK-projs Prefix J1 JN [P|Projs] Paramsno Arity GR (indc K) KTy Clauses1)
     (Clauses1 = [])
].

for-K Prefix Paramsno Arity GR K KT Clauses :- do! [
  count-prods KT N, Argsno is N - Paramsno,
  if (Argsno > 0)
     (allK-projs Prefix 0 Argsno [] Paramsno Arity GR K KT Clauses)
     (Clauses = [])
].

main I Prefix Clauses :- do! [
  coq.locate I T,
  assert (T = indt GR) "derive.projK: not an inductive type",
  coq.env.indt GR _ Paramsno _ Arity Kn Kt,
  map2 Kn Kt (for-K Prefix Paramsno Arity GR) ClausesList,
  flatten ClausesList Clauses
].

}
