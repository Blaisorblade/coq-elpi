/* induction principles                                                      */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

namespace derive.induction {

type induction-hyp term -> term -> prop.

push-arity (sort _) C (C :- !).
push-arity (prod _ _ _ as X) (pi x\ C x) (pi x\ C1 x) :-
  pi x\ push-arity X (C x) (C1 x).
push-arity (prod _ _ T) (reali A B) C :-
  (pi x\ mk-app A [x] (A1 x), mk-app B [x] (B1 x)),
  pi x\ push-arity (T x) (pi x\ reali (A1 x) (B1 x)) C.
push-arity (prod _ _ T) (param1P-db A B) C :-
  (pi x\ mk-app A [x] (A1 x), mk-app B [x] (B1 x)),
  pi x\ push-arity (T x) (pi x\ param1P-db (A1 x) (B1 x)) C.

prove [] [] [].
prove [X,P|XS] [_,TR|TS] [X,PX|PS] :-
  copy TR Goal, !,
  % coq.say {coq.term->string TR} "->" {coq.term->string Goal},
  if (TR = Goal) (PX = P) (spy(param1P-db Goal F), mk-app F [P] PX),
  prove XS TS PS.

branch K _ V VT R :-
  induction-hyp K IH,
  prove V VT Args, !,
  mk-app IH Args R.

oty _ _ VT P :-
  last VT XT,
  copy XT P.

branches (prod Name S T) Ity N M (prod Name S F1) (lam Name S R1) :- !,
  pi x\ decl x Name S =>
    branches (T x) {mk-app Ity [x]} {calc (N + 1)} M (F1 x) (R1 x).

branches (sort _) Ity Rno Rno Fty (lam `x` Ity Bo) :-
  copy Ity P, !,
  Fty = prod `x` Ity (_\ P),
  pi x\ decl x `x` Ity =>
    build-match x Ity oty branch (Bo x).

hyp (prod N S T) (prod N Q R) :- !,
  copy S Q,
  pi x \ decl x N Q => hyp (T x) (R x).
hyp S Q :- copy S Q.

hyps [K|KS] [KT|KTS] Ity Arity P (lam Name Ind Bo) :-
  term->gr K GRK,
  coq.name-suffix `H` {coq.gr->id GRK} Name,
  hyp KT Ind,
  pi x\
    induction-hyp K x =>
    decl x Name Ind =>
    hyps KS KTS Ity Arity P (Bo x).

hyps [] [] Ity Arity P (fix `IH` Recno Fty Bo) :-
  pi f\ sigma C\
    push-arity Arity (param1P-db P f) C,
    % coq.say "PROVE+=" C,
    C => decl f `IH` Fty => branches Arity Ity 0 Recno Fty (Bo f).

truncated-predicate-ty (sort _) T :-
  T = sort (typ U), coq.univ.new [] U.
truncated-predicate-ty (prod N S T) (prod N S R) :-
  pi x\ truncated-predicate-ty (T x) (R x).
  
params N Ity K KT (prod Nx Sx x\ prod NP (SP x) (T x)) (lam Nx Sx x\ lam NP (SP x) (R1 x)) :- N > 0, !,
  M is N - 2,
  pi x px\
    decl x Nx Sx => decl px NP (SP x) =>
    params M
      {mk-app Ity [x,px]} {map K (k\ mk-app k [x,px])} {map KT (subst-prod [x,px])}
      (T x px) (R1 x px).

mk-copy-clause Ity P C :-
 safe-dest-app Ity IT ITArgs,
 C = (pi Args Rest\
       copy (app[IT|Args]) (app[P|Rest]) :- !, appendR ITArgs Rest Args).

params 0 Ity K KT Arity (lam `P` Pty p\ Bo p) :-
  truncated-predicate-ty Arity Pty,
  pi p\ sigma Clause\
    mk-copy-clause Ity p Clause,
    % coq.say "STATE+=" Clause,
    Clause => decl p `P` Pty => hyps K KT Ity Arity p (Bo p).

ensure-typechecks R RT :- coq.typecheck R RT, !.
ensure-typechecks R _ :-
  coq.error "derive.induction: Generate ill-typed term:" {coq.term->string R}.

pred main i:term, i:string, o:list prop.
main T Name [Clause] :- do! [
  assert (T = indt _) "derive.induction: not an inductive type",
  assert (reali T TR) {calc (
    "derive.induction: no unary parametricity translation for" ^
    {coq.term->string T} ^ ", use derive.param1 first")},
  TR = indt GRR,
  coq.env.indt GRR Ind _ Luno Arity K KT,
  assert (Ind = tt) "derive.induction: Coinductive types are not supported",

  params Luno TR K KT Arity R,
  ensure-typechecks R RT,
  coq.env.add-const Name R RT _ I,

  Clause = induction-db T I,
  coq.elpi.accumulate "derive.induction.db" (clause _ _ Clause)
].

}
