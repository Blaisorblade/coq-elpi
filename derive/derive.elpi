/* Entry point for all derivations                                           */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

namespace derive {

pred chain i:list (list prop -> prop).
:if "DBG:derive" chain [X|_] :- coq.say {counter "run"} X, fail.
chain [].
chain [F|FS] :- (stop :- !, fail) => F C, !, C => chain FS.
chain [F|FS] :- coq.say "Derivation fails: " F, chain FS.


begin_ns N [] :- coq.env.begin-module N _.
end_ns [] :- coq.env.end-module _.

param1p T N C :-
  reali T P, !,
  derive.param1P.main P N C.

invert T N C :-
  reali T P, !,
  derive.invert.main P N C.

mapR T N C :-
  reali T R, !,
  derive.map.main R N C.

simplify P N C :-
  P T,
  derive.eqOK.main T N C.

main T M :- 
  coq.gr->id {term->gr T} Tname,
  Indname is M ^ Tname ^ "_",
  chain [
    derive.isK.main T {calc (Indname ^ "is_")},
    derive.map.main T {calc (Indname ^ "map")},
    derive.projK.main T {calc (Indname ^ "get_")},
    derive.param1.main T {calc (M ^ "is_")},
    param1p T Indname,
    mapR T {calc (M ^ "is_" ^ Tname ^ "_map")},
    % invert T "",
    derive.induction.main T {calc (Indname ^ "induction")},
    % simplify (induction-db T) "induction",
    derive.eq.main T {calc (Indname ^ "eq")},
    derive.bcongr.main T {calc (Indname ^ "bcongr_")},
    derive.eqK.main T {calc (Indname ^ "eq_axiom_")},
    derive.eqcorrect.main T {calc (Indname ^ "eq_correct")},
    derive.eqOK.main T {calc (Indname ^ "eq_OK")}
  ].
  
}
