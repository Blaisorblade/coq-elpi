/* param1 holds on the full type                                             */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

namespace derive.param1P {

% local data base to map a constructor K of T (applied to params) to
% the pair isK and its type, eg ({{Zero}} `-> pr {{isZero}} {{isNat Zero}}))
type (`->) term -> pair term term -> prop.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pred search i:term, o:term. % given isT it builds a proof forall x:T, isT x

search Goal P :- param1P-db Goal P.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pred prove-args % for each (K x ..) we must produce (isK x x_isX ..)
  i:list term, % the variables (x in the example above)
  i:term,      % the type of isK
  o:list term. % x and x_isX
prove-args [] _ [].
prove-args [V|VS] (prod N T x\ prod NX (PX x) (px\ F x px)) [V,PV | RS] :-
  reali T TR, !,  % out of the type of x we get isX
  search TR PT,   % PT is a proof that forall x, isX x
  PV = app[PT,V], % PV is the x_isX above
  @pi-decl N T x\
  @pi-decl NX (PX x) px\
    prove-args VS (F x px) RS.

oty F _ V _ R :- rev V [X|_], R = F X.

body K _ V _ R :-
  safe-dest-app K Kname _,
  Kname `-> (pr KR KRT),
  prove-args V KRT Args,
  mk-app KR Args R.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pred body-params
  i:int,   % number of params left
  i:term,  % inductive type applied to parameters treated so far
  i:term,  % inductive type arity to process
  i:list term, % construcors applied to parameters treated so far
  i:list term, % construcor's types instantiated to parameters treated so far
  o:term.

body-params 0 T (prod _ XT _\ sort _) K KT R :- !,
  RT = (x\ {mk-app T [x]}),
  R = {{ fix IH (x : lp:XT) {struct x} : lp:RT x := lp:Bo IH x }},
  safe-dest-app XT (indt GR) _,
  coq.env.indt GR _ _ _ _ KX _,
  map2 KX {zip K KT} (a\b\r\ r = a `-> b) K2KR,
  K2KR => % K `-> (pr isK isKtype)
    @pi-decl `IH` (prod `x` XT x\ RT x) f\ 
    @pi-decl `x` XT x\
    param1P-db T f =>
    build-match x XT
      (oty RT)
      body
    (Bo f x).

% param1 have the form : isT A (P : A -> Type) .. , so we process two
% binders at a time and we assume (H : forall x : A, P x) for each A and P
body-params N T (prod A TA a\ prod P (TP a) (F a)) K KT R :- N > 0, !,
  M is N - 2,
  R = (lam A TA a\
        lam P (TP a) p\
         lam _ (prod `x` a x\ app[p,x]) pf\ Bo a p pf), 
  @pi-decl A TA a\
  @pi-decl P (TP a) p\
  @pi-decl _ (prod `x` a x\ app[p,x]) pf\
  sigma KAP KTAP\
    map K  (k\ mk-app k [a,p]) KAP,
    map KT (subst-prod [a,p]) KTAP,
    reali a p =>
    param1P-db p pf => % to prove (P x) use (H x)
      body-params M {mk-app T [a,p]} (F a p) KAP KTAP (Bo a p pf).

body-params _ T _ _ _ _ :-
  coq.say "derive.param1P: wrong shape " {coq.term->string T}
            ". It does not look like a unary parametricity translation of an inductive with no indexes.",
  fail.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
main T Prefix [Clause] :- do! [
  % The input is T is the param1 translation of an inductive type
  assert (T = indt GR) "derive.param1P: not an inductive type",
  coq.env.indt GR Ind Lno Luno Arity K KT,
  assert (Ind = tt) "derive.param1P: Coinductive types are not supported",
  assert (Lno = Luno) "derive.param1P: Non-uniform parameters not supported",
  Name is Prefix ^ {coq.gr->id GR},
  
  body-params Lno (indt GR) Arity K KT R,
  coq.typecheck R RT,
  coq.env.add-const Name R RT ff Cmp,
  Clause = (param1P-db T Cmp),

  coq.elpi.accumulate "derive.param1P.db" (clause _ _ Clause)
].

}

% vim:set ft=lprolog spelllang=:
