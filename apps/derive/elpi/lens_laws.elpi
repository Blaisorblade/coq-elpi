/* Equations on lenses                                                       */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

namespace derive.lens-laws {

pred declare-law1 i:prop.
declare-law1 (lens-db I C) :- std.do! [
  coq.env.indt-decl I Decl,
  law1 Decl (global (const C)) (global (indt I)) Bo Ty,
  Name is {coq.gref->id (const C)} ^ "_law1",
  coq.env.add-const Name Bo Ty @opaque! _,
].
pred law1 i:indt-decl, i:term, i:term, o:term, o:term.
law1 (parameter ID _ Ty Rest) Lens Ind {{ fun p : lp:Ty => lp:(Bo p) }} {{ forall p : lp:Ty, lp:(BoTy p) }} :- !,
  @pi-parameter ID Ty p\ law1 (Rest p) {coq.mk-app Lens [p]} {coq.mk-app Ind [p]} (Bo p) (BoTy p).
law1 _ Lens IT Bo Ty :-
  BoS = {{ fun r => lp:{{ {coq.build-match {{r}} IT (law1-rty.aux Lens) law1-bo.aux } }} }},
  TyS = {{ lib:elpi.derive.lens.law1 lp:Lens }},
  std.assert-ok! (coq.elaborate-ty-skeleton TyS _ Ty) "ty",
  std.assert-ok! (coq.elaborate-skeleton BoS Ty Bo) "bo".
law1-rty.aux L _ Vs _ {{ lib:elpi.derive.lens.law1_on lp:L lp:R }} :- std.last Vs R.
law1-bo.aux _ _ _ _ {{ fun x => lib:@elpi.erefl _ _ }}.

pred declare-law2 i:prop.
declare-law2 (lens-db I C) :- std.do! [
  coq.env.indt-decl I Decl,
  law2 Decl (global (const C)) (global (indt I)) Bo Ty,
  Name is {coq.gref->id (const C)} ^ "_law2",
  coq.env.add-const Name Bo Ty @opaque! _,
].
pred law2 i:indt-decl, i:term, i:term, o:term, o:term.
law2 (parameter ID _ Ty Rest) Lens Ind {{ fun p : lp:Ty => lp:(Bo p) }} {{ forall p : lp:Ty, lp:(BoTy p) }} :- !,
  @pi-parameter ID Ty p\ law2 (Rest p) {coq.mk-app Lens [p]} {coq.mk-app Ind [p]} (Bo p) (BoTy p).
law2 _ Lens IT Bo Ty :-
  BoS = {{ fun r => lp:{{ {coq.build-match {{r}} IT (law2-rty.aux Lens) law2-bo.aux } }} }},
  TyS = {{ lib:elpi.derive.lens.law2 lp:Lens }},
  std.assert-ok! (coq.elaborate-ty-skeleton TyS _ Ty) "ty",
  std.assert-ok! (coq.elaborate-skeleton BoS Ty Bo) "bo".
law2-rty.aux L _ Vs _ {{ lib:elpi.derive.lens.law2_on lp:L lp:R }} :- std.last Vs R.
law2-bo.aux _ _ _ _ {{ fun x y => lib:@elpi.erefl _ _ }}.

pred declare-law3 i:prop.
declare-law3 (lens-db I C) :- std.do! [
  coq.env.indt-decl I Decl,
  law3 Decl (global (const C)) (global (indt I)) Bo Ty,
  Name is {coq.gref->id (const C)} ^ "_law3",
  coq.env.add-const Name Bo Ty @opaque! _,
].
pred law3 i:indt-decl, i:term, i:term, o:term, o:term.
law3 (parameter ID _ Ty Rest) Lens Ind {{ fun p : lp:Ty => lp:(Bo p) }} {{ forall p : lp:Ty, lp:(BoTy p) }} :- !,
  @pi-parameter ID Ty p\ law3 (Rest p) {coq.mk-app Lens [p]} {coq.mk-app Ind [p]} (Bo p) (BoTy p).
law3 _ Lens IT Bo Ty :-
  BoS = {{ fun r => lp:{{ {coq.build-match {{r}} IT (law3-rty.aux Lens) law3-bo.aux } }} }},
  TyS = {{ lib:elpi.derive.lens.law3 lp:Lens }},
  std.assert-ok! (coq.elaborate-ty-skeleton TyS _ Ty) "ty",
  std.assert-ok! (coq.elaborate-skeleton BoS Ty Bo) "bo".
law3-rty.aux L _ Vs _ {{ lib:elpi.derive.lens.law3_on lp:L lp:R }} :- std.last Vs R.
law3-bo.aux _ _ _ _ {{ lib:@elpi.erefl _ _ }}.

pred declare-law4 i:prop, i:prop.
declare-law4 (lens-db I C) (lens-db I C) :- !.
declare-law4 (lens-db I C1) (lens-db I C2) :- std.do! [
  coq.env.indt-decl I Decl,
  law4 Decl (global (const C1)) (global (const C2)) (global (indt I)) Bo Ty,
  Name is {coq.gref->id (const C1)} ^ {coq.gref->id (const C2)} ^ "_law4",
  coq.env.add-const Name Bo Ty @opaque! _,
].
pred law4 i:indt-decl, i:term, i:term, i:term, o:term, o:term.
law4 (parameter ID _ Ty Rest) Lens1 Lens2 Ind {{ fun p : lp:Ty => lp:(Bo p) }} {{ forall p : lp:Ty, lp:(BoTy p) }} :- !,
  @pi-parameter ID Ty p\ law4 (Rest p) {coq.mk-app Lens1 [p]}  {coq.mk-app Lens2 [p]} {coq.mk-app Ind [p]} (Bo p) (BoTy p).
law4 _ Lens1 Lens2 IT Bo Ty :-
  BoS = {{ fun r => lp:{{ {coq.build-match {{r}} IT (law4-rty.aux Lens1 Lens2) law4-bo.aux } }} }},
  TyS = {{ lib:elpi.derive.lens.law4 lp:Lens1 lp:Lens2 }},
  std.assert-ok! (coq.elaborate-ty-skeleton TyS _ Ty) "ty",
  std.assert-ok! (coq.elaborate-skeleton BoS Ty Bo) "bo".
law4-rty.aux L1 L2 _ Vs _ {{ lib:elpi.derive.lens.law4_on lp:L1 lp:L2 lp:R }} :- std.last Vs R.
law4-bo.aux _ _ _ _ {{ fun x y => lib:@elpi.erefl _ _ }}.

pred main i:inductive, o:list prop.
main I [] :- std.do! [
  std.findall (lens-db I L_) Lenses,
  std.forall Lenses declare-law1,
  std.forall Lenses declare-law2,
  std.forall Lenses declare-law3,
  std.forall Lenses (l1\ std.forall Lenses (l2\ declare-law4 l1 l2)),
].

}
