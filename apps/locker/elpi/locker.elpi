/* Locker                                                                    */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

namespace locker {

pred key-lock i:id, i:term, i:arity.
key-lock ID BO ARITY :- std.do! [
  make-key ID Key,

  coq.arity->term ARITY Ty,
  std.assert-ok! (coq.elaborate-skeleton {{ @locked_with lp:Key lp:Ty lp:BO }} DefTy Def)
    "locker: illtyped definition",
  coq.env.add-const ID Def DefTy _ C,

  make-key-unlockable ID Def DefTy (global (const C)) Key,
].

pred make-key i:id, o:term.
make-key ID (global (const C)) :- std.do! [
  KID is ID ^ "_key_subproof",
  coq.env.add-const KID {{ tt }} {{ unit }} @opaque! C,
].

pred module-lock i:id, i:term, i:arity.
module-lock Name BoSkel AritySkel :- std.do! [
  std.assert-ok! (coq.elaborate-arity-skeleton AritySkel _ Arity) "locker: type illtyped",
  coq.arity->term Arity Ty,
  std.assert-ok! (coq.elaborate-skeleton BoSkel Ty Bo) "locker: body illtyped",

  lock-module-type Name Ty Bo Signature,
  lock-module-body Signature Name Ty Bo C Module,

  @global! => coq.notation.add-abbreviation Name 0 (global (const C)) ff _,

  make-module-unlockable Name Module,
].

pred lock-module-type i:id, i:term, i:term, o:modtypath.
lock-module-type ID Ty Bo M :- std.do! [
  Name is ID ^ "_Locked",
  coq.env.begin-module-type Name,
  coq.env.add-axiom "body" Ty C, B = global (const C),
  PTY = {{ lp:B = lp:Bo }},
  std.assert-ok! (coq.typecheck-ty PTY _) "lock: unlock statement illtyped",
  coq.env.add-axiom "unlock" PTY _,
  coq.env.end-module-type M,
].

pred lock-module-body o:modtypath, i:id, i:term, i:term, o:constant, o:modpath.
lock-module-body Signature Name Ty Bo C M :- std.do! [
  coq.env.begin-module Name (some Signature),
  coq.env.add-const "body" Bo Ty @transparent! C, B = global (const C),
  P = {{ @refl_equal lp:Ty lp:B }},
  std.assert-ok! (coq.typecheck P _) "locker: unlock proof illtyped",
  PTY = {{ lp:B = lp:Bo }},
  std.assert-ok! (coq.typecheck-ty PTY _) "locker: unlock statement illtyped",
  coq.env.add-const "unlock" P PTY @opaque! _,
  coq.env.end-module M,
].

% Unlocking via the ssreflect Unlockable interface (CS instance)

pred make-key-unlockable i:string, i:term, i:term, i:term, i:term.
make-key-unlockable ID DefBo DefTy LockedDef Key :- std.do! [
  % we extract the read body in order to be precise in the unlocking equation
  DefBo = {{ @locked_with _ _ lp:Bo }},
  UnlockEQ = {{ @locked_withE lp:DefTy lp:Key lp:Bo }},
  Unlock = {{ @Unlockable _ _ lp:LockedDef lp:UnlockEQ }},
  make-unlockable ID Unlock,
].

pred make-module-unlockable i:id, i:modpath.
make-module-unlockable Name Module :- std.do! [
  coq.env.module Module [_,UnlockEQ],
  Unlock = {{ Unlockable lp:{{ global UnlockEQ }} }},
  make-unlockable Name Unlock,
].

pred make-unlockable i:id, i:term.
make-unlockable Name Unlock :- std.do! [
  std.assert-ok! (coq.typecheck Unlock UnlockTy) "locker: unlocking instance illtyped",
  UID is Name ^ "_unlock_subterm",
  coq.env.add-const UID Unlock UnlockTy _ U,
  coq.CS.declare-instance (const U),
].

}