(* Generates correctness proofs for comparison functions generated by derive.eq.

   license: GNU Lesser General Public License Version 2.1 or later           
   ------------------------------------------------------------------------- *)

From elpi Require Import elpi
  derive.eq derive.projK derive.isK 
  derive.param1 derive.param1P derive.map
  derive.induction derive.isK derive.projK
  derive.cast derive.bcongr.

From Coq Require Import ssreflect ssrbool.

Definition axiom T eqb x :=
  forall (y : T), reflect (x = y) (eqb x y).

Definition axiom_at T eqb (x y :T) :=
  reflect (x = y) (eqb x y).

Elpi derive.param1 prod.
Elpi derive.param1 list.
Elpi derive.param1 nat.
Elpi derive.param1 bool.

Elpi derive.param1P prodR.
Elpi derive.param1P listR.
Elpi derive.param1P natR.
Elpi derive.param1P boolR.

Elpi derive.map prodR.
Elpi derive.map listR.

Elpi derive.projK prod.
Elpi derive.projK list.
Elpi derive.projK nat.
Elpi derive.projK bool.

Elpi derive.bcongr prod.
Elpi derive.bcongr list.
Elpi derive.bcongr nat.
Elpi derive.bcongr bool.

Elpi derive.isK prod.
Elpi derive.isK list.
Elpi derive.isK nat.
Elpi derive.isK bool.

Elpi derive.induction nat.
Elpi derive.induction bool.
Elpi derive.induction list.
Elpi derive.induction prod.

Elpi derive.induction natR.
Elpi derive.induction boolR.
Elpi derive.induction listR.
Elpi derive.induction prodR.

Inductive nat1 := 
 | O1 
 | S1 (_ : nat1 * (bool * list nat1)).

Elpi derive.param1 nat1.
Elpi derive.param1P nat1R.
Elpi derive.induction nat1.


Notation pred X := (X -> Type).


Inductive listRR (A : Type) (PA : pred A) (PPA : forall a, pred (PA a)) : forall l : list A, pred (listR A PA l) :=
  nilRR  : listRR A PA PPA nil (nilR A PA)
| consRR (a : A) (pa : PA a) (_ : PPA a pa) (xs : list A) (pxs : listR A PA xs)
         (IH : listRR A PA PPA xs pxs) : listRR A PA PPA (cons a xs) (consR A PA a pa xs pxs).

Lemma listRRP (A : Type) (PA : pred A) (PPA : forall a, pred (PA a))
              (H : forall x px, PPA x px)
              : forall l lr, listRR A PA PPA l lr.
Proof.
move=>l.
elim=>[|x px xs pxs IH].
  constructor.
apply: consRR IH.
by [].
Defined.

Inductive prodRR (A : Type) (PA : pred A) (PPA : forall x, pred (PA x))
                 (B : Type) (PB : pred B) (PPB : forall x, pred (PB x)) :
                 forall x, pred (prodR A PA B PB x) := 
pairRR (a:A) (pa:PA a) (ppa : PPA a pa) (b:B) (pb : PB b) (ppb : PPB b pb) : prodRR A PA PPA B PB PPB (a,b) (pairR A PA B PB a pa b pb).

Lemma prodRRP (A : Type) (PA : pred A) (PPA : forall x, pred (PA x)) (HA : forall x px, PPA x px)
             (B : Type) (PB : pred B) (PPB : forall x, pred (PB x)) (HB : forall x px, PPB x px) :
               forall x px, prodRR A PA PPA B PB PPB x px.
Proof.
case=> ??[a pa b pb].
by constructor.
Qed.

Inductive boolRR : forall b, pred (boolR b) :=
  trueRR : boolRR true trueR
 |falseRR: boolRR false falseR.

Lemma boolRRP : forall b br, boolRR b br.
Proof.
by case; case; constructor.
Qed.

(*
Elpi derive.param1 listR.
Elpi derive.param1 prodR. 
Elpi derive.param1 boolR.

Elpi derive.param1 nat1R.
*)
(*
Elpi derive.induction nat1R.
*)
Lemma nat1R_induction (P : forall x, nat1R x -> Type) :
  P O1 O1R ->
  (forall (p : nat1 * (bool * list nat1))
          (_ : prodR nat1 nat1R (bool * list nat1) (prodR bool boolR (list nat1) (listR nat1 nat1R)) p)
          (px  : prodR nat1 nat1R (bool * list nat1) (prodR bool boolR (list nat1) (listR nat1 nat1R)) p)
          (IH : prodRR nat1 nat1R P
                      (bool * list nat1) (prodR bool boolR (list nat1) (listR nat1 nat1R))
                        (prodRR bool boolR boolRR (list nat1) (listR nat1 nat1R) (listRR nat1 nat1R P)) p px)
                      
 

, P (S1 p) (S1R p px)) ->
  forall x r, P x r.
Proof.
move=> H0 H1. 
fix IH 2 => x [| s ps ].
  by apply: H0.
apply: H1.
  by apply: ps.
case: ps => ? p ? q.
apply: pairRR.
  by apply: IH p.
case: q => ?? ? l.
apply: pairRR.
  by apply: boolRRP.
apply: listRRP; apply: IH.
Qed.

Lemma nat1R_induction_trunk (P : nat1 -> Type) :
  P O1 ->
  (forall (p : nat1 * (bool * list nat1))
          (*_ : prodR nat1 nat1R (bool * list nat1) (prodR bool boolR (list nat1) (listR nat1 nat1R)) p*)
          (px  : prodR nat1 P (bool * list nat1) (prodR bool boolR (list nat1) (listR nat1 P)) p)
          
                       
 

, P (S1 p)) ->
  forall x (r : nat1R x), P x.
Proof.
move=> H0 H1. 
fix IH 2 => x [| s ps ].
  by apply: H0.
apply: H1.
  (*by apply: ps.*)
apply: prodR_map ps.
  by apply: IH.
apply: prodR_map.
  by [].
apply: listR_map.
by apply: IH.
Qed.





Elpi derive.eq list. 
Elpi derive.eq prod.
Elpi derive.eq bool.
Elpi derive.eq nat.
Elpi derive.eq nat1.

Elpi derive.isK nat1.
Elpi derive.projK nat1.
Elpi derive.bcongr nat1.


Lemma bool_eqOK
            x : boolR x -> axiom bool bool_eq x.
Proof.
by elim; case; constructor.
Qed.

Definition eq_axiom_pair A fa B fb :
  forall a, axiom A fa a ->
  forall b, axiom B fb b ->
    axiom (A * B) (prod_eq A fa B fb) (a,b) :=
 (fun (a : A) (Pa : axiom A fa a)
            (b : B) (Pb : axiom B fb b) (w : A * B) =>
   match w return reflect ((a,b) = w) (prod_eq A fa B fb (a,b) w) with
   | pair x y => pair_congr A B a x (fa a x) (Pa x) b y (fb b y) (Pb y)
   end).


Definition prod_eqOK
            A fa B fb x :
            prodR A (axiom A fa) B (axiom B fb) x ->
            axiom (A * B) (prod_eq A fa B fb) x
:=
fun e : prodR A (axiom A fa) B (axiom B fb) x =>
  prodR_induction A (axiom A fa) B (axiom B fb) (fun r _ => axiom (A * B) (prod_eq A fa B fb) r)
    (fun a _ Pa _ b _ Pb _ => eq_axiom_pair A fa B fb a Pa b Pb)
  x e.

Lemma eq_axiom_nil A fa : axiom (list A) (list_eq A fa) (@nil A).
Proof.

refine (fun x : list A =>
  match x return axiom_at (list A) (list_eq A fa) (@nil A) x
  with
  | nil => nil_congr A
  | cons w ws => ReflectF (nil = cons w ws) (fun abs : nil = cons w ws => _)
end).
discriminate abs.

Qed.

Lemma eq_axiom_cons A fa :
  forall x, axiom A fa x ->
  forall xs, axiom (list A) (list_eq A fa) xs ->
    axiom (list A) (list_eq A fa) (cons x xs).
Proof.

refine (fun x Px xs Pxs l =>
  match l return axiom_at (list A) (list_eq A fa) (cons x xs) l
  with
  | nil => ReflectF (cons x xs = nil) (fun abs : cons x xs = nil => _)
  | cons y ys => cons_congr A x y (fa x y) (Px y) xs ys (list_eq A fa xs ys) (Pxs ys)
  end).

discriminate abs.

Qed.

Check list_induction.

Lemma listR_induction_trunk
     : forall (A : Type) PA (P : pred (list A)),
       P nil ->
       (forall H : A, PA H -> forall H0 : list A, P H0 -> P (H :: H0)%list) ->
       forall x : list A, listR A PA x -> P x.
Proof.
move=> A PA P P0 P1.
by fix IH 2=> x [//|a pa l pl]; apply: P1 => //; apply: IH.
Qed.

Lemma list_eqOK
            A fa l :
            listR A (axiom A fa) l ->
            axiom (list A) (list_eq A fa) l.
Proof. 
elim/listR_induction_trunk.
  by apply: eq_axiom_nil.
move=> x px xs IH.
by apply: eq_axiom_cons.
Qed.
 

Lemma eq_axiom_O1 : axiom nat1 nat1_eq O1.
Proof.
case; first by apply: O1_congr.
by move=> ?; apply: ReflectF => abs; discriminate abs.
Qed.

Lemma eq_axiom_S1 x :
  axiom _ (prod_eq nat1 nat1_eq (bool * list nat1)
     (prod_eq bool bool_eq (list nat1)
        (list_eq nat1 nat1_eq))) x ->
     axiom nat1 nat1_eq (S1 x).
Proof.
move=> Hx [|y]; first by constructor 2=> ABS; discriminate ABS.
by apply: S1_congr; move: Hx y.
Qed.

Lemma prodRR_prodR A PA X B PB Y x px  : prodRR A PA X B PB Y x px -> prodR A (fun x => { p & X x p }) B (fun x => { p & Y x p }) x.
Proof. by case; constructor; eexists; eassumption. Qed.


Lemma listRR_listR A PA X l pl : listRR A PA X l pl -> listR A (fun x => { p & X x p }) l.
Proof.
by elim=> *; constructor=> //; eexists; eassumption.
Qed.

Definition proj {A B P Q} {_: forall x, P x -> Q x} (x : A) : { _ : B x & P x } -> Q x.
Proof.
by case=> *; apply: X.
Qed.


Lemma nat1_eqOK x : nat1R x -> axiom nat1 nat1_eq x.
Proof.
elim/nat1R_induction_trunk.
  by apply: eq_axiom_O1.
move=> p px.
apply: eq_axiom_S1.

apply: prod_eqOK.
apply: prodR_map px.
  by [].

move=> ? px.
apply: prod_eqOK.
apply: prodR_map px.
  by apply: bool_eqOK.

move=> ? px.
apply: list_eqOK.
apply: listR_map px.
by [].

Qed.

(*
Lemma nat1_eqOK x : nat1R x -> axiom nat1 nat1_eq x.
Proof.
elim/nat1R_induction.
  by apply: eq_axiom_O1.
move=> p _ tx px.
apply: eq_axiom_S1.

apply: prod_eqOK.
move/prodRR_prodR: px.
apply: prodR_map.
  by move=> ? [? px].
move=> ? [? px].

apply: prod_eqOK.
move/prodRR_prodR: px.
apply: prodR_map. 
  by move=> ? [? _]; apply: bool_eqOK.
move=> ? [? px].

apply: list_eqOK.
move/listRR_listR: px.
apply: listR_map.
by move=> ? [? px].

Qed.

Check (prodR_map _ _ _ _ _ _ _ _ _ (prodRR_prodR _ _ _ _ _ _ _ _ ppx)).
apply: prod_eqOK _ _ _ _ _ (prodR_map _ _ _ _ _ _ _ _ _ (prodRR_prodR _ _ _ _ _ _ _ _ ppx)).
  

case: ppx=> ?? pl ?? pr.

constructor.
  by apply: pl.
apply: prod_eqOK.
case: pr => ?? pb ?? pln.
constructor.
  by apply: bool_eqOK.
apply: list_eqOK.

Lemma nat1_eqOK x : nat1R x -> axiom nat1 nat1_eq x.
Proof.
move: x; apply: nat1_induction.

  move=> _.
  by case; [ constructor 1; reflexivity
           | constructor 2=> ABS; discriminate ABS ].

move=>x Px II; apply: eq_axiom_S1 (x) _; move: x Px II.

move=> x Px . case.
apply: prod_eqOK.
apply: prodR_map Px.  

  move=> n Pn. apply: Pn. exact: nat1RP.
  by move=> n Pn; exact Pn.

move=> q Pq.
apply: prod_eqOK.
apply: prodR_map Pq.

  by move=> b Pb; apply: bool_eqOK b Pb.

move => l Pl.
apply: list_eqOK.
apply: listR_map Pl.

by move=> n Pn; exact Pn.
Qed.




From Coq Require Import Bool List ssreflect.
From Coq Require Vector.

Elpi derive.param1 prod.
Elpi derive.param1 list.
Elpi derive.param1 nat.
Elpi derive.param1P prodR.
Elpi derive.param1P listR.
Elpi derive.param1P natR.
Elpi derive.map prodR.
Elpi derive.map listR.

Inductive nat1 := 
 | O1 
 | S1 (_ : nat1 * (bool * list nat1)).

Elpi derive.induction nat.
Elpi derive.induction bool.
Elpi derive.induction list.
Elpi derive.induction prod.
Elpi derive.induction nat1.

Elpi derive.eq list. 
Elpi derive.eq prod.
Elpi derive.eq bool.
Elpi derive.eq nat.
Elpi derive.eq nat1.

Elpi derive.isK bool.
Elpi derive.isK nat.
Elpi derive.isK list.
Elpi derive.isK prod.
Elpi derive.isK nat1.

Module Vector.
Elpi derive.eq Vector.t eq.
Elpi derive.induction Vector.t induction.
Elpi derive.isK Vector.t.
Elpi derive.projK Vector.t.
Elpi derive.param1 Vector.t R.
End Vector.

Print Vector.eq.

*)


(* Elpi derive.eq sigT. 

Definition sigT_eq A fA P fP (s1 s2 : { a : A & P a }) : bool :=
  match s1, s2 with
  | existT _ a pa, existT _ b pb =>
      fA a b && fP a pa b pb
  end.
About sigT_eq.
  Print Vector.eq.

Fixpoint veq A fA n m (v1 : Vector.t A n) (v2 : Vector.t A m) {struct v1} :=
  match v1 with
  | Vector.nil _ =>
      match v2 with
      | Vector.nil _ => true
      | _ => false
      end
  | Vector.cons _ x m xs =>
      match v2 with
      | Vector.nil _ => false
      | Vector.cons _ y n ys => fA x y && nat_eq m n && veq A fA m n xs ys
      end
  end.

Search eq projT1.


Fixpoint v2l A n (v : Vector.t A n) : list A :=
  match v with
  | Vector.nil _ => nil
  | Vector.cons _ x m xs => cons x (v2l A m xs)
  end.

Fixpoint l2v A (l : list A) : { n : nat & Vector.t A n } :=
  match l with
  | nil => existT _ 0 (Vector.nil _)
  | cons x xs =>
      let: existT _ j v := l2v _ xs in
      existT _ (S j) (Vector.cons _ x j v)
  end.

Lemma vl A n v : l2v A (v2l A n v) = existT _ n v.
Proof. by elim: v => //= x j xs ->. Qed.

Lemma lv A l : let v := l2v A l in v2l A _ (projT2 v) = l.
Proof.
elim: l => //= x xs.
by case: (l2v A xs) => j v IH /=; congr (_ :: _).
Qed.

Lemma list_eqOK A f :
  forall x (HA : listR A (axiom A f) x),
  axiom (list A) (list_eq A f) x.
Admitted.

Definition bij A B f := { g : B -> A & forall x, g (f x) = x }.

Lemma bij_l2v A : bij _ _ (l2v A).
Proof.
move.
exists (fun v => v2l A (projT1 v) (projT2 v)).
exact: lv.
Qed.

Definition inj A B (f : A -> B) := forall x y : A, f x = f y -> x = y.

Lemma inj_v2l A n : inj _ _ (v2l A n).
Proof.
elim => [y|].
  by refine match y with Vector.nil _ => _ end.
move=> x j xs IH y.
move: xs IH; rewrite -[j]/(pred (S j)). 
  refine match y with Vector.cons _ y k ys => _ end.
by move=> /= xs IH [-> /IH->].
Qed.

Lemma axiomK A B cmp f (inj_f : inj B A f) b1 :
  axiom A cmp (f b1) -> axiom B (fun x y => cmp (f x) (f y)) b1.
Proof.
move=> H b2.
have [/inj_f -> |nE ] := H (f b2).
  by constructor 1.
by constructor 2 => Hb; apply: nE; rewrite Hb.
Qed.

Definition veq A f n v1 v2 := list_eq A f (v2l A n v1) (v2l A n v2).

Lemma vR2lR A PA n pn v : Vector.tR A PA n pn v -> listR A PA (v2l A n v).
Proof.
elim => /= [| hd Phd j Pj tl Ptl IH].
  by constructor 1.
by constructor 2.
Qed.

Lemma veq_OK A f :
  forall x px v (HA : Vector.tR A (axiom A f) x px v),
  axiom (Vector.t A x) (veq A f x) v.
Proof.
move=> x px v H.
apply: axiomK.
  by apply: inj_v2l.
apply: list_eqOK.
by apply: vR2lR H.
Qed.
 

(* fgffff *)

have xH := axiomK _ _ _ _ (bij_l2v A). (list_eqOK A f _ _).
 apply: list_eqOK.

Definition veqSig A fA (v1 : { n : nat & Vector.t A n}) (v2 : { m : nat & Vector.t A m }) : bool :=
  match v1, v2 with
  | existT _ a pa, existT _ b pb =>
      nat_eq a b && veq A fA a b pa pb
  end.

Axiom nat_eqOK : forall x, axiom nat nat_eq x.

Lemma veqSigOK A fA x v :
  axiom (Vector.t A x) (veq A fA x x) v -> axiom ({ n : nat & Vector.t A n}) (veqSig A fA) (existT _ x v).
Proof.
move=> Hxx [y w]; rewrite /veqSig.
case: (nat_eqOK x y) w => [<- w|??]; last by constructor 2 => /projT1_eq.
case: Hxx => [->| Evw]; first by constructor 1.
constructor 2 => Esig; have H := Eqdep_dec.inj_pair2_eq_dec _ _ _ _ _ _ Esig.
by apply/Evw/H=> i j; case: (nat_eqOK i j); [ left | right ].
Qed.

Lemma veqSigOK1 A fA x v :
  axiom ({ n : nat & Vector.t A n}) (veqSig A fA) (existT _ x v) ->
  axiom (Vector.t A x) (veq A fA x x) v.
Proof.
move: x v.
apply: Vector.induction.
  move=> XX v2; have [] := XX (existT _ 0 v2).
  admit. admit.
move=> b j bs IH XX v2; have [] := XX (existT _ _ v2).

move=> Hsig v2.
case: (Hsig (existT _ x v2)).

move=> Hxx [y w]; rewrite /veqSig.
case: (nat_eqOK x y) w => [<- w|??]; last by constructor 2 => /projT1_eq.
case: Hxx => [->| Evw]; first by constructor 1.
constructor 2 => Esig; have H := Eqdep_dec.inj_pair2_eq_dec _ _ _ _ _ _ Esig.
by apply/Evw/H=> i j; case: (nat_eqOK i j); [ left | right ].
Qed.

Lemma veqOK A f : 
  forall x px v (HA : Vector.tR A (axiom A f) x px v),
  axiom (Vector.t A x) (veq A f x x) v.
Proof.
move=> x px v1 Hf v2; move: x v1 v2 px Hf.
apply: Vector.induction.
  move=> [|b j bs] _ _.
  by constructor 1.
  by constructor 2; apply: equal_idx.
move=> x m xs IH n [_ _|y j ys R Hf /=].
  by constructor 2; apply: equal_idx.
inversion Hf.
case: (X y); last first.
  move=> E; constructor 2. admit.
have nat_eqOK : forall x, axiom nat nat nat_eq x.
  admit.
case: (nat_eqOK m j); last first.
  move=> E; constructor 2. admit.
move=> ? ?.
Admitted.

End Test.

Check veqOK.


Search eq existT .
have := reflect_eqf_base (IH j ys Pn X0).


  case: {-3}_ _ {-}_ / Hf (eq_refl (Vector.cons A x m xs)) (eq_refl (S m)) => //.

    by constructor 2; apply: equal_idx.

refine match v2 with Vector.nil _ => _ | Vector.cons _ y n ys => _ end.
  by [].



 case. => [ [|//]| ]. x m xs IH mR pf ].



Lemma list_eqOK A f :
  forall x (HA : listR A (axiom A f) x),
  axiom (list A) (list_eq A f) x.
Proof.
move=> l; elim => [|x Px xs Pxs IH] [|y ys].
- constructor 1; reflexivity.
- constructor 2 => ?; discriminate.
- constructor 2 => ?; discriminate.
- apply: reflect_eqf_step2 (Px y) _.
  case: (Px y) => [p|np].
    case: _ / p; apply: reflect_eqf_base; first by apply: IH.
    by move=> ?? [->].
  by move=> ???? [->].
Qed.


(*
Lemma reflect_eqf_step3 A B C D
 (f : forall a : A, forall b : B a, C a b -> D) b1 b2 
x y z (w : B y) r (s : C y w) : 
   forall e : reflect (x = y) b1,
     (match e with
      | ReflectT _ e =>
            reflect (f x z r = 
                     f x (cast2 A B _ _ e w) (cast3 A B C _ _ e _ s)) b2
      | ReflectF _ abs =>
             forall x y z w r s, f x z r = f y w s -> x = y
     end) ->
      reflect (f x z r = f y w s) (b1 && b2).
Proof.
case=> e; first by case: _ / e w s.
by move=> inj; constructor=> /inj.
Qed.
*)

Axiom daemon : False.


Elpi Command derive.eqOK.
Elpi Accumulate Db derive.isK.db.
Elpi Accumulate File "ltac/discriminate.elpi".
Elpi Accumulate Db derive.param1.db.
Elpi Accumulate Db derive.param1P.db.
Elpi Accumulate Db derive.induction.db.
Elpi Accumulate Db derive.cast.db.
Elpi Accumulate File "derive/eqOK.elpi".
Elpi Accumulate "
  main [str I, str F] :- !,
    coq.locate I (indt GR),
    coq.locate F (const Cmp),
    derive.eqOK.main GR Cmp.
  main _ :- usage.

  usage :- coq.error ""Usage: derive.eqOK <inductive type name> <comparison function>"".
".
Elpi Typecheck.
 
(*
Elpi derive.param1 prod.
Elpi derive.param1 list.
Elpi derive.param1 nat.
Elpi derive.param1P prodR.
Elpi derive.param1P listR.
Elpi derive.param1P natR.
Elpi derive.map prodR.
Elpi derive.map listR.

Elpi derive.induction nat.
Elpi derive.induction bool.
Elpi derive.induction list.
Elpi derive.induction prod.

Elpi derive.eq list. 
Elpi derive.eq prod.
Elpi derive.eq bool.
Elpi derive.eq nat.

Elpi derive.isK bool.
Elpi derive.isK nat.
Elpi derive.isK list.
Elpi derive.isK prod.

Elpi derive.eqOK bool bool_eq.
Check bool_eqOK : forall x, axiom bool bool_eq x.

Elpi derive.eqOK nat nat_eq.
Check nat_eqOK : forall x, axiom nat nat_eq x.


Elpi derive.eqOK list list_eq.
Print list_eqOK.

*)

*)
