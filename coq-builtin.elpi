% This file is automatically generated from coq_elpi_builtin.ml
% See also coq-HOAS.elpi


% -- Printing (debugging) ---------------------------------------------

% [coq.say ...] Prints an info message
external type coq.say variadic any prop.

% [coq.warn ...] Prints a warning message
external type coq.warn variadic any prop.

% [coq.error ...] Prints and *aborts* the program (it's a fatal error)
external type coq.error variadic any prop.

% [coq.version VersionString Major Minor Patch] Fetches the version of Coq,
% as a string and as 3 numbers
external pred coq.version o:string, o:int, o:int, o:int.

% -- Nametab ----------------------------------------------------------

% [coq.locate Name TermFound] Locates a global term
external pred coq.locate i:string, o:gref.

% Name as input by the user, e.g. in the declaration of an inductive, the
% name
% of constructors are @id (since they matter to the user, e.g. they all
% must
% be distinct).

macro @id :- ctype "string".

% [coq.locate-module ModName ModPath] locates a module. *E*
external pred coq.locate-module i:@id, o:@modpath.

% [coq.locate-module-type ModName ModPath] locates a module. *E*
external pred coq.locate-module-type i:@id, o:@modtypath.

% -- Environment: read ------------------------------------------------

% global constant name
macro @constant :- ctype "constant".


% inductive type name
macro @inductive :- ctype "inductive".


% inductive constructor name
macro @constructor :- ctype "constructor".


% constants: inductive types, inductive constructors, definitions
kind gref type.
type const @constant -> gref. % Nat.add, List.append, ...
type indt @inductive -> gref. % nat, list, ...
type indc @constructor -> gref. % O, S, nil, cons, ...

% [coq.env.typeof-gr GR Ty] reads the type Ty of a (const GR, indt GR, indc
% GR)
external pred coq.env.typeof-gr i:gref, o:term.

% While constants, inductive type and inductive constructors do share the
% same data type for their names, namely @gref, the predicates named
% coq.env-{const,indt,indc} can only be used for objects of kind
% {const,indt,indc} respectively.

external pred coq.env.indt % reads the inductive type declaration for the environment
  i:@inductive, % reference to the inductive type
  o:bool,       % tt if the type is inductive (ff for co-inductive)
  o:int,        % number of parameters
  o:int,        % number of parameters that are uniform (<= parameters)
  o:term,       % type of the inductive type constructor including parameters
  o:list term,  % list of constructors like [ (indc "O"); (indc "S") ]
  o:list term.  % list of the types of the constructors (type of KNames)
  
% [coq.env.indc GR ParamNo UnifParamNo Kno Ty] reads the type Ty of an
% inductive constructor GR, as well as the number of parameters ParamNo and
% uniform parameters UnifParamNo and the number of the constructor Kno (0
% based)
external pred coq.env.indc i:@constructor, o:int, o:int, o:int, o:term.

% [coq.env.const-opaque? GR] checks if GR is an opaque constant
external pred coq.env.const-opaque? i:@constant.

% [coq.env.const GR Bo Ty] reads the type Ty and the body Bo of constant GR.
% Opaque constants have Bo = hole.
external pred coq.env.const i:@constant, o:term, o:term.

% [coq.env.const-body GR Bo] reads the body of a constant, even if it is
% opaque. If such body is hole, then the constant is a true axiom
external pred coq.env.const-body i:@constant, o:term.

% ModPath.t
macro @modpath :- ctype "modpath".


% ModTypePath.t
macro @modtypath :- ctype "modtypath".


% [coq.env.module MP Contents] lists the contents of a module (recurses on
% submodules) *E*
external pred coq.env.module i:@modpath, o:list gref.

% [coq.env.module-type MTP Entries] lists the items made visible by module
% type (does not recurse on submodules) *E*
external pred coq.env.module-type i:@modtypath, o:list @id.

% -- Environment: write -----------------------------------------------

% Note: universe constraints are taken from ELPI's constraints store. Use
% coq.univ-* in order to add constraints (or any higher level facility as
% coq.elaborate or of from engine/elaborator.elpi)

% [coq.env.add-const Name Bo Ty Opaque T] declare a new constant: T gets
% (const GR) for a new GR derived from Name and the current module; Type can
% be left unspecified and in that case the inferred one is taken (as in
% writing Definition x := t); Body can be unspecified and in that case an
% axiom is added
external pred coq.env.add-const i:@id, i:term, i:term, i:@opaque?, o:term.

% [coq.env.add-indt Decl I] Declares an inductive type
external pred coq.env.add-indt i:indt-decl, o:term.

% Interactive module construction

% [coq.env.begin-module Name ModTyPath] Starts a module, the modtype can be
% unspecified *E*
external pred coq.env.begin-module i:@id, i:@modtypath.

% [coq.env.end-module ModPath] end the current module that becomes known as
% ModPath *E*
external pred coq.env.end-module o:@modpath.

% [coq.env.begin-module-type Name] Starts a module type *E*
external pred coq.env.begin-module-type i:@id.

% [coq.env.end-module-type ModTyPath] end the current module type that
% becomes known as ModPath *E*
external pred coq.env.end-module-type o:@modtypath.

% [coq.env.include-module ModPath] is like the vernacular Include *E*
external pred coq.env.include-module i:@modpath.

% [coq.env.include-module-type ModTyPath] is like the vernacular Include *E*
external pred coq.env.include-module-type i:@modtypath.

% -- Universes --------------------------------------------------------

% Univ.Universe.t
macro @univ :- ctype "univ".


% Universes (for the sort term former)
kind universe type.
type prop universe. % impredicative sort of propositions
type sprop universe. % impredicative sort of propositions with definitional proof irrelevance
type typ @univ -> universe. % predicative sort of data (carries a level)

% [coq.univ.print-constraints] prints the set of universe constraints
external pred coq.univ.print-constraints .

% [coq.univ.leq U1 U2] constrains U1 <= U2
external pred coq.univ.leq o:@univ, o:@univ.

% [coq.univ.eq U1 U2] constrains U1 = U2
external pred coq.univ.eq o:@univ, o:@univ.

% [coq.univ.new Names U] fresh universe *E*
external pred coq.univ.new i:list @id, o:@univ.

% [coq.univ.sup U1 U2] constrains U2 = U1 + 1
external pred coq.univ.sup o:@univ, o:@univ.

% [coq.univ.max U1 U2 U3] constrains U3 = max U1 U2
external pred coq.univ.max o:@univ, o:@univ, o:@univ.

% Very low level, don't use

% [coq.univ.algebraic-max U1 U2 U3] constrains U3 = Max(U1,U2) *E*
external pred coq.univ.algebraic-max o:@univ, o:@univ, o:@univ.

% [coq.univ.algebraic-sup U1 U2] constrains U2 = Sup(U1) *E*
external pred coq.univ.algebraic-sup o:@univ, o:@univ.

% -- Databases (TC, CS, Coercions) ------------------------------------

% Pattern for canonical values
kind cs-pattern type.
type cs-gref gref -> cs-pattern.
type cs-prod cs-pattern.
type cs-default cs-pattern.
type cs-sort universe -> cs-pattern.

% Canonical Structure instances: (cs-instance Proj ValPat Inst)
kind cs-instance type.
type cs-instance gref -> cs-pattern -> term -> cs-instance.

% [coq.CS.declare-instance GR] declares GR as a canonical structure instance
external pred coq.CS.declare-instance i:gref.

% [coq.CS.db Db] reads all instances
external pred coq.CS.db o:list cs-instance.

% Type class instance with priority
kind tc-instance type.
type tc-instance gref -> int -> tc-instance.

% [coq.TC.declare-instance GR Priority Global] declare GR as a Global type
% class instance with Priority
external pred coq.TC.declare-instance i:gref, i:int, i:@global?.

% [coq.TC.db Db] reads all instances
external pred coq.TC.db o:list tc-instance.

% [coq.TC.db-for GR Db] reads all instances of the given class GR
external pred coq.TC.db-for i:gref, o:list tc-instance.

% [coq.TC.class? GR] checks if GR is a class
external pred coq.TC.class? i:gref.

% Node of the coercion graph
kind class type.
type funclass class.
type sortclass class.
type grefclass gref -> class.

% Edge of the coercion graph
kind coercion type.
type coercion gref -> int -> class -> class -> coercion.

% [coq.coercion.declare C Global] declares C = (coercion GR _ From To) as a
% coercion From >-> To. 
external pred coq.coercion.declare i:coercion, i:@global?.

% [coq.coercion.db L] reads all declared coercions
external pred coq.coercion.db o:list coercion.

% [coq.coercion.db-for From To L] reads all declared coercions
external pred coq.coercion.db-for i:class, i:class, 
                                  o:list (pair gref int).

% -- Coq's pretyper ---------------------------------------------------

% [coq.sigma.print] Prints Coq's Evarmap and the mapping to/from Elpi's
% unification variables
external pred coq.sigma.print .

% [coq.typecheck T Ty] typchecks a closed term (no holes, no context). This
% limitation shall be lifted in the future. Inferred universe constraints
% are put in the constraint store
external pred coq.typecheck i:term, o:term.

% [coq.elaborate T E ETy] elabotares terms that can contain "hole".  It is
% able to work in a proof and hypothetical context, as long as all bound
% variables are accompanied by a decl or def hypothesis. Limitation: the
% resulting term has to be evar free (no unresolved holes), shall be lifted
% in the future
external pred coq.elaborate i:term, o:term, o:term.

% -- Coq's tactics --------------------------------------------

% [coq.ltac1.call Tac Args G GL] Calls Ltac1 tactic named Tac with arguments
% Args on goal G
external pred coq.ltac1.call i:string, i:list term, i:goal, o:list goal.

% -- Datatypes conversions --------------------------------------------

% Name.Name.t: Name hints (in binders), can be input writing a name
% between backticks, e.g. `x` or `_` for anonymous. Important: these are
% just printing hints with no meaning, hence in elpi two @name are always
% related: `x` = `y`
macro @name :- ctype "name".


% [coq.name-suffix Name Suffix NameSuffix] suffixes a Name with a string or
% an int or another name
external pred coq.name-suffix i:@name, i:any, o:@name.

% [coq.string->name Hint Name] creates a name hint
external pred coq.string->name i:string, o:@name.

% [coq.gr->id GR Id] extracts the label (last component of a full kernel
% name). Accepts also as @id in input, in this case it is the identity
external pred coq.gr->id i:gref, o:@id.

% [coq.gr->string GR FullPath] extract the full kernel name. GR can be a
% @gref or @id
external pred coq.gr->string i:gref, o:string.

% [coq.term->string T S] prints a term T to a string S using Coq's pretty
% printer
external pred coq.term->string i:term, o:string.

% -- Access to Elpi's data --------------------------------------------

% clauses
% 
% A clause like
%   :name "foo" :before "bar" foo X Y :- bar X Z, baz Z Y
% is represented as
%   clause "foo" (before "bar") (pi x y z\ foo x y :- bar x z, baz z y)
% that is exactly what one would load in the context using =>.
%           
% The name and the grafting specification can be left unspecified.
kind clause type.
type clause @id -> grafting -> prop -> clause.

kind grafting type.
type before @id -> grafting.
type after @id -> grafting.

% [coq.elpi.accumulate DbName Clause] Declare that, once the program is
% over, the given clause has to be added to the given db (see Elpi Db)
external pred coq.elpi.accumulate i:@id, i:clause.

%  == I/O builtins =====================================

%  -- I/O --

macro @in_stream :- ctype "in_stream".

type std_in @in_stream.

macro @out_stream :- ctype "out_stream".

type std_out @out_stream.
type std_err @out_stream.

% [open_in FileName InStream] opens FileName for input
external pred open_in i:string, o:@in_stream.

% [open_out FileName OutStream] opens FileName for output
external pred open_out i:string, o:@out_stream.

% [open_append FileName OutStream] opens FileName for output in append mode
external pred open_append i:string, o:@out_stream.

% [close_in InStream] closes input stream InStream
external pred close_in i:@in_stream.

% [close_out OutStream] closes output stream OutStream
external pred close_out i:@out_stream.

% [output OutStream Data] writes Data to OutStream
external pred output i:@out_stream, i:string.

% [flush OutStream] flush all output not yet finalized to OutStream
external pred flush i:@out_stream.

% [input InStream Bytes Data] reads Bytes from InStream
external pred input i:@in_stream, i:int, o:string.

% [input_line InStream Line] reads a full line from InStream
external pred input_line i:@in_stream, o:string.

% [eof InStream] checks if no more data can be read from InStream
external pred eof i:@in_stream.

%  -- System --

% [gettimeofday T] sets T to the number of seconds elapsed since 1/1/1970
external pred gettimeofday o:float.

% [getenv VarName Value] Like Sys.getenv
external pred getenv i:string, o:option string.

% [system Command RetVal] executes Command and sets RetVal to the exit code
external pred system i:string, o:int.

%  -- Debugging --

% [term_to_string T S] prints T to S
external pred term_to_string i:any, o:string.

% == Elpi builtins =====================================

% [dprint ...] prints raw terms (debugging)
external type dprint variadic any prop.

% [print ...] prints terms
external type print variadic any prop.

% [counter Name Value] reads the Value of a trace point Name
external pred counter i:string, o:int.

% [rex_match Rex Subject] checks if Subject matches Rex. Matching is based
% on OCaml's Str library
external pred rex_match i:string, i:string.

% [rex_replace Rex Replacement Subject Out] Out is obtained by replacing all
% occurrences of Rex with Replacement in Subject. See also OCaml's
% Str.global_replace
external pred rex_replace i:string, i:string, i:string, o:string.

% [quote_syntax FileName QueryText QuotedProgram QuotedQuery] quotes the
% program from FileName and the QueryText. See elpi-quoted_syntax.elpi for
% the syntax tree
external pred quote_syntax i:string, i:string, o:list A, o:A.

% == Elpi nonlogical builtins =====================================

% Opaque ML data types
kind ctype type.
type ctype string -> ctype.

% [var any term] checks if the term is a variable
external pred var i:any.

% [same_var first term second term] checks if the two terms are the same
% variable
external pred same_var i:A, i:A.

% [name T ...] checks if T is a eigenvariable. When used with tree arguments
% it relates an applied name with its head and argument list.
external type name any -> variadic any prop.

% [constant T ...] checks if T is a (global) constant.  When used with tree
% arguments it relates an applied constant with its head and argument list.
external type constant any -> variadic any prop.

external pred names % generates the list of eigenvariable
  o:list any. % list of eigenvariables in order of age (young first)
  
external pred occurs % checks if the constant occurs in the term
  i:A, % a constant (global or eigenvariable)
  i:A. % a term
  
% [closed_term T] unify T with a variable that has no eigenvariables in
% scope
external pred closed_term o:any.

% [is_cdata T Ctype] checks if T is primitive of type Ctype, eg (ctype
% "int")
external pred is_cdata i:any, o:ctype.

pred primitive? i:A, i:string.

primitive? X S :- is_cdata X (ctype S).

% [new_int N] unifies N with a different int every time it is called
external pred new_int o:int.

% Holds data across bracktracking
macro @safe :- ctype "safe".


% [new_safe Safe] creates a safe: a store that persists across backtracking
external pred new_safe o:@safe.

% [stash_in_safe Safe Data] stores Data in the Safe
external pred stash_in_safe i:@safe, i:any.

% [open_safe Safe Data] retrieves the Data stored in Safe
external pred open_safe i:@safe, o:list any.


% [if C T E] picks the first success of C then runs T (never E).
% if C has no success it runs E.
pred if i:prop, i:prop, i:prop.
if B T _ :- B, !, T.
if _ _ E :- E.  

% [random.init Seed] Initialize OCaml's PRNG with the given Seed
external pred random.init i:int.

% [random.self_init] Initialize OCaml's PRNG with some seed
external pred random.self_init .

% [random.int Bound N] unifies N with a random int between 0 and Bound
% (excluded)
external pred random.int i:int, o:int.



% == stdlib =======================================================

% Conventions:
% - all predicates declare a mode with some input arguments, unless...
% - predicates whose name ends with R are relations (work in any direction,
%   that is all arguments are in ouput mode)
% - predicates whose name ends with ! do contain a cut and generate only the
%   first result
% - all errors given by this library end up calling fatal-error[-w-data],
%   override it in order to handle them differently
% - all debug prints by this library end up calling debug-print, override it
%   in order to handle them differently

namespace std {

pred fatal-error i:string.
:name "default-fatal-error"
fatal-error Msg :- halt Msg.

pred fatal-error-w-data i:string, i:A.
:name "default-fatal-error-w-data"
fatal-error-w-data Msg Data :- halt Msg ":" Data.

pred debug-print i:string, i:A.
:name "default-debug-print"
debug-print Msg Data :- print Msg Data.

%  -- Errors, Debugging, Hacks --

pred ignore-failure! i:prop.
ignore-failure! P :- P, !.
ignore-failure! _.

% [assert! C M] takes the first success of C or fails with message M 
pred assert! i:prop, i:string.
assert! Cond Msg :- (Cond ; fatal-error-w-data Msg Cond), !.

% [spy P] traces the call to P, printing all success and the final failure
pred spy i:prop.
spy P :- counter "run" NR, if (not(NR = 0)) (debug-print "run=" NR) true,
         debug-print "----<<---- enter: " P,
         P,
         debug-print "---->>---- exit: " P.
spy P :- debug-print "---->>---- fail: " P, fail.

% [spy! P] traces the first call to P without leaving a choice point
pred spy! i:prop.
spy! P :- counter "run" NR, if (not(NR = 0)) (debug-print "run=" NR) true,
         debug-print "----<<---- enter: " P,
         P,
         debug-print "---->>---- exit: " P, !.
spy! P :- debug-print "---->>---- fail: " P, fail.

% to silence the type checker
pred unsafe-cast o:A, o:B.
unsafe-cast X X.

% -- List processing --

pred length i:list A, o:int.
length [_|L] N :- length L N1, N is N1 + 1.
length []    0.

pred rev i:list A, o:list A.
rev L RL  :- rev.aux L []  RL.
rev.aux [X|XS] ACC R :- rev.aux XS [X|ACC] R.
rev.aux [] L L.

pred last i:list A, o:A.
last [] _ :- fatal-error "last on empty list".
last [X] X :- !.
last [_|XS] R :- last XS R.

pred append i:list A, i:list A, o:list A.
append [X|XS] L [X|L1] :- append XS L L1 .
append [] L L .

pred appendR o:list A, o:list A, o:list A.
appendR [X|XS] L [X|L1] :- appendR XS L L1 .
appendR [] L L .

pred take i:int, i:list A, o:list A.
take 0 _ [] :- !.
take N [X|XS] [X|L] :- !, N1 is N - 1, take N1 XS L.
take _ _ _ :- fatal-error "take run out of list items".

pred drop i:int, i:list A, o:list A.
drop 0 L L :- !.
drop N [_|XS] L :- !, N1 is N - 1, drop N1 XS L.
drop _ _ _ :- fatal-error "drop run out of list items".

pred drop-last i:int, i:list A, o:list A.
drop-last N L R :-
  length L M, I is M - N, take I L R.

pred split-at i:int, i:list A, o:list A, o:list A.
split-at 0 L [] L :- !.
split-at N [X|XS] [X|LN] LM :- !, N1 is N - 1, split-at N1 XS LN LM.
split-at _ _ _ _ :- fatal-error "split-at run out of list items".

pred fold i:list B, i:A, i:(B -> A -> A -> prop), o:A.
fold [] A _ A.
fold [X|XS] A F R :- F X A A1, fold XS A1 F R.

pred fold2 i:list C, i:list B, i:A, i:(C -> B -> A -> A -> prop), o:A.
fold2 [] [_|_] _ _ _ :- fatal-error "fold2 on lists of different length".
fold2 [_|_] [] _ _ _ :- fatal-error "fold2 on lists of different length".
fold2 [] [] A _ A.
fold2 [X|XS] [Y|YS] A F R :- F X Y A A1, fold2 XS YS A1 F R.

pred map i:list A, i:(A -> B -> prop), o:list B.
map [] _ [].
map [X|XS] F [Y|YS] :- F X Y, map XS F YS.

pred map-i i:list A, i:(int -> A -> B -> prop), o:list B.
map-i L F R :- map-i.aux L 0 F R.
map-i.aux [] _ _ [].
map-i.aux [X|XS] N F [Y|YS] :- F N X Y, M is N + 1, map-i.aux XS M F YS.

:index(1 1)
pred map2 i:list A, i:list B, i:(A -> B -> C -> prop), o:list C.
map2 [] [_|_] _ _ :- fatal-error "map2 on lists of different length".
map2 [_|_] [] _ _ :- fatal-error "map2 on lists of different length".
map2 [] [] _ [].
map2 [X|XS] [Y|YS] F [Z|ZS] :- F X Y Z, map2 XS YS F ZS.

pred map2_filter i:list A, i:list B, i:(A -> B -> C -> prop), o:list C.
map2_filter [] [_|_] _ _ :- fatal-error "map2_filter on lists of different length".
map2_filter [_|_] [] _ _ :- fatal-error "map2_filter on lists of different length".
map2_filter [] [] _ [].
map2_filter [X|XS] [Y|YS] F [Z|ZS] :- F X Y Z, !, map2_filter XS YS F ZS.
map2_filter [_|XS] [_|YS] F ZS :- map2_filter XS YS F ZS.

% [nth N L X] picks in X the N-th element of L (L must be of length > N)
pred nth i:int, i:list A, o:A.
nth 0 [X|_] X :- !.
nth N [_|XS] R :- !, N1 is N - 1, nth N1 XS R.
nth _ _ _ :- fatal-error "nth run out of list items".

% [lookup L K V] sees L as a map from K to V
pred lookup i:list (pair A B), i:A, o:B.
lookup [pr X Y|_] X Y.
lookup [_|LS]       X Y :- lookup LS X Y.

% [lookup! L K V] sees L as a map from K to V, stops at the first binding
pred lookup! i:list (pair A B), i:A, o:B.
lookup! [pr X Y|_] X Y :- !.
lookup! [_|LS]       X Y :- lookup! LS X Y.

% [mem! L X] succeeds once if X occurs inside L 
pred mem! i:list A, o:A.
mem! [X|_] X :- !.
mem! [_|L] X :- mem! L X.

% [mem L X] succeeds every time if X occurs inside L 
pred mem i:list A, o:A.
mem [X|_] X.
mem [_|L] X :- mem L X.


pred exists i:list A, i:(A -> prop).
exists [X|_] P :- P X.
exists [_|L] P :- exists L P.

pred exists2 i:list A, i:list B, i:(A -> B -> prop).
exists2 [] [_|_] _ :- fatal-error "exists2 on lists of different length".
exists2 [_|_] [] _ :- fatal-error "exists2 on lists of different length".
exists2 [X|_] [Y|_] P :- P X Y.
exists2 [_|L] [_|M] P :- exists2 L M P.

pred forall i:list A, i:(A -> prop).
forall [] _.
forall [X|L] P :- P X, forall L P.

pred forall2 i:list A, i:list B, i:(A -> B -> prop).
forall2 [] [_|_] _ :- fatal-error "forall2 on lists of different length".
forall2 [_|_] [] _ :- fatal-error "forall2 on lists of different length".
forall2 [X|XS] [Y|YS] P :- P X Y, forall2 XS YS P.
forall2 [] [] _.

pred filter i:list A, i:(A -> prop), o:list A.
filter []    _ [].
filter [X|L] P R :- if (P X) (R = X :: L1) (R = L1), filter L P L1.

pred zip i:list A, i:list B, o:list (pair A B).
zip [_|_] [] _ :- fatal-error "zip on lists of different length".
zip [] [_|_] _ :- fatal-error "zip on lists of different length".
zip [X|LX] [Y|LY] [pr X Y|LR] :- zip LX LY LR.
zip [] [] [].

pred unzip i:list (pair A B), o:list A, o:list B.
unzip [] [] [].
unzip [pr X Y|L] [X|LX] [Y|LY] :- unzip L LX LY.

pred flatten i:list (list A), o:list A.
flatten [X|LS] R :- flatten LS LS', append X LS' R.
flatten []     [].

pred null i:list A.
null [].

pred iota i:int, o:list int.
iota N L :- iota.aux 0 N L.
iota.aux X X [] :- !.
iota.aux N X [N|R] :- M is N + 1, iota.aux M X R.

%  -- Misc --

pred flip i:(A -> B -> prop), i:B, i:A.
flip P X Y :- P Y X.

pred time i:prop, o:float.
time P T :- gettimeofday Before, P, gettimeofday After, T is After - Before.

pred do! i:list prop.
do! [].
do! [P|PS] :- P, !, do! PS.

pred spy-do! i:list prop.
spy-do! L :- map L (x\y\y = spy x) L1, do! L1.

pred any->string i:A, o:string.
any->string X Y :- term_to_string X Y.

} % namespace std 




