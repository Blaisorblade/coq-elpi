/* coq-elpi: Coq terms as the object language of elpi                        */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

accumulate lp-lib.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coq's terms
%
% Types of term formers, to be kept in sync with HOAS embedding in
% coq_elpi_HOAS.ml
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Data types that are opaque to LP: cannot be manipulated directly
macro @gref :- ctype "Globnames.global_reference". % name for a global constant
macro @univ :- ctype "Univ.Universe.t".            % universes
macro @name :- ctype "Name.t".                     % name hint (compare as =)

% Universes (for the "sort" term former)
kind universe type.
type prop universe.          % impredicative sort of propositions
type typ  @univ -> universe. % predicative sort of datatypes (carries a level)

% -- terms ------------------------------------------------------------------
kind term type.

type sort  universe -> term. % Prop, Type@{i}

% constants: inductive types, inductive constructors, definitions
type indt  @gref -> term. % nat, list, ...
type indc  @gref -> term. % O, S, nil, cons, ...
type const @gref -> term. % Nat.add, List.append, ...

% binders: to form functions, arities and local definitions
type lam  @name -> term -> (term -> term) -> term.         % fun x : t =>
type prod @name -> term -> (term -> term) -> term.         % forall x : t,
type let  @name -> term -> term -> (term -> term) -> term. % let x := v : T in

% other term formers: function application, pattern matching and recursion
type app   list term -> term.                   % app [hd|args]
type match term -> term -> list term -> term.   % match t p [branch])
type fix   @name -> int -> term -> (term -> term) -> term. % fix name rno ty bo

% implicit argument
type hole  term.

% well, for Axioms
type axiom term.

% -- helpers -----------------------------------------------------------------
macro @cast T TY :- (let "cast" TY T x\x).

% the HOAS embedding accepts strings in place of @names.  These lines
% tell the type checker to accept strings too.
type lam  string -> term -> (term -> term) -> term.
type prod string -> term -> (term -> term) -> term.
type let  string -> term -> term -> (term -> term) -> term.
type fix  string -> int -> term -> (term -> term) -> term.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coq's evar_map
%
% To be kept in sync with HOAS embedding in coq_elpi_HOAS.ml
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% An evar_info 
%
% x : t
% y := v : x
% ----------
% p x y
%
% is coded as an elpi goal
% 
% pi x1\ coq-decl x1 "x" `t` => pi x2\ coq-def x2 "y" `v` Vn x1 =>
%   coq-declare-evar (Evar x1 x2) (`p` x1 x2)
%
% Conversely a remaining syntactic constraint
%
% coq-decl x1 "x" `t`, coq-def x2 "y" `v` `vn` x1 ?-
%   coq-evar (Evar x1 x2) (`p` x1 x2)
%
% is read back as the evar_info above.
%
% The client is supposed to implement coq-declare-evar. E.g.
%
%   coq-declare-evar X T :- coq-evar X T.
%
% Of course the client can do any additional work at evar declaration time,
% for example impose an additional constraint of well-typedness or augment.

pred coq-decl i:term, o:@name, o:term. % Var Name Ty
pred coq-def  i:term, o:@name, o:term, o:term, o:term. % Var Name Bo BoNorm Ty
pred coq-declare-evar i:term, i:term. % Evar Ty

constraint coq-evar coq-def coq-decl { }
pred coq-evar i:term, i:term. % Evar Ty
coq-evar (?? as X) T :- !, $constraint (coq-evar X T) [X].
coq-evar _ _. % volatile, only unresolved evars are considered as evars

coq-evd-print :- $print_constraints.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coq's tactic invocation
%
% To be kept in sync with HOAS embedding in coq_elpi_HOAS.ml
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

kind goal-attribute type.
kind goal type.

type goal-name @name -> goal-attribute.
type goal term -> term -> list goal-attribute -> goal.

pred solve i:list goal.
pred coq-declare-goal i:term, i:term, i:(term -> term -> prop). % Evar Ty Goal

% The entry point of a tactic is
%
%  solve [goal Solution Type Attributes]
%
% Note: currently the goal list is always of length 1
%
% The client is supposed to implement coq-declare-goal. E.g.
%
%   coq-declare-goal X T G :- coq-evar X T, G X T.
%
% Of course the client can do any additional work at goal declaration time, eg:
%
%   coq-declare-goal X T G :- coq-evar X T, G Y T, check-good-solution Y T X.
%
% where check-good-solution eventually rejects bad Y; sets X=Y otherwise.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coq's API
%
% Types of term formers, to be kept in sync with coq_elpi_API.ml
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred coq-say i:A.
coq-say X :- $coq-say X.

pred coq-warn i:string.
coq-warn X :- $coq-warn X.

pred coq-locate i:string, o:term.
coq-locate Name Term :- $coq-locate Name Term.

pred coq-env-const i:@gref, o:term, o:term.
coq-env-const Name Bo Ty :- $coq-env-const Name Bo Ty.

pred coq-env-indt i:@gref, o:bool, o:int, o:int, o:term, o:list term, o:list term.
coq-env-indt Name IsInd Lno Luno Ty Knames Ktypes :-
  $coq-env-indt Name IsInd Lno Luno Ty Knames Ktypes.

pred coq-env-indc i:@gref, o:int, o:int, o:term.
coq-env-indc Name Lno Kno Ty :- $coq-env-indc Name Lno Kno Ty.

% universe constraints are taken from ELPI's constraints store (see elaborate)
pred coq-env-add-const i:string, i:term, i:term, o:term.
coq-env-add-const Name BO TY GR :- $coq-env-add-const Name BO TY GR.

kind indt-decl type.
kind indc-decl type.
type parameter    @name -> term -> (term -> indt-decl) -> indt-decl.
type inductive    @name -> term -> (term -> list indc-decl) -> indt-decl.
type coinductive  @name -> term -> (term -> list indc-decl) -> indt-decl.
type constructor  @name -> term -> indc-decl.

type parameter   string -> term -> (term -> indt-decl) -> indt-decl.
type inductive   string -> term -> (term -> list indc-decl) -> indt-decl.
type coinductive string -> term -> (term -> list indc-decl) -> indt-decl.
type constructor string -> term -> indc-decl.

pred coq-env-add-indt i:indt-decl, o:term.
coq-env-add-indt Decl GR :- $coq-env-add-indt Decl GR.

pred coq-env-indt->decl
  i:term, i:int, i:term, i:list term, i:list term, o:indt-decl.
coq-env-indt->decl Arity 0 (indt GR as Iname) Kns Ktys (inductive I Arity Ks) :- !,
  coq-string->name {coq-gr->string GR} I,
  pi i\
    map2 Kns Ktys (name\ ty\ res\
      sigma tmp grk s\
      (copy Iname i :- !) => copy ty tmp,
      name = indc grk,
      coq-gr->string grk s,
      res = constructor s tmp)
    (Ks i).
coq-env-indt->decl (prod N S T) Lno Iname Kns Ktys (parameter N S Res) :- !,
  Lno > 0, Lno1 is Lno - 1,
  pi p\
    map Ktys (ty\res\sigma b n\whd-prod ty (prod n S b), res = b p) (Ktys1 p),
    coq-env-indt->decl (T p) Lno1 Iname Kns (Ktys1 p) (Res p).
coq-env-indt->decl T Lno Iname Kns Ktys Idecl :-
  whd-prod T T1, coq-env-indt->decl T1 Lno Iname Kns Ktys Idecl.

% R is a (prod _ _ _) obtained by putting T in whnf
whd-prod T R :-
  whd T [] HD S, unwind HD S R,
  assert (R = prod _ _ _) "coq-env-indt->decl: Lno > #products(arity)".

pred coq-TC-declare-instance i:@gref, i:int, i:bool.
coq-TC-declare-instance GR Precedence Global? :-
  $coq-TC-declare-instance GR Precedence Global?.

pred coq-CS-declare-instance i:@gref.
coq-CS-declare-instance GR :- $coq-CS-declare-instance GR.

kind canonical type.
type canonical term -> term -> term -> canonical. % Proj, Value, Instance

pred coq-CS-db o:list canonical.
coq-CS-db L :- $coq-CS-db L.

kind instance type.
type instance term -> int -> instance. % Value, Priority

pred coq-TC-db o:list instance.
coq-TC-db L :- $coq-TC-db L.

pred coq-TC-db-for i:@gref, o:list instance.
coq-TC-db-for GR L :- $coq-TC-db-for GR L.

pred coq-TC-is-class i:@gref.
coq-TC-is-class GR :- $coq-TC-is-class GR.

% To can (also) be {{ _ -> _ }} or {{ Type }} for Funclass or Sortclass
pred coq-coercion-declare i:@gref, i:term, i:term, i:bool.
coq-coercion-declare GR From To Global? :-
  $coq-coercion-declare GR From To Global?.

pred coq-typecheck i:term, o:term.
coq-typecheck Bo Ty :- $coq-typecheck Bo Ty.

% adds Coq's universe constraints to ELPI's constraints store.
% call this before adding anything to the env, on both body and type.
pred coq-elaborate i:term, o:term, o:term.
coq-elaborate Bo Bo1 Ty1 :- $coq-elaborate Bo Bo1 Ty1.

pred coq-env-typeof-gr i:@gref, o:term.
coq-env-typeof-gr GR TY :- $coq-env-typeof-gr GR TY.

pred coq-error i:string.
coq-err Msg :- $coq-error Msg.

pred coq-gr->string i:@gref, o:string.
pred coq-gr->string i:string, o:string.
coq-gr->string GR S :- $coq-gr->string GR S.

pred coq-string->name i:string, o:@name.
coq-string->name S N :- $coq-string->name S N.

pred coq-name->string i:@name, o:string.
coq-name->string S N :- $coq-name->string S N.

type coq-univ-print-constraints prop.
coq-univ-print-constraints :- $coq-univ-print-constraints.

pred coq-univ-max i:@univ, i:@univ, o:@univ.
coq-univ-max U1 U2 M :- $coq-univ-max U1 U2 M.

pred coq-univ-sup i:@univ, o:@univ.
coq-univ-sup U S :- $coq-univ-sup U S.

pred coq-univ-new i:list @name, o:@univ.
coq-univ-new L U :- $coq-univ-new L U.

pred coq-univ-leq i:@univ, i:@univ.
coq-univ-leq U1 U2 :- $coq-univ-leq U1 U2.

pred coq-univ-eq i:@univ, i:@univ.
coq-univ-eq U1 U2 :- $coq-univ-eq U1 U2.

% -- helpers -----------------------------------------------------------------
pred coq-env-unfolds? i:term.
coq-env-unfolds? (const GR) :- coq-env-const GR BO _, not(BO = axiom).

% -- override printing function in lp-lib ------------------------------------
:before "default-fatal-error"
fatal-error Msg :- !, M is "elpi: " ^ Msg, coq-err M.

type debug-print string -> A -> prop.
:before "default-debug-print"
debug-print Msg Data :- !, M is "elpi: " ^ Msg, $coq-say M Data.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Best effort pretty printer using the name hints
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pred pp i:A, o:B.

macro @pp X N :- (pp X N :- !).

pp (app L) L1 :- !, pp-list L L1.
pp (prod N T F) (prod N T1 F1) :- !,
  pp T T1, pi x\ @pp x N => pp (F x) F1.
pp (lam N T F) (lam N T1 F1) :- !,
  pp T T1, pi x\ @pp x N => pp (F x) F1.
pp (let N T B F) (let N T1 B1 F1) :- !,
  pp T T1, pp B B1, pi x\ @pp x N => pp (F x) F1.
pp (fix N _R _T B) (fix N _ _ B1) :- !, pi f\ @pp f N => pp (B f) B1.
pp (match A _R B) (match A1 _ B1) :- !, pp A A1, pp-list B B1.
pp (indt KN) KN :- !.
pp (indc KN) KN :- !.
pp (const KN) KN :- !.
pp (sort prop) "Prop" :- !.
pp (sort _) "Type" :- !.
pp X X :- !.
pp _ "unprintable" :- !. % cannot fail

mode (pp-list i o).
pp-list [] [].
pp-list [X|XS] [Y|YS] :- !, pp X Y, pp-list XS YS.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Term surgery
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred  subst-prod i:list term, i:term, o:term.
subst-prod [] P P.
subst-prod [X|XS] (prod _ _ F) P :- subst-prod XS (F X) P.

pred subst-lam i:list term, i:term, o:term.
subst-lam [] T T.
subst-lam [X|XS] (lam _ _ F) T :- subst-lam XS (F X) T.

type prod->lam term -> term -> prop.
prod->lam (prod N T F) (lam N T R) :- !, pi x\ prod->lam (F x) (R x).
prod->lam X X.

pred safe-dest-app i:term, o:term, o:list term.
safe-dest-app (app [X|XS]) X XS :- !.
safe-dest-app X X [].

pred mk-app i:term, i:list term, o:term.
mk-app HD [] HD :- !.
mk-app (app L) Args (app LArgs) :- !, append L Args LArgs.
mk-app (?? as K) [A|Args] R :- !, unsafe-cast K K', mk-app (K' A) Args R.
mk-app HD Args (app [HD|Args]).


pred copy i:term, o:term.
copy X Y :- $is_name X, X = Y, !. % avoid loading "copy x x" at binders
copy (const _ as C) C :- !.
copy (indc _ as C) C :- !.
copy (indt _ as C) C :- !.
copy (sort _ as C) C :- !.
copy (lam N T F) (lam N T1 F1) :- !,
  copy T T1, pi x\ copy (F x) (F1 x).
copy (let N T B F) (let N T1 B1 F1) :- !,
  copy T T1, copy B B1, pi x\ copy (F x) (F1 x).
copy (prod N T F) (prod N T1 F1) :- !,
  copy T T1, (pi x\ copy (F x) (F1 x)).
copy (app L) (app L1) :- !, map L copy L1.
copy (fix N Rno Ty F) (fix N Rno Ty1 F1) :- !,
  copy Ty Ty1, pi x\ copy (F x) (F1 x).
copy (match T Rty B) (match T1 Rty1 B1) :- !,
  copy T T1, copy Rty Rty1, map B copy B1.
copy (?? M L) W :- map L copy L1, mk-app M L1 W.

% vim:set ft=lprolog spelllang=:

