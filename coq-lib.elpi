/* coq-elpi: Coq terms as the object language of elpi                        */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

accumulate lp-lib.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coq's terms
%
% Types of term formers, to be kept in sync with HOAS embedding in
% coq_elpi_HOAS.ml
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Data types that are opaque to LP: cannot be manipulated directly
macro @gref :- ctype "Globnames.global_reference". % name for a global constant
macro @univ :- ctype "Univ.Universe.t".            % universes
macro @name :- ctype "Name.t".                     % name hint (compare as =)
macro @id   :- string.                             % identifiers

% Universes (for the "sort" term former)
kind universe type.
type prop universe.          % impredicative sort of propositions
type typ  @univ -> universe. % predicative sort of datatypes (carries a level)

% -- terms ------------------------------------------------------------------
kind term type.

type sort  universe -> term. % Prop, Type@{i}

% constants: inductive types, inductive constructors, definitions
type indt  @gref -> term. % nat, list, ...
type indc  @gref -> term. % O, S, nil, cons, ...
type const @gref -> term. % Nat.add, List.append, ...

% binders: to form functions, arities and local definitions
type lam  @name -> term -> (term -> term) -> term.         % fun x : t =>
type prod @name -> term -> (term -> term) -> term.         % forall x : t,
type let  @name -> term -> term -> (term -> term) -> term. % let x := v : T in

% other term formers: function application, pattern matching and recursion
type app   list term -> term.                   % app [hd|args]
type match term -> term -> list term -> term.   % match t p [branch])
type fix   @name -> int -> term -> (term -> term) -> term. % fix name rno ty bo

% implicit argument (missing term)
type hole  term.

% -- helpers -----------------------------------------------------------------
macro @cast T TY :- (let `cast` TY T x\x).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coq's evar_map
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% An evar_info 
%
% x : t
% y := v : x
% ----------
% p x y
%
% is coded as an elpi goal
% 
% pi x1\ decl x1 "x" `t` => pi x2\ def x2 "y" `v` Vn x1 =>
%   declare-evar
%      [decl x1 "x" `t`, def x2 "y" `v` Vn x1] (Evar x1 x2) (`p` x1 x2)
%
% where, by default, declare-evar creates a syntactic constraint as
%
%   decl x1 "x" `t`, def x2 "y" `v` `vn` x1 ?-  evar (Evar x1 x2) (`p` x1 x2)
%   
% When the program is over, a remaining syntactic constraint like the one above
% is read back and transformed into the corresponding evar_info.
%
% The client may want to provide an alternative implementation of
% declare-evar that, for example, typechecks the term assigned to Evar.

pred decl i:term, o:@name, o:term. % Var Name Ty
pred def  i:term, o:@name, o:term, o:term, o:term. % Var Name Bo BoNorm Ty
pred declare-evar i:list prop, i:term, i:term. % Ctx Evar Ty
:name "default-declare-evar"
declare-evar Ctx Ev Ty :- evar Ev Ty Ev.

constraint evar def decl pp read-evar { }
pred evar i:term, i:term, o:term. % Evar Ty RefinedSolution
evar (?? as X) T  S :- !, declare_constraint (evar X T S) [X].
:name "default-assign-evar"
evar _ _ _. % volatile, only unresolved evars are considered as evars

coq-evd-print :- print_constraints.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coq's tactic invocation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

kind extra-info type.

macro @goal-ctx :- list prop. % only decl and def entries

kind goal type.
type goal @goal-ctx -> term -> term -> list extra-info -> goal.

kind tactic-argument type.
type str string -> tactic-argument.
type trm term -> tactic-argument.

pred solve i:list goal, i:list tactic-argument.

% The entry point of a tactic is
%
%  solve [goal Ctx Solution Ty ExtraInfo]
%
% where Ctx is a list of decl or def and Solution is a unification variable
% to be assigned to a term of type Ty in order to make progress.
% ExtraInfo contains
% a list of "extra logical" data attached to the goal.
%
% Note: currently the goal list is always of length 1 and the ExtraInfo list
% is empty.
%
% The invocation of a tactic on a goal like
%
% x : t
% y := v : x
% ----------
% g x y
%
% is coded as an elpi goal
% 
% pi x1\ decl x1 "x" `t` => pi x2\ def x2 "y" `v` Vn x1 => sigma GoalEvar\
%   declare-goal-evar
%      [decl x1 "x" `t`, def x2 "y" `v` Vn x1]
%      (Evar x1 x2) (`g` x1 x2) GoalEvar,
%   solve
%     [goal
%        [decl x1 "x" `t`, def x2 "y" `v` Vn x1]
%        GoalEvar (`g` x1 x2) []]
%
% If the goal sequent contains other evars, then a tactic invocation is
% an elpi query made of the conjunction of all the declare-evar queries
% corresponding to these evars and the query corresponding to the goal
% sequent.
% As for declare-evar, also declare-goal-evar can be re-implemented
% by the client, for example by making Evar take the result of elaborating
% the term assigned to GoalEvar.

pred declare-goal-evar i:list prop, i:term, i:term, o:term. % Ctx Evar Ty GEvar
:name "default-declare-goal-evar"
declare-goal-evar Ctx Ev Ty Ev :- declare-evar Ctx Ev Ty.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coq's API
%
% To be kept in sync with coq_elpi_API.ml
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

external type coq-say variadic any prop.

external type coq-warn variadic any prop.

% Prints and *aborts* the program. LP's fatal-error uses this one
external type coq-error variadic any prop.

% Nametab %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

external pred coq-locate i:string, o:term.

macro @modpath :- ctype "ModPath.t".
external pred coq-locate-module i:string, o:@modpath.

macro @modtypath :- ctype "ModTypePath.t".
external pred coq-locate-module-type i:string, o:@modtypath.

% Environment: read %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

external pred coq-env-const i:@gref, o:term, o:term.

external pred coq-env-indt i:@gref, o:bool, o:int, o:int, o:term, o:list term, o:list term.

external pred coq-env-indc i:@gref, o:int, o:int, o:term.

external pred coq-env-module i:@modpath, o:list term.

external pred coq-env-module-type i:@modtypath, o:list string.

external pred coq-env-typeof-gr i:@gref, o:term.

% Environment: write %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Note: universe constraints are taken from ELPI's constraints
% store. Use coq-univ-* and coq-elaborate to add constraints.

external pred coq-env-add-const i:string, i:term, i:term, o:term.

kind indt-decl type.
kind indc-decl type.
kind attribute type.
type coercion attribute.
macro @attrs :- list attribute. 

type parameter   @name -> term -> (term -> indt-decl) -> indt-decl.
type inductive   @id -> term -> (term -> list indc-decl) -> indt-decl.
type coinductive @id -> term -> (term -> list indc-decl) -> indt-decl.
type constructor @id -> term -> indc-decl.
type record      @id -> term -> @id -> record-decl -> indt-decl.
type field       @attrs -> @id -> term -> (term -> record-decl) -> record-decl.
type end-record  record-decl.

external pred coq-env-add-indt i:indt-decl, o:term.

external pred coq-env-begin-module i:@id, i:@modtypath.

external pred coq-env-end-module o:@modpath.

external pred coq-env-begin-module-type i:@id.

external pred coq-env-end-module-type o:@modtypath.

external pred coq-env-include-module i:@modpath.

external pred coq-env-include-module-type i:@modtypath.

kind instance type.
type instance term -> int -> instance. % Value, Priority

external pred coq-univ-max i:@univ, i:@univ, o:@univ.

external pred coq-univ-sup i:@univ, o:@univ.

external pred coq-univ-new i:list @id, o:@univ.

external pred coq-univ-leq i:@univ, i:@univ.

external pred coq-univ-eq i:@univ, i:@univ.

external pred coq-univ-print-constraints.

% don't use
external pred coq-univ-algebraic-max i:@univ, i:@univ, o:@univ.
external pred coq-univ-algebraic-sup i:@univ, o:@univ.


% Databases (TC, CS, Coercions) %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Name, Precedence, Global?
external pred coq-TC-declare-instance i:@gref, i:int, i:bool.

external pred coq-CS-declare-instance i:@gref.

kind canonical type.
type canonical term -> term -> term -> canonical. % Proj, Value, Instance

external pred coq-CS-db o:list canonical.

kind instance type.
type instance term -> int -> instance. % Value, Priority

external pred coq-TC-db o:list instance.

external pred coq-TC-db-for i:@gref, o:list instance.

external pred coq-TC-is-class i:@gref.

% GR, From, To, Global?
% To can (also) be {{ _ -> _ }} or {{ Type }} for Funclass or Sortclass
external pred coq-coercion-declare i:@gref, i:term, i:term, i:bool.

% Coq's functionalities %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% typchecks a closed term (no holes, no context)
external pred coq-typecheck i:term, o:term.

% elabotares terms that can contain "hole".  It is able to work in
% a proof and hypothetical context, as long as all bound variables
% are accompained by a decl or def hypothesis.
% Limitation: theresulting term has to be evar free (no undersolved holes).
% Note: adds Coq's universe constraints to ELPI's constraints store.
% call this before adding anything to the env, on both body and type.
external pred coq-elaborate i:term, o:term, o:term.

% Datatypes conversions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% extracts the label
external pred coq-gr->id i:@gref, o:@id.
external pred coq-gr->id i:@id,   o:@id.

external pred coq-gr->string i:@gref, o:string.
external pred coq-gr->string i:@id,   o:string.

external pred coq-string->name i:string, o:@name.

% partial, fatal error if the name is "_"
external pred coq-name->id i:@name, o:@id.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Helpers
%
% Pure LP code that works with the data types and API above.
% Named clauses are natural extension points, eg one can extend
% subst-prod to perform reduction in order to expose a "prod" node.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred coq-env-unfolds? i:term.
coq-env-unfolds? (const GR) :- coq-env-const GR BO _, not(BO = hole).

:before "default-fatal-error"
fatal-error Msg :- !, M is "elpi: " ^ Msg, coq-error M.

:before "default-debug-print"
debug-print Msg Data :- !, M is "elpi: " ^ Msg, coq-say M Data.

% Best effort pretty printer (debugging) %%%%%%%%%%%%%%%%%%%%%%%%
pred pp i:A, o:B.

macro @pp X N :- (pp X N :- !).
pp (app L) L1 :- !, pp-list L L1.
pp (prod N T F) (prod N T1 F1) :- !,
  pp T T1, pi x\ @pp x N => pp (F x) F1.
pp (lam N T F) (lam N T1 F1) :- !,
  pp T T1, pi x\ @pp x N => pp (F x) F1.
pp (let N T B F) (let N T1 B1 F1) :- !,
  pp T T1, pp B B1, pi x\ @pp x N => pp (F x) F1.
pp (fix N _R _T B) (fix N _ _ B1) :- !, pi f\ @pp f N => pp (B f) B1.
pp (match A _R B) (match A1 _ B1) :- !, pp A A1, pp-list B B1.
pp (indt KN) KN :- !.
pp (indc KN) KN :- !.
pp (const KN) KN :- !.
pp (sort prop) "Prop" :- !.
pp (sort _) "Type" :- !.
pp X X :- !.
pp _ "unprintable" :- !. % cannot fail

mode (pp-list i o).
pp-list [] [].
pp-list [X|XS] [Y|YS] :- !, pp X Y, pp-list XS YS.

% Term surgery %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred  subst-prod i:list term, i:term, o:term.
subst-prod [] P P.
subst-prod [X|XS] (prod _ _ F) P :- !, subst-prod XS (F X) P.
:name "subst-prod:fail"
subst-prod [_|_] T _ :- !,
  fatal-error-w-data T "subst-prod: not a product".

pred subst-lam i:list term, i:term, o:term.
subst-lam [] T T.
subst-lam [X|XS] (lam _ _ F) T :- !, subst-lam XS (F X) T.
:name "subst-lam:fail"
subst-lam [_|_] T _ :- !, 
  fatal-error-w-data T "subst-lam: not a lambda".

type prod-R-lam term -> term -> prop.
prod-R-lam (prod N T F) (lam N T R) :- !, pi x\ prod-R-lam (F x) (R x).
prod-R-lam X X.
mode (prod-R-lam i o) xas prod->lam.

pred safe-dest-app i:term, o:term, o:list term.
safe-dest-app (app [X|XS]) X XS :- !.
safe-dest-app X X [].

pred mk-app i:term, i:list term, o:term.
mk-app HD [] HD :- !.
mk-app (app L) Args (app LArgs) :- !, append L Args LArgs.
mk-app (?? as K) [A|Args] R :- !, unsafe-cast K K', mk-app (K' A) Args R.
mk-app HD Args (app [HD|Args]).

% mk-eta n Ty T: performs up to n (when >= 0) eta expasion of T
% according to its type Ty. If n < 0 it makes as many step as
% products in Ty. There be dragons if T has not type Ty.
pred mk-eta i:int, i:term, i:term, o:term.
mk-eta 0 _ B B :- !.
mk-eta N (prod Name Ty P) (lam _ _ F) (lam Name Ty F1) :- !, N1 is N - 1,
  pi x \ mk-eta N1 (P x) (F x) (F1 x).
mk-eta N (prod Name Ty P) B           (lam Name Ty B1) :- !, N1 is N - 1,
  pi x \ mk-eta N1 (P x) {mk-app B [x]} (B1 x).
:name "mk-eta:end"
mk-eta _ _ B B :- !.

% copy can be used to perform a replacement, eg
%   (copy (const "foo") (const "bar) :- !) => copy T T1
% traverses T replacing foo with bar.
pred copy i:term, o:term.
copy X Y :- is_name X, !, X = Y, !. % avoid loading "copy x x" at binders
copy (const _ as C) C :- !.
copy (indc _ as C) C :- !.
copy (indt _ as C) C :- !.
copy (sort _ as C) C :- !.
copy (lam N T F) (lam N T1 F1) :- !,
  copy T T1, pi x\ copy (F x) (F1 x).
copy (let N T B F) (let N T1 B1 F1) :- !,
  copy T T1, copy B B1, pi x\ copy (F x) (F1 x).
copy (prod N T F) (prod N T1 F1) :- !,
  copy T T1, (pi x\ copy (F x) (F1 x)).
copy (app L) (app L1) :- !, map L copy L1.
copy (fix N Rno Ty F) (fix N Rno Ty1 F1) :- !,
  copy Ty Ty1, pi x\ copy (F x) (F1 x).
copy (match T Rty B) (match T1 Rty1 B1) :- !,
  copy T T1, copy Rty Rty1, map B copy B1.
copy (?? M L) W :- map L copy L1, mk-app M L1 W.

% bridges the gap between the data types used to read/write inductives
pred coq-env-indt->decl
  i:term, i:int, i:term, i:list term, i:list term, o:indt-decl.
coq-env-indt->decl Arity 0 (indt GR as Iname) Kns Ktys (inductive I Arity Ks) :- !,
  coq-gr->id GR I,
  pi i\
    map2 Kns Ktys (name\ ty\ res\
      sigma tmp grk s\
      (copy Iname i :- !) => copy ty tmp,
      name = indc grk,
      coq-gr->id grk s,
      res = constructor s tmp)
    (Ks i).

coq-env-indt->decl (prod N S T) Lno Iname Kns Ktys (parameter N S Res) :- !,
  Lno > 0, Lno1 is Lno - 1,
  pi p\
    map Ktys (subst-prod [p]) (Ktys1 p),
    coq-env-indt->decl (T p) Lno1 Iname Kns (Ktys1 p) (Res p).

:name "coq-env-indt->decl:fail"
coq-env-indt->decl _ _ _ _ _ _ :- !,
  fatal-error "coq-env-indt->decl: invalid declaration".

% extract @gref from terms that happen to have one
pred term->gr i:term, o:@gref.
term->gr (const GR) GR :- !.
term->gr (indt GR) GR :- !.
term->gr (indc GR) GR :- !.
:name "term->gr:fail"
term->gr Term _ :-
  fatal-error-w-data Term "term->gr: input has no global reference".

% with-TC Class Instance->Clause Code: runs Code under a context augmented with
% all instances for Class transformed by Instance->Clause.
pred with-TC i:term, i:(instance -> prop -> prop), i:prop.
with-TC Class Instance->Clause Code :-
  coq-TC-db-for {term->gr Class} Instances,
  map Instances Instance->Clause Hyps, !,
  Hyps => Code.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% vim:set ft=lprolog spelllang=:

