/* coq-elpi: Coq terms as the object language of elpi                        */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% extra typing declarations %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type indc string -> term.
type indt string -> term.
type $$=> list prop -> prop -> prop.
type $$* int -> int -> int.

%%%%%%%%%%%%%%%%%%%
% generic helpers %
%%%%%%%%%%%%%%%%%%%

mk-eta (prod N T P) B (lam N T B') :- !,
  (pi x \ mk-eta (P x) {subst-lam [x] B} (B' x)).
mk-eta P B B :- !.

mk-N-eta Nb Prod B (lam N T B') :- Nb > 0, !,
  Nb' is Nb - 1, !, unify-eq Prod (prod N T P), !,
  (pi x \ mk-N-eta Nb' (P x) {subst-lam [x] B} (B' x)).
mk-N-eta 0 _P B B :- !.

pred perm-op i:(string -> term -> (term -> term) -> term),
     i:(list A -> list A -> prop), i:int, i:term, o:term.
perm-op Op Perm Nb (Op N T B) (Op N' T' B') :- !,
  perm-op-aux Op Perm Nb (Op N T B) [] (Op N' T' B') [].

pred perm-op-aux i:(string -> term -> (term -> term) -> term),
     i:(list A -> list A -> prop), i:int,
     i:term, i:(list (pair (pair string term) term)),
     o:term, o:(list (pair (pair string term) term)).
%@log(perm-op-aux _ _ _ _ _ _ _).
perm-op-aux Op Perm Nb (Op N T B) Acc (Op N' T' B') Acc' :- Nb > 0, !,
  Nb' is Nb - 1,
  (pi x\
    perm-op-aux Op Perm Nb' (B x) [pr (pr N T) x|Acc] (B' x) (Acc'x x),
    Acc'x x = [pr (pr N' T') x|Acc']).
perm-op-aux _Op Perm 0 B Acc B' Acc'' :- !,
  Perm {rev Acc} RevAcc', rev RevAcc' Acc',
  % $coq-say "Acc=" Acc, $coq-say "Acc'=" Acc',
  map2 Acc Acc' (a\ a'\ res\ sigma X Y TX TY\
    a = pr TX X, a' = pr TY Y,
    res = (copy Y X :- !)) Rename,
  % $coq-say "Rename=" Rename,
  % $coq-say "B=" B,
  Rename => (
    copy B B',
    % $coq-say "B'=" B',
    map2 Acc Acc'
      (a\ a'\ res\ sigma X Y NX NY TX TY TY'\
      a = pr (pr NX TX) X, a' = pr (pr NY TY) Y,
      copy TY TY', res = pr (pr NY TY') X) Acc'').
  %$coq-say "Acc''=" Acc''


pred eta-perm i:(list A -> list A -> prop), i:int,
  i:term, i:term, o:term, o:term.
eta-perm Perm Nb P B P' B' :- !,
  mk-N-eta Nb P B EtaB, !,
  perm-op prod Perm Nb P P', !,
  perm-op lam Perm Nb EtaB B'.

pred let-perm i:(list A -> list A -> prop), i:int,
  i:string, i:term, i:term, o:((term -> term) -> term).
let-perm Perm Nb Name Ty X (let Name Ty' X') :- !,
  eta-perm Perm Nb Ty X Ty' X'.


pred term->gr i:term, o:@gref.
term->gr (const GR) GR :- !.
term->gr (indt GR) GR :- !.
term->gr (indc GR) GR :- !.
term->gr Term GR :- !, $coq-say "term-gr, global reference term expected:" Term, fail.

pred instance->term i:instance, o:term.
instance->term (instance Term _Priority) Term :- !.

pred with-TC i:term, i:(term -> term -> prop -> prop), i:prop.
%@log(with-TC _ _ _).
with-TC Class TyHyp Pred :-
  coq-TC-db-for {term->gr Class} Instances,
  InstanceHyp = (i\ p\ sigma T Ty\
    instance->term i T, coq-env-typeof-gr {term->gr T} Ty, TyHyp T Ty p),
  map Instances InstanceHyp Hyps,
  Hyps => Pred.

pred goal->ctx i:term, o:(list term).
goal->ctx (?? _ Ctx) Ctx.

pred ctx->TC i:(list term), o:(list (pair term term)).
ctx->TC [] [] :- !.
ctx->TC [X|Xs] [pr X Ty|Is] :- (coq-decl X _ Ty; coq-def X _ _ _ Ty), !,
  ctx->TC Xs Is.
