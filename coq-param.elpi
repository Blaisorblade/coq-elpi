/* coq-elpi: Coq terms as the object language of elpi                        */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

pred param i:term, o:term, o:term.
% @log(param _ _ _).
param (sort _ as P) P
  (lam "s" P x\ lam "s" P y\ prod "s" x _\ prod "s" y _\ P) :- !.

param (lam N T B) (lam N T1 B1)
      (lam N T x\ lam N T1 x1\ lam N (app [TR,x,x1]) xR\ BR x x1 xR) :- !,
  param T T1 TR,
  pi x x1 xR\ param x x1 xR => param (B x) (B1 x1) (BR x x1 xR).

param (prod N T P as Prod) Prod1 ProdR :- !,
  param T T1 TR,
  pi x x1 xR\ param x x1 xR => param (P x) (P1 x1) (PR x x1 xR),
  Prod1 = prod N T1 P1,
  ProdR = lam "f" Prod f\ lam "g" Prod1 g\
       prod N T x\ prod N T1 x1\ prod N (app [TR,x,x1]) xR\
        app [PR x x1 xR, app [f, x], app [g, x1]].

param (app [A|Bs]) (app [A1|Bs1]) (app [AR|BsR]) :- !,
   param A A1 AR, param-args Bs Bs1 BsR.

param-args [] [] [] :- !.
param-args [X|Xs] [X1|Xs1] [X,X1,XR|XsR] :- !,
  param X X1 XR, param-args Xs Xs1 XsR.

map-param [] [] [] :- !.
map-param [X|Xs] [X1|Xs1] [XR|XsR]:- !,
  param X X1 XR, map-param Xs Xs1 XsR.

param (let N T V B) Let1 LetR :- !,
  param T T1 TR, param V V1 VR,
  pi x x1 xR\ param x x1 xR => param (B x) (B1 x1) (BR x x1 xR),
  Let1 = let N T1 V1 B1,
  LetR = let N T V x\ let N T1 V1 x1\ let N TR VR xR\ BR x x1 xR.

param (fix N Rno T F as Fix) Fix1 FixR :- !,
  param T T1 TR,
  pi x x1 xR\ param x x1 xR => param (F x) (F1 x1) (FR x x1 xR),
  RnoR is Rno + Rno + Rno + 2,
  Fix1 = fix N Rno T1 F1,
  FixR = fix N RnoR (app [TR, Fix, Fix1]) xR\ FR Fix Fix1 xR.

pred param-match i:term, o:term, o:((term -> term) -> (term -> term) -> term).
% @log(param-match _ _ _).
param-match (lam N T B) P1 PRM :- pi x\ coq-typecheck (B x) (sort _), !,
  param T T1 TR,
  pi x x1 xR\ param x x1 xR => param (B x) (B1 x1) (BR x x1 xR),
  P1 = lam N T1 B1,
  pi z z1\ PRM z z1 = lam N T x\ lam N T1 x1\ lam N (app [TR,x,x1]) xR\
         app [BR x x1 xR, z x, z1 x1].

param-match (lam N T B) P1 PRM :-
  param T T1 TR,
  pi x x1 xR\ param x x1 xR => param-match (B x) (B1 x1) (BR x x1 xR),
  P1 = lam N T1 B1,
  pi z z1\ PRM z z1 = lam N T x\ lam N T1 x1\ lam N (app [TR,x,x1]) xR\
        BR x x1 xR z z1.

type $$=> list prop -> prop -> prop.
param (match T P Bs) M1 MR :- !,
  param T T1 TR,
  param-match P P1 PRM,
  [param T T1 TR] => map-param Bs Bs1 BsR,
  M1 = match T1 P1 Bs1,
  MR = match TR (PRM (x\ match x P Bs) (x\ match x P1 Bs1)) BsR.

% param (indt _) hole hole. % TODO
% param (indc _) hole hole. %TODO

derive-param Name :-
  coq-locate Name (const GR),
  coq-env-const GR BO TY,
  $coq-say "BO=" BO,
  param BO _ PBO,
  $coq-say "PBO=" PBO,
  coq-typecheck PBO PBTy.
