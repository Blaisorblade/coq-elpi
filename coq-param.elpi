/* coq-elpi: Coq terms as the object language of elpi                        */
/* license: GNU Lesser General Public License Version 2.1 or later           */
/* ------------------------------------------------------------------------- */

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% extra typing declarations %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

type indc string -> term.
type indt string -> term.
type $$=> list prop -> prop -> prop.

%%%%%%%%%%%%%%%%%%%
% generic helpers %
%%%%%%%%%%%%%%%%%%%

mk-eta (prod N T P) B (lam N T B') :- !,
  pi x \ mk-eta (P x) (app [B, x]) (B' x).
mk-eta P B B :- !.

pred with-TC i:term, i:(instance -> prop -> prop), i:prop.
% @log(with-TC _ _ _).
with-TC (indt GR) Map Pred :-
  coq-TC-db-for GR Instances,
%  coq-say Instances,
  map Instances Map Hyps,
  Hyps => Pred.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parametricty translation %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred param i:term, o:term, o:term.

param-args [] [] [] :- !.
param-args [X|Xs] [X1|Xs1] [X,X1,XR|XsR] :- !,
  param X X1 XR, param-args Xs Xs1 XsR.

map-param [] [] [] :- !.
map-param [X|Xs] [X1|Xs1] [XR|XsR]:- !,
  param X X1 XR, map-param Xs Xs1 XsR.

param (sort _ as P) P
  (lam "s" P x\ lam "s" P y\ prod "s" x _\ prod "s" y _\ P) :- !.

param (lam N T B) (lam N T1 B1)
      (lam N T x\ lam N T1 x1\ lam N (app [TR,x,x1]) xR\ BR x x1 xR) :- !,
  param T T1 TR,
  pi x x1 xR\ param x x1 xR => param (B x) (B1 x1) (BR x x1 xR).

param (prod N T P as Prod) Prod1 ProdR :- !,
  param T T1 TR,
  pi x x1 xR\ param x x1 xR => param (P x) (P1 x1) (PR x x1 xR),
  Prod1 = prod N T1 P1,
  ProdR = lam "f" Prod f\ lam "g" Prod1 g\
       prod N T x\ prod N T1 x1\ prod N (app [TR,x,x1]) xR\
        app [PR x x1 xR, app [f, x], app [g, x1]].

param (app [A|Bs]) (app [A1|Bs1]) (app [AR|BsR]) :- !,
   param A A1 AR, param-args Bs Bs1 BsR.

param (let N T V B) Let1 LetR :- !,
  param T T1 TR, param V V1 VR,
  pi x x1 xR\ param x x1 xR => param (B x) (B1 x1) (BR x x1 xR),
  Let1 = let N T1 V1 B1,
  LetR = let N T V x\ let N T1 V1 x1\ let N TR VR xR\ BR x x1 xR.

param (match T P Bs) M1 MR :- !,
  param T T1 TR, param-match P P1 PRM,
  param T T1 TR => map-param Bs Bs1 BsR,
  M1 = match T1 P1 Bs1,
  MR = match TR (PRM (x\ match x P Bs) (x\ match x P1 Bs1)) BsR.

param (fix N Rno T F as Fix) Fix1 TypedFixR :- !,
  param T T1 TR,
  pi x x1 xR\ param x x1 xR =>
    param (F x) (F1 x1) (FR x x1 xR),
  Rno0 is Rno + Rno + Rno, Rno1 is Rno0 + 1, RnoR is Rno1 + 1,
  Fix1 = fix N Rno T1 F1,
  coq-typecheck (lam "f" T f\ lam "g" T1 f1\
                 lam "xR" (app [TR, f, f1]) xR\ FR f f1 xR) Ty,
  % TODO: add typing constraints for U and U1 before unification
  unify-eq Ty (prod _ Tf f\ prod _ Tf1 f1\ prod _ (_ f f1) xR\
               app [TR, U f, U1 f1]),
  coq-typecheck (lam "x" Tf U) Tu, coq-typecheck (lam "x" Tf1 U1) Tu1,
  (pi f f1 xR u u1 h\ transport Rno1 {subst-lam [app [u,f], f1] TR} []
        h (F'Body f f1 xR u u1 h)),
  (pi f f1 xR u u1 h\ transport Rno0 {subst-lam [f, f1] TR} []
        h (FBody f f1 xR u u1 h)),
  (pi f f1 xR\ FixBody f f1 xR =
         let "U" Tu (lam "x" Tf U) u\
         let "U1" Tu1 (lam "x" Tf1 U1) u1\
	 let "FR" (app [TR, app [u,f], app[u1,f1]]) (FR f f1 xR) fr\
         let "F'" (app [TR, app [u,f], f1]) (F'Body f f1 xR u u1 fr) g'\
         let "F" (app [TR, f, f1]) (FBody f f1 xR u u1 g') g \ g),
  (pi f f1\ subst-lam [f, f1] TR (TRff1 f f1)),
  (pi f f1 xR\ mk-eta (TRff1 f f1) (FixBody f f1 xR) (EtaFixBody f f1 xR)),
  TypedFixR = (let N T Fix f\ let N T1 Fix1 f1\
         fix N RnoR (TRff1 f f1) xR\ EtaFixBody f f1 xR).

% helpers for fitting the type of the match with the one of fix

transport Rno (prod N T P) Args H (lam N T B) :- Rno > 0, !,
  Rno' is Rno - 1,
  pi x \ transport Rno' (P x) [x|Args] H (B x).
transport 0 (prod N T P) Args H Transport :- !,
  (pi x\ rev [x|Args] (RArgs x)),
  mk-trivial-match T (x \ app[H|RArgs x]) Branches,
  Transport = (lam N T x \ match x (lam N T x\ P x) Branches).

mk-branch-lams T F K (prod N T B) (lam N T B1) :- !,
  pi x\ mk-branch-lams T F {mk-app K [x]} (B x) (B1 x).
mk-branch-lams T F K Ty (let "K" T K x \ F x).

mk-trivial-match T F Branches :-
  safe-dest-app T (indt Name) Args,
  coq-env-indt Name _ Lno _ _ Knames KTypes,
  split-at Lno Args LArgs _,
  map KTypes (subst-prod LArgs) LKTypes,
  map2 Knames LKTypes (mk-branch-lams T F) Branches.

% helpers for match return type

pred param-match i:term, o:term, o:((term -> term) -> (term -> term) -> term).
param-match (lam N T B) P1 PRM :- pi x\ not (B x = lam (_ x) (_ x) (_ x)), !,
  param T T1 TR,
  pi x x1 xR\ param x x1 xR => param (B x) (B1 x1) (BR x x1 xR),
  P1 = lam N T1 B1,
  pi z z1\ PRM z z1 = lam N T x\ lam N T1 x1\ lam N (app [TR,x,x1]) xR\
         app [BR x x1 xR, z x, z1 x1].

param-match (lam N T B) P1 PRM :-
  param T T1 TR,
  pi x x1 xR\ param x x1 xR => param-match (B x) (B1 x1) (BR x x1 xR),
  P1 = lam N T1 B1,
  pi z z1\ PRM z z1 = lam N T x\ lam N T1 x1\ lam N (app [TR,x,x1]) xR\
        BR x x1 xR z z1.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% translation of inductive types %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred param-indt i:@gref, i:bool, i:int, i:int, i:term, i:list term, i:list term,
     i:string, o:bool, o:int, o:int, o:term, o:list term, o:list term.
param-indt GR IsInd Lno Luno Ty Knames Ktypes
 	   NameR IsInd LnoR LunoR TyR KnamesR KtypesR :- !,
  LnoR is Lno + Lno + Lno,
  LunoR is Luno + Luno + Luno,
  param (indt GR) (indt GR) (indt NameR) =>
    (param Ty _ TyR,
     map Knames (rename-indc NameR) KnamesR,
     map2 Knames Ktypes param-indc KtypesR).
 
pred rename-indc i:string, i:term, o:term.
rename-indc NameR (indc GR) (indc NameR') :-
  coq-gr->string GR Name,
  NameR' is NameR ^ "_" ^ Name.

pred rename-indc i:term, i:term, o:term.
param-indc K T TRK :- !,
  param T _ TR, TRK = app [TR, K, K].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Class storage functions: %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pred retrieve-param i:instance, o:prop.
retrieve-param (instance I _) (param X X1 XR) :- !,
  coq-typecheck I Ty,
  Ty = app [_, _, _, _, X, X1, XR].

pred store-param-all-indc i:(list term), o:(list term).
% @log(store-param-all-indc _ _).
store-param-all-indc [] [] :- !. 
store-param-all-indc [K|Ks] [KR|KRs] :- !,
  KR = indc GR,
  store-param GR K K KR, store-param-all-indc Ks KRs.

pred store-param i:string, i:term, i:term, i:term.
@log(store-param _ _ _ _).
store-param N X X1 XR :- !,
  Nparam is "param_" ^ {coq-gr->string N},
  coq-typecheck X Ty, coq-typecheck X1 Ty1, coq-typecheck XR TyR,
  Args = [Ty, Ty1, TyR, X, X1, XR],
  coq-env-add-const Nparam (app [{{@store_param}}|Args])
                           (app [{{@param_db}}   |Args]) (const GR),
  coq-TC-declare-instance GR 0 tt.

%%%%%%%%%%%%%%%%%%%%%%%
% toplevel predicates %
%%%%%%%%%%%%%%%%%%%%%%%

pred param-const i:term, o:term, o:term, o:term, o:term, o:term.
param-const (const GR as Const) Ty X1 Ty1 XR TyR :- !,
  coq-env-const GR X Ty,
  with-TC {{@param_db}} retrieve-param (param X X1 XR),
  coq-typecheck X1 Ty1,
  coq-typecheck XR TyR.

pred env-add-param i:term, i:string.
env-add-param (const GR as Term) NameR :- !,
  param-const Term Ty X1 Ty1 XR TyR,
  coq-env-add-const NameR XR TyR TermR,
  store-param NameR Term Term TermR.

pred env-add-param i:term, i:string.
env-add-param (indt GR as Ind) NameR :- !,
  coq-env-indt GR IsInd Lno Luno Ty Knames Ktypes,
  coq-env-indt->decl Ty Lno Ind Knames Ktypes Decl,
  with-TC {{@param_db}} retrieve-param 
     (param-indt GR IsInd Lno Luno Ty Knames Ktypes
 	   	 NameR IsIndR LnoR LunoR TyR KnamesR KtypesR),
  coq-env-indt->decl {subst-lam [Ind, Ind] TyR} LnoR 
      (indt NameR) KnamesR KtypesR DeclR,
  coq-env-add-indt DeclR (indt GRR),
  store-param NameR Ind Ind (indt GRR),
  coq-env-indt GRR _ _ _ _ RealNamesR _,
  store-param-all-indc Knames RealNamesR.


